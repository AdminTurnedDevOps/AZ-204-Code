{"version":3,"file":"BufferScheduler.js","sourceRoot":"","sources":["../../../src/utils/BufferScheduler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventEmitter } from \"events\";\nimport { Readable } from \"stream\";\n\n/**\n * OutgoingHandler is an async function triggered by BufferScheduler.\n */\nexport declare type OutgoingHandler = (buffer: Buffer, offset?: number) => Promise<any>;\n\n/**\n * This class accepts a Node.js Readable stream as input, and keeps reading data\n * from the stream into the internal buffer structure, until it reaches maxBuffers.\n * Every available buffer will try to trigger outgoingHandler.\n *\n * The internal buffer structure includes an incoming buffer array, and a outgoing\n * buffer array. The incoming buffer array includes the \"empty\" buffers can be filled\n * with new incoming data. The outgoing array includes the filled buffers to be\n * handled by outgoingHandler. Every above buffer size is defined by parameter bufferSize.\n *\n * NUM_OF_ALL_BUFFERS = BUFFERS_IN_INCOMING + BUFFERS_IN_OUTGOING + BUFFERS_UNDER_HANDLING\n *\n * NUM_OF_ALL_BUFFERS <= maxBuffers\n *\n * PERFORMANCE IMPROVEMENT TIPS:\n * 1. Input stream highWaterMark is better to set a same value with bufferSize\n *    parameter, which will avoid Buffer.concat() operations.\n * 2. concurrency should set a smaller value than maxBuffers, which is helpful to\n *    reduce the possibility when a outgoing handler waits for the stream data.\n *    in this situation, outgoing handlers are blocked.\n *    Outgoing queue shouldn't be empty.\n * @export\n * @class BufferScheduler\n */\nexport class BufferScheduler {\n  /**\n   * Size of buffers in incoming and outgoing queues. This class will try to align\n   * data read from Readable stream into buffer chunks with bufferSize defined.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private readonly bufferSize: number;\n\n  /**\n   * How many buffers can be created or maintained.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private readonly maxBuffers: number;\n\n  /**\n   * A Node.js Readable stream.\n   *\n   * @private\n   * @type {Readable}\n   * @memberof BufferScheduler\n   */\n  private readonly readable: Readable;\n\n  /**\n   * OutgoingHandler is an async function triggered by BufferScheduler when there\n   * are available buffers in outgoing array.\n   *\n   * @private\n   * @type {OutgoingHandler}\n   * @memberof BufferScheduler\n   */\n  private readonly outgoingHandler: OutgoingHandler;\n\n  /**\n   * An internal event emitter.\n   *\n   * @private\n   * @type {EventEmitter}\n   * @memberof BufferScheduler\n   */\n  private readonly emitter: EventEmitter = new EventEmitter();\n\n  /**\n   * Concurrency of executing outgoingHandlers. (0 < concurrency <= maxBuffers)\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private readonly concurrency: number;\n\n  /**\n   * An internal offset marker to track data offset in bytes of next outgoingHandler.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private offset: number = 0;\n\n  /**\n   * An internal marker to track whether stream is end.\n   *\n   * @private\n   * @type {boolean}\n   * @memberof BufferScheduler\n   */\n  private isStreamEnd: boolean = false;\n\n  /**\n   * An internal marker to track whether stream or outgoingHandler returns error.\n   *\n   * @private\n   * @type {boolean}\n   * @memberof BufferScheduler\n   */\n  private isError: boolean = false;\n\n  /**\n   * How many handlers are executing.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private executingOutgoingHandlers: number = 0;\n\n  /**\n   * Encoding of the input Readable stream which has string data type instead of Buffer.\n   *\n   * @private\n   * @type {string}\n   * @memberof BufferScheduler\n   */\n  private encoding?: string;\n\n  /**\n   * How many buffers have been allocated.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private numBuffers: number = 0;\n\n  /**\n   * Because this class doesn't know how much data every time stream pops, which\n   * is defined by highWaterMarker of the stream. So BufferScheduler will cache\n   * data received from the stream, when data in unresolvedDataArray exceeds the\n   * blockSize defined, it will try to concat a blockSize of buffer, fill into available\n   * buffers from incoming and push to outgoing array.\n   *\n   * @private\n   * @type {Buffer[]}\n   * @memberof BufferScheduler\n   */\n  private unresolvedDataArray: Buffer[] = [];\n\n  /**\n   * How much data consisted in unresolvedDataArray.\n   *\n   * @private\n   * @type {number}\n   * @memberof BufferScheduler\n   */\n  private unresolvedLength: number = 0;\n\n  /**\n   * The array includes all the available buffers can be used to fill data from stream.\n   *\n   * @private\n   * @type {Buffer[]}\n   * @memberof BufferScheduler\n   */\n  private incoming: Buffer[] = [];\n\n  /**\n   * The array (queue) includes all the buffers filled from stream data.\n   *\n   * @private\n   * @type {Buffer[]}\n   * @memberof BufferScheduler\n   */\n  private outgoing: Buffer[] = [];\n\n  /**\n   * Creates an instance of BufferScheduler.\n   *\n   * @param {Readable} readable A Node.js Readable stream\n   * @param {number} bufferSize Buffer size of every maintained buffer\n   * @param {number} maxBuffers How many buffers can be allocated\n   * @param {OutgoingHandler} outgoingHandler An async function scheduled to be\n   *                                          triggered when a buffer fully filled\n   *                                          with stream data\n   * @param {number} concurrency Concurrency of executing outgoingHandlers (>0)\n   * @param {string} [encoding] [Optional] Encoding of Readable stream when it's a string stream\n   * @memberof BufferScheduler\n   */\n  constructor(\n    readable: Readable,\n    bufferSize: number,\n    maxBuffers: number,\n    outgoingHandler: OutgoingHandler,\n    concurrency: number,\n    encoding?: string\n  ) {\n    if (bufferSize <= 0) {\n      throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);\n    }\n\n    if (maxBuffers <= 0) {\n      throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);\n    }\n\n    if (concurrency <= 0) {\n      throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);\n    }\n\n    this.bufferSize = bufferSize;\n    this.maxBuffers = maxBuffers;\n    this.readable = readable;\n    this.outgoingHandler = outgoingHandler;\n    this.concurrency = concurrency;\n    this.encoding = encoding;\n  }\n\n  /**\n   * Start the scheduler, will return error when stream of any of the outgoingHandlers\n   * returns error.\n   *\n   * @returns {Promise<void>}\n   * @memberof BufferScheduler\n   */\n  public async do(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.readable.on(\"data\", (data) => {\n        data = typeof data === \"string\" ? Buffer.from(data, this.encoding) : data;\n        this.appendUnresolvedData(data);\n\n        if (!this.resolveData()) {\n          this.readable.pause();\n        }\n      });\n\n      this.readable.on(\"error\", (err) => {\n        this.emitter.emit(\"error\", err);\n      });\n\n      this.readable.on(\"end\", () => {\n        this.isStreamEnd = true;\n        this.emitter.emit(\"checkEnd\");\n      });\n\n      this.emitter.on(\"error\", (err) => {\n        this.isError = true;\n        this.readable.pause();\n        reject(err);\n      });\n\n      this.emitter.on(\"checkEnd\", () => {\n        if (this.outgoing.length > 0) {\n          this.triggerOutgoingHandlers();\n          return;\n        }\n\n        if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {\n          if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {\n            this.outgoingHandler(this.shiftBufferFromUnresolvedDataArray(), this.offset)\n              .then(resolve)\n              .catch(reject);\n          } else if (this.unresolvedLength >= this.bufferSize) {\n            return;\n          } else {\n            resolve();\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Insert a new data into unresolved array.\n   *\n   * @private\n   * @param {Buffer} data\n   * @memberof BufferScheduler\n   */\n  private appendUnresolvedData(data: Buffer) {\n    this.unresolvedDataArray.push(data);\n    this.unresolvedLength += data.length;\n  }\n\n  /**\n   * Try to shift a buffer with size in blockSize. The buffer returned may be less\n   * than blockSize when data in unresolvedDataArray is less than bufferSize.\n   *\n   * @private\n   * @returns {Buffer}\n   * @memberof BufferScheduler\n   */\n  private shiftBufferFromUnresolvedDataArray(): Buffer {\n    if (this.unresolvedLength >= this.bufferSize) {\n      if (this.bufferSize === this.unresolvedDataArray[0].length) {\n        this.unresolvedLength -= this.bufferSize;\n        return this.unresolvedDataArray.shift()!;\n      }\n\n      // Lazy concat because Buffer.concat highly drops performance\n      let merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);\n      const buffer = merged.slice(0, this.bufferSize);\n      merged = merged.slice(this.bufferSize);\n      this.unresolvedDataArray = [merged];\n      this.unresolvedLength -= buffer.length;\n      return buffer;\n    } else if (this.unresolvedLength > 0) {\n      const merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);\n      this.unresolvedDataArray = [];\n      this.unresolvedLength = 0;\n      return merged;\n    } else {\n      return Buffer.allocUnsafe(0);\n    }\n  }\n\n  /**\n   * Resolve data in unresolvedDataArray. For every buffer with size in blockSize\n   * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,\n   * then push it into outgoing to be handled by outgoing handler.\n   *\n   * Return false when available buffers in incoming are not enough, else true.\n   *\n   * @private\n   * @returns {boolean} Return false when buffers in incoming are not enough, else true.\n   * @memberof BufferScheduler\n   */\n  private resolveData(): boolean {\n    while (this.unresolvedLength >= this.bufferSize) {\n      let buffer: Buffer;\n\n      if (this.incoming.length > 0) {\n        buffer = this.incoming.shift()!;\n      } else {\n        if (this.numBuffers < this.maxBuffers) {\n          buffer = Buffer.allocUnsafe(this.bufferSize);\n          this.numBuffers++;\n        } else {\n          // No available buffer, wait for buffer returned\n          return false;\n        }\n      }\n\n      buffer.fill(this.shiftBufferFromUnresolvedDataArray());\n      this.outgoing.push(buffer);\n      this.triggerOutgoingHandlers();\n    }\n    return true;\n  }\n\n  /**\n   * Try to trigger a outgoing handler for every buffer in outgoing. Stop when\n   * concurrency reaches.\n   *\n   * @private\n   * @memberof BufferScheduler\n   */\n  private async triggerOutgoingHandlers() {\n    let buffer: Buffer | undefined;\n    do {\n      if (this.executingOutgoingHandlers >= this.concurrency) {\n        return;\n      }\n\n      buffer = this.outgoing.shift();\n      if (buffer) {\n        this.triggerOutgoingHandler(buffer);\n      }\n    } while (buffer);\n  }\n\n  /**\n   * Trigger a outgoing handler for a buffer shifted from outgoing.\n   *\n   * @private\n   * @param {Buffer} buffer\n   * @returns {Promise<any>}\n   * @memberof BufferScheduler\n   */\n  private async triggerOutgoingHandler(buffer: Buffer): Promise<any> {\n    const bufferLength = buffer.length;\n\n    this.executingOutgoingHandlers++;\n    this.offset += bufferLength;\n\n    try {\n      await this.outgoingHandler(buffer, this.offset - bufferLength);\n    } catch (err) {\n      this.emitter.emit(\"error\", err);\n      return;\n    }\n\n    this.executingOutgoingHandlers--;\n    this.reuseBuffer(buffer);\n    this.emitter.emit(\"checkEnd\");\n  }\n\n  /**\n   * Return buffer used by outgoing handler into incoming.\n   *\n   * @private\n   * @param {Buffer} buffer\n   * @memberof BufferScheduler\n   */\n  private reuseBuffer(buffer: Buffer) {\n    this.incoming.push(buffer);\n    if (!this.isError && this.resolveData() && !this.isStreamEnd) {\n      this.readable.resume();\n    }\n  }\n}\n"]}