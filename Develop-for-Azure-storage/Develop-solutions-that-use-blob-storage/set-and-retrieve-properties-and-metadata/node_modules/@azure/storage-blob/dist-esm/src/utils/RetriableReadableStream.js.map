{"version":3,"file":"RetriableReadableStream.js","sourceRoot":"","sources":["../../../src/utils/RetriableReadableStream.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,kCAAkC;;AAGlC,OAAO,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAElC,OAAO,EAAE,WAAW,EAAmB,UAAU,EAAE,MAAM,yBAAyB,CAAC;AA4CnF,IAAM,WAAW,GAAG,IAAI,UAAU,CAAC,4BAA4B,CAAC,CAAC;AAEjE;;;;;;;GAOG;AACH;IAA6C,2CAAQ;IAgBnD;;;;;;;;;;OAUG;IACH,iCACE,MAA6B,EAC7B,MAA4B,EAC5B,MAAc,EACd,KAAa,EACb,OAA4C;QAA5C,wBAAA,EAAA,YAA4C;QAL9C,YAOE,iBAAO,SAiBR;QA5CO,aAAO,GAAW,CAAC,CAAC;QAIpB,kBAAY,GAAG;YACrB,KAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACpB,KAAI,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;QAClC,CAAC,CAAC;QAqBA,KAAI,CAAC,OAAO,GAAG,OAAO,CAAC,WAAW,IAAI,WAAW,CAAC,IAAI,CAAC;QACvD,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,KAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QACpB,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,KAAI,CAAC,GAAG,GAAG,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC;QAC9B,KAAI,CAAC,gBAAgB;YACnB,OAAO,CAAC,gBAAgB,IAAI,OAAO,CAAC,gBAAgB,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3F,KAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,KAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,KAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAI,CAAC,YAAY,CAAC,CAAC;QAE1D,KAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,KAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,KAAI,CAAC,qBAAqB,EAAE,CAAC;;IAC/B,CAAC;IAEM,uCAAK,GAAZ;QACE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;YACzB,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;SACtB;IACH,CAAC;IAEO,sDAAoB,GAA5B;QAAA,iBAqBC;QApBC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,UAAC,IAAY;YAClC,IAAI,KAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE;gBAClC,KAAI,CAAC,OAAO,CAAC,iBAAiB,GAAG,SAAS,CAAC;gBAC3C,KAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;gBACpB,KAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;gBACvC,KAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxB,OAAO;aACR;YAED,eAAe;YACf,2EAA2E;YAC3E,KAAK;YACL,KAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;YAC3B,IAAI,KAAI,CAAC,UAAU,EAAE;gBACnB,KAAI,CAAC,UAAU,CAAC,EAAE,WAAW,EAAE,KAAI,CAAC,MAAM,GAAG,KAAI,CAAC,KAAK,EAAE,CAAC,CAAC;aAC5D;YACD,IAAI,CAAC,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACpB,KAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;aACrB;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,qDAAmB,GAA3B;QAAA,iBAiDC;QAhDC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE;YACpB,eAAe;YACf,yCAAyC;YACzC,kBAAkB;YAClB,+BAA+B;YAC/B,KAAK;YACL,IAAI,KAAI,CAAC,MAAM,GAAG,CAAC,KAAK,KAAI,CAAC,GAAG,EAAE;gBAChC,KAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAI,CAAC,YAAY,CAAC,CAAC;gBAC7D,KAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACjB;iBAAM,IAAI,KAAI,CAAC,MAAM,IAAI,KAAI,CAAC,GAAG,EAAE;gBAClC,eAAe;gBACf,gEAAgE;gBAChE,KAAK;gBACL,IAAI,KAAI,CAAC,OAAO,GAAG,KAAI,CAAC,gBAAgB,EAAE;oBACxC,KAAI,CAAC,OAAO,IAAI,CAAC,CAAC;oBAClB,KAAI,CAAC,MAAM,CAAC,KAAI,CAAC,MAAM,CAAC;yBACrB,IAAI,CAAC,UAAC,SAAS;wBACd,KAAI,CAAC,MAAM,GAAG,SAAS,CAAC;wBACxB,KAAI,CAAC,oBAAoB,EAAE,CAAC;wBAC5B,KAAI,CAAC,mBAAmB,EAAE,CAAC;wBAC3B,KAAI,CAAC,qBAAqB,EAAE,CAAC;oBAC/B,CAAC,CAAC;yBACD,KAAK,CAAC,UAAC,KAAK;wBACX,KAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;oBAC5B,CAAC,CAAC,CAAC;iBACN;qBAAM;oBACL,KAAI,CAAC,IAAI,CACP,OAAO,EACP,IAAI,KAAK;oBACP,2CAA2C;oBAC3C,yHAAsH,KAAI;yBACvH,MAAM,GAAG,CAAC,+BAAyB,KAAI,CAAC,GAAG,mBAC5C,KAAI,CAAC,OAAO,uBACI,KAAI,CAAC,gBAAkB,CAC1C,CACF,CAAC;iBACH;aACF;iBAAM;gBACL,KAAI,CAAC,IAAI,CACP,OAAO,EACP,IAAI,KAAK,CACP,8FACE,KAAI,CAAC,GAAG,4BACY,KAAI,CAAC,MAAM,GAAG,CAAC,CAAE,CACxC,CACF,CAAC;aACH;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,uDAAqB,GAA7B;QAAA,iBAIC;QAHC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,UAAC,KAAK;YAC5B,KAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC5B,CAAC,CAAC,CAAC;IACL,CAAC;IACH,8BAAC;AAAD,CAAC,AA1ID,CAA6C,QAAQ,GA0IpD","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { TransferProgressEvent } from \"@azure/core-http\";\nimport { Readable } from \"stream\";\n\nimport { AbortSignal, AbortSignalLike, AbortError } from \"@azure/abort-controller\";\n\nexport type ReadableStreamGetter = (offset: number) => Promise<NodeJS.ReadableStream>;\n\nexport interface RetriableReadableStreamOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   *\n   * @type {AbortSignalLike}\n   * @memberof RetriableReadableStreamOptions\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Max retry count (>=0), undefined or invalid value means no retry\n   *\n   * @type {number}\n   * @memberof RetriableReadableStreamOptions\n   */\n  maxRetryRequests?: number;\n\n  /**\n   * Read progress event handler\n   *\n   * @memberof RetriableReadableStreamOptions\n   */\n  onProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Debug purpose only. Used to inject an unexpected end to existing internal stream,\n   * to test stream retry works well or not.\n   *\n   * When assign it to true, for next incoming \"data\" event of internal stream,\n   * RetriableReadableStream will try to emit an \"end\" event to existing internal\n   * stream to force it end and start retry from the breaking point.\n   * The value will then update to \"undefined\", once the injection works.\n   *\n   * @type {boolean}\n   * @memberof RetriableReadableStreamOptions\n   */\n  doInjectErrorOnce?: boolean;\n}\n\nconst ABORT_ERROR = new AbortError(\"The operation was aborted.\");\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.\n *\n * @class RetriableReadableStream\n * @extends {Readable}\n */\nexport class RetriableReadableStream extends Readable {\n  private aborter: AbortSignalLike;\n  private start: number;\n  private offset: number;\n  private end: number;\n  private getter: ReadableStreamGetter;\n  private source: NodeJS.ReadableStream;\n  private retries: number = 0;\n  private maxRetryRequests: number;\n  private onProgress?: (progress: TransferProgressEvent) => void;\n  private options: RetriableReadableStreamOptions;\n  private abortHandler = () => {\n    this.source.pause();\n    this.emit(\"error\", ABORT_ERROR);\n  };\n\n  /**\n   * Creates an instance of RetriableReadableStream.\n   *\n   * @param {NodeJS.ReadableStream} source The current ReadableStream returned from getter\n   * @param {ReadableStreamGetter} getter A method calling downloading request returning\n   *                                      a new ReadableStream from specified offset\n   * @param {number} offset Offset position in original data source to read\n   * @param {number} count How much data in original data source to read\n   * @param {RetriableReadableStreamOptions} [options={}]\n   * @memberof RetriableReadableStream\n   */\n  public constructor(\n    source: NodeJS.ReadableStream,\n    getter: ReadableStreamGetter,\n    offset: number,\n    count: number,\n    options: RetriableReadableStreamOptions = {}\n  ) {\n    super();\n    this.aborter = options.abortSignal || AbortSignal.none;\n    this.getter = getter;\n    this.source = source;\n    this.start = offset;\n    this.offset = offset;\n    this.end = offset + count - 1;\n    this.maxRetryRequests =\n      options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;\n    this.onProgress = options.onProgress;\n    this.options = options;\n\n    this.aborter.addEventListener(\"abort\", this.abortHandler);\n\n    this.setSourceDataHandler();\n    this.setSourceEndHandler();\n    this.setSourceErrorHandler();\n  }\n\n  public _read() {\n    if (!this.aborter.aborted) {\n      this.source.resume();\n    }\n  }\n\n  private setSourceDataHandler() {\n    this.source.on(\"data\", (data: Buffer) => {\n      if (this.options.doInjectErrorOnce) {\n        this.options.doInjectErrorOnce = undefined;\n        this.source.pause();\n        this.source.removeAllListeners(\"data\");\n        this.source.emit(\"end\");\n        return;\n      }\n\n      // console.log(\n      //   `Offset: ${this.offset}, Received ${data.length} from internal stream`\n      // );\n      this.offset += data.length;\n      if (this.onProgress) {\n        this.onProgress({ loadedBytes: this.offset - this.start });\n      }\n      if (!this.push(data)) {\n        this.source.pause();\n      }\n    });\n  }\n\n  private setSourceEndHandler() {\n    this.source.on(\"end\", () => {\n      // console.log(\n      //   `Source stream emits end, offset: ${\n      //     this.offset\n      //   }, dest end : ${this.end}`\n      // );\n      if (this.offset - 1 === this.end) {\n        this.aborter.removeEventListener(\"abort\", this.abortHandler);\n        this.push(null);\n      } else if (this.offset <= this.end) {\n        // console.log(\n        //   `retries: ${this.retries}, max retries: ${this.maxRetries}`\n        // );\n        if (this.retries < this.maxRetryRequests) {\n          this.retries += 1;\n          this.getter(this.offset)\n            .then((newSource) => {\n              this.source = newSource;\n              this.setSourceDataHandler();\n              this.setSourceEndHandler();\n              this.setSourceErrorHandler();\n            })\n            .catch((error) => {\n              this.emit(\"error\", error);\n            });\n        } else {\n          this.emit(\n            \"error\",\n            new Error(\n              // tslint:disable-next-line:max-line-length\n              `Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this\n                .offset - 1}, data needed offset: ${this.end}, retries: ${\n                this.retries\n              }, max retries: ${this.maxRetryRequests}`\n            )\n          );\n        }\n      } else {\n        this.emit(\n          \"error\",\n          new Error(\n            `Data corruption failure: Received more data than original request, data needed offset is ${\n              this.end\n            }, received offset: ${this.offset - 1}`\n          )\n        );\n      }\n    });\n  }\n\n  private setSourceErrorHandler() {\n    this.source.on(\"error\", (error) => {\n      this.emit(\"error\", error);\n    });\n  }\n}\n"]}