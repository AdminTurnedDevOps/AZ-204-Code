// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __assign, __awaiter, __generator } from "tslib";
import { TestWebResource } from "./testWebResource";
function update(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var _a, client, requestOptions, initialResponse, previousResponse, abortSignal, response, doFinalResponse;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = this.state, client = _a.client, requestOptions = _a.requestOptions, initialResponse = _a.initialResponse, previousResponse = _a.previousResponse;
                    abortSignal = options.abortSignal || (requestOptions && requestOptions.abortSignal);
                    if (!client) {
                        // The client property is assigned to the operation state during the instantiation of the `TestPoller`.
                        // So the client should always exist.
                        // Though `PublicTestOperationState` doesn't have the client property,
                        // so we have to make it optional in `TestOperationState`.
                        throw new Error("The client property should exist");
                    }
                    doFinalResponse = previousResponse && previousResponse.parsedBody.doFinalResponse;
                    if (!!initialResponse) return [3 /*break*/, 2];
                    return [4 /*yield*/, client.sendInitialRequest(new TestWebResource(abortSignal))];
                case 1:
                    response = _b.sent();
                    this.state.initialResponse = response;
                    this.state.isStarted = true;
                    return [3 /*break*/, 6];
                case 2:
                    if (!doFinalResponse) return [3 /*break*/, 4];
                    return [4 /*yield*/, client.sendFinalRequest(new TestWebResource(abortSignal))];
                case 3:
                    response = _b.sent();
                    this.state.isCompleted = true;
                    this.state.result = "Done";
                    this.state.previousResponse = response;
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, client.sendRequest(new TestWebResource(abortSignal))];
                case 5:
                    response = _b.sent();
                    this.state.previousResponse = response;
                    _b.label = 6;
                case 6:
                    if (!response) {
                        throw new Error("Our tests must not run forever");
                    }
                    // Progress only after the poller has started and before the poller is done
                    if (initialResponse && !doFinalResponse && options.fireProgress) {
                        options.fireProgress(this.state);
                    }
                    return [2 /*return*/, makeOperation(this.state)];
            }
        });
    });
}
function cancel(options) {
    if (options === void 0) { options = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var requestOptions, abortSignal, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    requestOptions = this.state.requestOptions;
                    abortSignal = options.abortSignal || (requestOptions && requestOptions.abortSignal);
                    if (!(abortSignal && abortSignal.aborted)) return [3 /*break*/, 2];
                    return [4 /*yield*/, this.update({
                            abortSignal: abortSignal
                        })];
                case 1: 
                // Simulating a try catch of an HTTP request that's given an aborted abortSignal.
                return [2 /*return*/, _a.sent()]; // This will throw
                case 2:
                    if (this.state.unsupportedCancel) {
                        throw new Error("Cancellation not supported");
                    }
                    response = {
                        status: 205
                    };
                    return [2 /*return*/, makeOperation(__assign(__assign({}, this.state), { isCancelled: true, previousResponse: response }))];
            }
        });
    });
}
function toString() {
    return JSON.stringify({
        state: this.state
    });
}
export function makeOperation(state) {
    return {
        state: __assign({}, state),
        update: update,
        cancel: cancel,
        toString: toString
    };
}
//# sourceMappingURL=testOperation.js.map