// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
import assert from "assert";
import { delay, WebResource, HttpHeaders, isNode } from "@azure/core-http";
import { TestClient } from "./utils/testClient";
import { PollerStoppedError, PollerCancelledError } from "../src";
import { TestTokenCredential } from "./utils/testTokenCredential";
var testHttpHeaders = new HttpHeaders();
var testHttpRequest = new WebResource();
var basicResponseStructure = {
    headers: testHttpHeaders,
    parsedBody: {},
    request: testHttpRequest,
    status: 200
};
var initialResponse = __assign(__assign({}, basicResponseStructure), { parsedBody: {
        started: true
    } });
var doFinalResponse = __assign(__assign({}, basicResponseStructure), { parsedBody: {
        doFinalResponse: true
    } });
var finalResponse = __assign(__assign({}, basicResponseStructure), { parsedBody: {
        finished: true
    } });
describe("Long Running Operations - custom client", function () {
    it("can automatically poll a long running operation with one promise", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, poller, result, serializedOperation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses([initialResponse, doFinalResponse, finalResponse]);
                        return [4 /*yield*/, client.startLRO()];
                    case 1:
                        poller = _a.sent();
                        // In our tests, startLRO will do the first request for us
                        assert.equal(client.totalSentRequests, 1);
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 2:
                        result = _a.sent();
                        serializedOperation = JSON.parse(poller.toString());
                        assert.ok(serializedOperation.state.isStarted);
                        assert.ok(poller.initialResponse.parsedBody.started);
                        assert.ok(poller.previousResponse.parsedBody.finished);
                        assert.ok(poller.getOperationState().isCompleted);
                        assert.equal(result, "Done");
                        return [2 /*return*/];
                }
            });
        });
    });
    if (isNode) {
        it("won't throw UnhandledPromiseRejectionWarnings when poll called without pollUntilDone", function () {
            return __awaiter(this, void 0, void 0, function () {
                var client, foundUnhandled, checker, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            client = new TestClient(new TestTokenCredential("my-test-token"));
                            foundUnhandled = false;
                            checker = function () {
                                foundUnhandled = true;
                            };
                            process.once("unhandledRejection", checker);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 5]);
                            return [4 /*yield*/, client.startLRO()];
                        case 2:
                            _a.sent();
                            throw new Error("Test failure");
                        case 3:
                            err_1 = _a.sent();
                            assert.notEqual(err_1.message, "Test failure", "client.startLRO did not throw an error.");
                            // delay(0) gives the event loop a chance emit the UnhandledPromiseRejectionWarning so we can catch it.
                            return [4 /*yield*/, delay(0)];
                        case 4:
                            // delay(0) gives the event loop a chance emit the UnhandledPromiseRejectionWarning so we can catch it.
                            _a.sent();
                            assert.equal(foundUnhandled, false, "An UnhandledPromiseRejectionWarning was thrown.");
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        });
    }
    it("can poll a long running operation with more than one promise", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, poller, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses([initialResponse, doFinalResponse, finalResponse]);
                        return [4 /*yield*/, client.startLRO()];
                    case 1:
                        poller = _a.sent();
                        return [4 /*yield*/, poller.poll()];
                    case 2:
                        _a.sent();
                        assert.ok(poller.previousResponse.parsedBody.doFinalResponse);
                        return [4 /*yield*/, poller.getResult()];
                    case 3:
                        result = _a.sent();
                        assert.equal(result, undefined);
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 4:
                        _a.sent();
                        assert.ok(poller.previousResponse.parsedBody.finished);
                        assert.ok(poller.getOperationState().isCompleted);
                        return [4 /*yield*/, poller.getResult()];
                    case 5:
                        result = _a.sent();
                        assert.equal(result, "Done");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can cancel the operation (when cancellation is supported)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, poller, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses(__spreadArrays([initialResponse], Array(20).fill(basicResponseStructure)));
                        return [4 /*yield*/, client.startLRO()];
                    case 1:
                        poller = _a.sent();
                        assert.equal(client.totalSentRequests, 1);
                        // Testing the cancelled error
                        poller.pollUntilDone().catch(function (e) {
                            assert.ok(e instanceof PollerCancelledError);
                            assert.equal(e.name, "PollerCancelledError");
                            assert.equal(e.message, "Poller cancelled");
                        });
                        // The poller will appear as unstopped, since we're waiting until finishes
                        assert.ok(!poller.isStopped());
                        i = 1;
                        _a.label = 2;
                    case 2:
                        if (!(i <= 10)) return [3 /*break*/, 5];
                        return [4 /*yield*/, poller.poll()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 2];
                    case 5:
                        assert.equal(client.totalSentRequests, 11);
                        return [4 /*yield*/, poller.cancelOperation()];
                    case 6:
                        _a.sent();
                        assert.ok(poller.getOperationState().isCancelled);
                        // Cancelling a poller stops it
                        assert.ok(poller.isStopped());
                        return [2 /*return*/];
                }
            });
        });
    });
    it("fails to cancel the operation (when cancellation is not supported)", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, poller, i, error, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses(__spreadArrays([initialResponse], Array(20).fill(basicResponseStructure)));
                        return [4 /*yield*/, client.startNonCancellableLRO()];
                    case 1:
                        poller = _a.sent();
                        assert.equal(client.totalSentRequests, 1);
                        i = 1;
                        _a.label = 2;
                    case 2:
                        if (!(i <= 10)) return [3 /*break*/, 5];
                        return [4 /*yield*/, poller.poll()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 2];
                    case 5:
                        assert.equal(client.totalSentRequests, 11);
                        _a.label = 6;
                    case 6:
                        _a.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, poller.cancelOperation()];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        e_1 = _a.sent();
                        error = e_1;
                        return [3 /*break*/, 9];
                    case 9:
                        assert.equal(error.message, "Cancellation not supported");
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can stop polling the operation", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, poller, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses(__spreadArrays([initialResponse], Array(20).fill(basicResponseStructure)));
                        return [4 /*yield*/, client.startLRO()];
                    case 1:
                        poller = _a.sent();
                        assert.equal(client.totalSentRequests, 1);
                        poller.pollUntilDone().catch(function (e) {
                            assert.ok(e instanceof PollerStoppedError);
                            assert.equal(e.name, "PollerStoppedError");
                            assert.equal(e.message, "This poller is already stopped");
                        });
                        return [4 /*yield*/, poller.poll()];
                    case 2:
                        _a.sent();
                        assert.equal(client.totalSentRequests, 2);
                        i = 1;
                        _a.label = 3;
                    case 3:
                        if (!(i <= 10)) return [3 /*break*/, 6];
                        return [4 /*yield*/, poller.poll()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 3];
                    case 6:
                        assert.equal(client.totalSentRequests, 12);
                        poller.stopPolling();
                        return [4 /*yield*/, delay(100)];
                    case 7:
                        _a.sent();
                        assert.equal(client.totalSentRequests, 12);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can document progress", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, totalOperationUpdates, poller, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        client.setResponses(__spreadArrays([
                            initialResponse
                        ], Array(10).fill(basicResponseStructure), [
                            doFinalResponse,
                            finalResponse
                        ]));
                        totalOperationUpdates = 0;
                        return [4 /*yield*/, client.startLRO({
                                onProgress: function (_) {
                                    totalOperationUpdates++;
                                }
                            })];
                    case 1:
                        poller = _a.sent();
                        return [4 /*yield*/, poller.pollUntilDone()];
                    case 2:
                        result = _a.sent();
                        assert.equal(result, "Done");
                        assert.equal(poller.getResult(), "Done");
                        // Progress only after the poller has started and before the poller is done
                        assert.equal(totalOperationUpdates, 11);
                        return [2 /*return*/];
                }
            });
        });
    });
    it("can reuse one poller state to instantiate another poller", function () {
        return __awaiter(this, void 0, void 0, function () {
            var client, responses, poller, i, serialized, client2, poller2, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = new TestClient(new TestTokenCredential("my-test-token"));
                        responses = __spreadArrays([
                            initialResponse
                        ], Array(10).fill(basicResponseStructure), [
                            doFinalResponse,
                            finalResponse
                        ]);
                        client.setResponses(responses);
                        return [4 /*yield*/, client.startLRO()];
                    case 1:
                        poller = _a.sent();
                        i = 1;
                        _a.label = 2;
                    case 2:
                        if (!(i <= 10)) return [3 /*break*/, 5];
                        return [4 /*yield*/, poller.poll()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 2];
                    case 5:
                        assert.equal(client.totalSentRequests, 11);
                        serialized = poller.toString();
                        client2 = new TestClient(new TestTokenCredential("my-test-token"));
                        client2.setResponses(responses);
                        return [4 /*yield*/, client2.startLRO({
                                baseOperation: serialized
                            })];
                    case 6:
                        poller2 = _a.sent();
                        assert.equal(client2.totalSentRequests, 1);
                        return [4 /*yield*/, poller2.pollUntilDone()];
                    case 7:
                        result = _a.sent();
                        assert.equal(result, "Done");
                        // The second client doesn't do the first request and goes all the way to the end.
                        assert.equal(client2.totalSentRequests, 12);
                        return [2 /*return*/];
                }
            });
        });
    });
});
//# sourceMappingURL=testClient.test.js.map