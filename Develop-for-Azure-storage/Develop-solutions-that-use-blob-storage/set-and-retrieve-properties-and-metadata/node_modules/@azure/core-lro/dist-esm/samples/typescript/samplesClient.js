"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var src_1 = require("../../src");
var core_http_1 = require("@azure/core-http");
/**
 * A utility method that builds an instance of the sample poll operation with some default methods.
 */
function makeSamplePollOperation(state) {
    return {
        /**
         * To ensure the state is always clean of previously used references, we're making a copy of it.
         */
        state: tslib_1.__assign(tslib_1.__assign({}, state), { previousResponses: tslib_1.__spreadArrays(state.previousResponses) }),
        /**
         * The update method should change the operation's state.
         * In our case, we'll be calling the Client's makeRequest.
         */
        update: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var state, _a, _b;
                return tslib_1.__generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            state = tslib_1.__assign({}, this.state);
                            if (!!state.isStarted) return [3 /*break*/, 2];
                            _a = state;
                            return [4 /*yield*/, state.client.makeRequest()];
                        case 1:
                            _a.result = _c.sent();
                            state.isStarted = true;
                            return [3 /*break*/, 4];
                        case 2:
                            if (!!state.isCompleted) return [3 /*break*/, 4];
                            _b = state;
                            return [4 /*yield*/, state.client.makeRequest()];
                        case 3:
                            _b.result = _c.sent();
                            if (state.client.isDone(state.result.value)) {
                                state.isCompleted = true;
                            }
                            _c.label = 4;
                        case 4:
                            state.previousResponses.push(state.result);
                            return [2 /*return*/, makeSamplePollOperation(state)];
                    }
                });
            });
        },
        /**
         * The cancel method can be called to send a cancelling signal to the remote service.
         * If cancelling isn't supported, an error can be thrown instead.
         */
        cancel: function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var state, _a;
                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            state = this.state;
                            _a = state;
                            return [4 /*yield*/, state.client.cancel()];
                        case 1:
                            _a.result = _b.sent();
                            state.previousResponses.push(state.result);
                            return [2 /*return*/, makeSamplePollOperation(tslib_1.__assign(tslib_1.__assign({}, state), { isCancelled: true }))];
                    }
                });
            });
        },
        /**
         * The toString method serializes the PollOperationState, so that
         * one poller can be stopped and another poller can recover at any time
         * based on a copy of the first one.
         */
        toString: function () {
            return JSON.stringify({
                state: this.state
            });
        }
    };
}
/**
 * Here's our sample's poller.
 * It will work over our SamplePollOperationState.
 * Once the polling is completed, it will return an instance of the ReturnValue interface.
 */
var SamplePoller = /** @class */ (function (_super) {
    tslib_1.__extends(SamplePoller, _super);
    function SamplePoller(_a) {
        var client = _a.client, _b = _a.intervalInMs, intervalInMs = _b === void 0 ? 2000 : _b, resumeFrom = _a.resumeFrom;
        var _this = this;
        var state = {
            client: client,
            previousResponses: []
        };
        // Here's an example of how to resume from the serialized version of a previously defined poller.
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        // Making a new instance of the SamplePollOperation
        var operation = makeSamplePollOperation(state);
        _this = _super.call(this, operation) || this;
        _this.intervalInMs = intervalInMs;
        return _this;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    SamplePoller.prototype.delay = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, core_http_1.delay(this.intervalInMs)];
            });
        });
    };
    /**
     * Could be used to get a publicly safe version of the poller state.
     */
    SamplePoller.prototype.getOperationState = function () {
        return this.operation.state;
    };
    return SamplePoller;
}(src_1.Poller));
/**
 * Now it's time to define our Client.
 * Our client will have four public methods:
 * `makeRequest()` attempts to emulate the network request,
 * `cancel()` which portrays how to tell the remote resource to cancel the long running operation,
 * and `beginLongOperation()`, the method that returns the poller.
 */
var Client = /** @class */ (function () {
    function Client() {
        /**
         * We'll keep track of the number of requests through this private property.
         * This is just to demonstrate the poller's behavior.
         */
        this.requestCount = 0;
    }
    /**
     * isDone is here to represent a way to determine if the response from the service indicates that the long running operation has finished.
     * In this sample we're considering a number value of 3 to be the only indicator that the operation has finished.
     */
    Client.prototype.isDone = function (value) {
        return value === 3;
    };
    /**
     * cancel should reach out to the remote service to indicate that the
     * long running operation should be cancelled. In our case it simply returns a value,
     * the poller will stop nonetheless.
     */
    Client.prototype.cancel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, {
                        value: 0
                    }];
            });
        });
    };
    /**
     * makeRequest simulates a method that reaches out to a remote resource that responds differently each time
     */
    Client.prototype.makeRequest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // Let's assume the HTTP request happens here.
                    return [4 /*yield*/, core_http_1.delay(1000)];
                    case 1:
                        // Let's assume the HTTP request happens here.
                        _a.sent();
                        return [2 /*return*/, {
                                value: this.requestCount++
                            }];
                }
            });
        });
    };
    Client.prototype.beginLongOperation = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var poller;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        poller = new SamplePoller(tslib_1.__assign({ client: this }, options));
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    return Client;
}());
// Now let's see how the client is used.
function main() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var client, poller, result, serialized;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    client = new Client();
                    return [4 /*yield*/, client.beginLongOperation()];
                case 1:
                    poller = _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 1 }
                    return [4 /*yield*/, poller.pollUntilDone()];
                case 2:
                    result = _a.sent();
                    console.log(result); // Should show: { value: 3 }
                    return [4 /*yield*/, client.beginLongOperation()];
                case 3:
                    // We can start again and do each call individually
                    poller = _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 1 }
                    return [4 /*yield*/, poller.poll()];
                case 4:
                    _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 2 }
                    return [4 /*yield*/, poller.poll()];
                case 5:
                    _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 3 }
                    console.log(poller.isDone()); // Should be: true
                    return [4 /*yield*/, client.beginLongOperation()];
                case 6:
                    // We can also start it, then serialize it, then resume it with a different poller
                    poller = _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 1 }
                    serialized = poller.toString();
                    return [4 /*yield*/, client.beginLongOperation({ resumeFrom: serialized })];
                case 7:
                    poller = _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 2 }
                    return [4 /*yield*/, poller.poll()];
                case 8:
                    _a.sent();
                    console.log(poller.getResult()); // Should show: { value: 3 }
                    console.log(poller.isDone()); // Should be: true
                    return [2 /*return*/];
            }
        });
    });
}
main().catch(function (err) {
    console.log("error code: ", err.code);
    console.log("error message: ", err.message);
    console.log("error stack: ", err.stack);
});
//# sourceMappingURL=samplesClient.js.map