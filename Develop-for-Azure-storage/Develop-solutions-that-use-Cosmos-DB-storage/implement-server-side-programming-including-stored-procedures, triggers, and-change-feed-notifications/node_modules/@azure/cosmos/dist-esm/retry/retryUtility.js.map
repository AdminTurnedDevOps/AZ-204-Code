{"version":3,"file":"retryUtility.js","sourceRoot":"","sources":["../../src/retry/retryUtility.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { Response } from \"../request\";\nimport { RequestContext } from \"../request/RequestContext\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\n\n/**\n * @ignore\n */\ninterface ExecuteArgs {\n  retryContext?: RetryContext;\n  retryPolicies?: RetryPolicies;\n  requestContext: RequestContext;\n  executeRequest: (requestContext: RequestContext) => Promise<Response<any>>;\n}\n\n/**\n * @ignore\n */\ninterface RetryPolicies {\n  endpointDiscoveryRetryPolicy: EndpointDiscoveryRetryPolicy;\n  resourceThrottleRetryPolicy: ResourceThrottleRetryPolicy;\n  sessionReadRetryPolicy: SessionRetryPolicy;\n  defaultRetryPolicy: DefaultRetryPolicy;\n}\n\n/**\n *\n * @param param0\n * @ignore\n */\nexport async function execute({\n  retryContext = {},\n  retryPolicies,\n  requestContext,\n  executeRequest\n}: ExecuteArgs): Promise<Response<any>> {\n  // TODO: any response\n  if (!retryPolicies) {\n    retryPolicies = {\n      endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.operationType\n      ),\n      resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(\n        requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount,\n        requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds,\n        requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds\n      ),\n      sessionReadRetryPolicy: new SessionRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.resourceType,\n        requestContext.operationType,\n        requestContext.connectionPolicy\n      ),\n      defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)\n    };\n  }\n  if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n    requestContext.client.clearSessionToken(requestContext.path);\n  }\n  requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(\n    requestContext.resourceType,\n    requestContext.operationType\n  );\n  try {\n    const response = await executeRequest(requestContext);\n    response.headers[Constants.ThrottleRetryCount] =\n      retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n    response.headers[Constants.ThrottleRetryWaitTimeInMs] =\n      retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n    return response;\n  } catch (err) {\n    // TODO: any error\n    let retryPolicy: RetryPolicy = null;\n    const headers = err.headers || {};\n    if (\n      err.code === StatusCodes.Forbidden &&\n      (err.substatus === SubStatusCodes.DatabaseAccountNotFound ||\n        err.substatus === SubStatusCodes.WriteForbidden)\n    ) {\n      retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n    } else if (err.code === StatusCodes.TooManyRequests) {\n      retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n    } else if (\n      err.code === StatusCodes.NotFound &&\n      err.substatus === SubStatusCodes.ReadSessionNotAvailable\n    ) {\n      retryPolicy = retryPolicies.sessionReadRetryPolicy;\n    } else {\n      retryPolicy = retryPolicies.defaultRetryPolicy;\n    }\n    const results = await retryPolicy.shouldRetry(err, retryContext, requestContext.endpoint);\n    if (!results) {\n      headers[Constants.ThrottleRetryCount] =\n        retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n      headers[Constants.ThrottleRetryWaitTimeInMs] =\n        retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n      err.headers = { ...err.headers, ...headers };\n      throw err;\n    } else {\n      requestContext.retryCount++;\n      const newUrl = (results as any)[1]; // TODO: any hack\n      if (newUrl !== undefined) {\n        requestContext.endpoint = newUrl;\n      }\n      await sleep(retryPolicy.retryAfterInMs);\n      return execute({\n        executeRequest,\n        requestContext,\n        retryContext,\n        retryPolicies\n      });\n    }\n  }\n}\n"]}