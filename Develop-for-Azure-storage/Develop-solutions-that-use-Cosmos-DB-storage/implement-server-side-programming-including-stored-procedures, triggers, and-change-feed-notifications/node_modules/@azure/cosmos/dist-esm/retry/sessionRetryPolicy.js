import { __awaiter } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { isReadRequest } from "../common";
/**
 * This class implements the retry policy for session consistent reads.
 * @hidden
 */
export class SessionRetryPolicy {
    /**
     * @constructor SessionReadRetryPolicy
     * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.
     * @property {object} request                                      - The Http request information
     */
    constructor(globalEndpointManager, resourceType, operationType, connectionPolicy) {
        this.globalEndpointManager = globalEndpointManager;
        this.resourceType = resourceType;
        this.operationType = operationType;
        this.connectionPolicy = connectionPolicy;
        /** Current retry attempt count. */
        this.currentRetryAttemptCount = 0;
        /** Retry interval in milliseconds. */
        this.retryAfterInMs = 0;
    }
    /**
     * Determines whether the request should be retried or not.
     * @param {object} err - Error returned by the request.
     * @param {function} callback - The callback function which takes bool argument which specifies whether the request\
     * will be retried or not.
     */
    shouldRetry(err, retryContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!err) {
                return false;
            }
            if (!retryContext) {
                return false;
            }
            if (!this.connectionPolicy.enableEndpointDiscovery) {
                return false;
            }
            if (this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)) {
                // If we can write to multiple locations, we should against every write endpoint until we succeed
                const endpoints = isReadRequest(this.operationType)
                    ? yield this.globalEndpointManager.getReadEndpoints()
                    : yield this.globalEndpointManager.getWriteEndpoints();
                if (this.currentRetryAttemptCount > endpoints.length) {
                    return false;
                }
                else {
                    retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                    retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;
                    retryContext.clearSessionTokenNotAvailable =
                        this.currentRetryAttemptCount === endpoints.length;
                    return true;
                }
            }
            else {
                if (this.currentRetryAttemptCount > 1) {
                    return false;
                }
                else {
                    retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                    retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint
                    retryContext.clearSessionTokenNotAvailable = true;
                    return true;
                }
            }
        });
    }
}
//# sourceMappingURL=sessionRetryPolicy.js.map