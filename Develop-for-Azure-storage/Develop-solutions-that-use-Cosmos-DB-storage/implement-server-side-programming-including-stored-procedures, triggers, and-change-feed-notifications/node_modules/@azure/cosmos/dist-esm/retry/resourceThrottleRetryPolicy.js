import { __awaiter } from "tslib";
/**
 * This class implements the resource throttle retry policy for requests.
 * @hidden
 */
export class ResourceThrottleRetryPolicy {
    /**
     * @constructor ResourceThrottleRetryPolicy
     * @param {int} maxTries - Max number of retries to be performed for a request.
     * @param {int} fixedRetryIntervalInMs   - Fixed retry interval in milliseconds to wait between each \
     * retry ignoring the retryAfter returned as part of the response.
     * @param {int} timeoutInSeconds               - Max wait time in seconds to wait for a request while the \
     * retries are happening.
     */
    constructor(maxTries = 9, fixedRetryIntervalInMs = 0, timeoutInSeconds = 30) {
        this.maxTries = maxTries;
        this.fixedRetryIntervalInMs = fixedRetryIntervalInMs;
        /** Current retry attempt count. */
        this.currentRetryAttemptCount = 0;
        /** Cummulative wait time in milliseconds for a request while the retries are happening. */
        this.cummulativeWaitTimeinMs = 0;
        /** Max wait time in milliseconds to wait for a request while the retries are happening. */
        this.retryAfterInMs = 0;
        this.timeoutInMs = timeoutInSeconds * 1000;
        this.currentRetryAttemptCount = 0;
        this.cummulativeWaitTimeinMs = 0;
    }
    /**
     * Determines whether the request should be retried or not.
     * @param {object} err - Error returned by the request.
     */
    shouldRetry(err) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: any custom error object
            if (err) {
                if (this.currentRetryAttemptCount < this.maxTries) {
                    this.currentRetryAttemptCount++;
                    this.retryAfterInMs = 0;
                    if (this.fixedRetryIntervalInMs) {
                        this.retryAfterInMs = this.fixedRetryIntervalInMs;
                    }
                    else if (err.retryAfterInMs) {
                        this.retryAfterInMs = err.retryAfterInMs;
                    }
                    if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {
                        this.cummulativeWaitTimeinMs += this.retryAfterInMs;
                        return true;
                    }
                }
            }
            return false;
        });
    }
}
//# sourceMappingURL=resourceThrottleRetryPolicy.js.map