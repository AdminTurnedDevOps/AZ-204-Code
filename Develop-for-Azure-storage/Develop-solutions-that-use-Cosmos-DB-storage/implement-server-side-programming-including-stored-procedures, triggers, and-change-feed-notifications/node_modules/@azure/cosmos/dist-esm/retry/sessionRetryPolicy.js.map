{"version":3,"file":"sessionRetryPolicy.js","sourceRoot":"","sources":["../../src/retry/sessionRetryPolicy.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;AAClC,OAAO,EAAE,aAAa,EAA+B,MAAM,WAAW,CAAC;AAOvE;;;GAGG;AACH,MAAM,OAAO,kBAAkB;IAM7B;;;;OAIG;IACH,YACU,qBAA4C,EAC5C,YAA0B,EAC1B,aAA4B,EAC5B,gBAAkC;QAHlC,0BAAqB,GAArB,qBAAqB,CAAuB;QAC5C,iBAAY,GAAZ,YAAY,CAAc;QAC1B,kBAAa,GAAb,aAAa,CAAe;QAC5B,qBAAgB,GAAhB,gBAAgB,CAAkB;QAd5C,mCAAmC;QAC5B,6BAAwB,GAAG,CAAC,CAAC;QACpC,sCAAsC;QAC/B,mBAAc,GAAG,CAAC,CAAC;IAYvB,CAAC;IAEJ;;;;;OAKG;IACU,WAAW,CAAC,GAAkB,EAAE,YAA2B;;YACtE,IAAI,CAAC,GAAG,EAAE;gBACR,OAAO,KAAK,CAAC;aACd;YAED,IAAI,CAAC,YAAY,EAAE;gBACjB,OAAO,KAAK,CAAC;aACd;YAED,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,EAAE;gBAClD,OAAO,KAAK,CAAC;aACd;YAED,IACE,IAAI,CAAC,qBAAqB,CAAC,4BAA4B,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,aAAa,CAAC,EAC9F;gBACA,iGAAiG;gBACjG,MAAM,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC;oBACjD,CAAC,CAAC,MAAM,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,EAAE;oBACrD,CAAC,CAAC,MAAM,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC;gBACzD,IAAI,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAC,MAAM,EAAE;oBACpD,OAAO,KAAK,CAAC;iBACd;qBAAM;oBACL,YAAY,CAAC,UAAU,GAAG,EAAE,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;oBAC9D,YAAY,CAAC,gCAAgC,GAAG,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;oBAClF,YAAY,CAAC,6BAA6B;wBACxC,IAAI,CAAC,wBAAwB,KAAK,SAAS,CAAC,MAAM,CAAC;oBACrD,OAAO,IAAI,CAAC;iBACb;aACF;iBAAM;gBACL,IAAI,IAAI,CAAC,wBAAwB,GAAG,CAAC,EAAE;oBACrC,OAAO,KAAK,CAAC;iBACd;qBAAM;oBACL,YAAY,CAAC,UAAU,GAAG,EAAE,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;oBAC9D,YAAY,CAAC,gCAAgC,GAAG,KAAK,CAAC,CAAC,kDAAkD;oBACzG,YAAY,CAAC,6BAA6B,GAAG,IAAI,CAAC;oBAClD,OAAO,IAAI,CAAC;iBACb;aACF;QACH,CAAC;KAAA;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { isReadRequest, OperationType, ResourceType } from \"../common\";\nimport { ConnectionPolicy } from \"../documents\";\nimport { GlobalEndpointManager } from \"../globalEndpointManager\";\nimport { ErrorResponse } from \"../request\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\n\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\nexport class SessionRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount = 0;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs = 0;\n\n  /**\n   * @constructor SessionReadRetryPolicy\n   * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.\n   * @property {object} request                                      - The Http request information\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private connectionPolicy: ConnectionPolicy\n  ) {}\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param {object} err - Error returned by the request.\n   * @param {function} callback - The callback function which takes bool argument which specifies whether the request\\\n   * will be retried or not.\n   */\n  public async shouldRetry(err: ErrorResponse, retryContext?: RetryContext): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext) {\n      return false;\n    }\n\n    if (!this.connectionPolicy.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (\n      this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)\n    ) {\n      // If we can write to multiple locations, we should against every write endpoint until we succeed\n      const endpoints = isReadRequest(this.operationType)\n        ? await this.globalEndpointManager.getReadEndpoints()\n        : await this.globalEndpointManager.getWriteEndpoints();\n      if (this.currentRetryAttemptCount > endpoints.length) {\n        return false;\n      } else {\n        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n        retryContext.clearSessionTokenNotAvailable =\n          this.currentRetryAttemptCount === endpoints.length;\n        return true;\n      }\n    } else {\n      if (this.currentRetryAttemptCount > 1) {\n        return false;\n      } else {\n        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;\n        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n        retryContext.clearSessionTokenNotAvailable = true;\n        return true;\n      }\n    }\n  }\n}\n"]}