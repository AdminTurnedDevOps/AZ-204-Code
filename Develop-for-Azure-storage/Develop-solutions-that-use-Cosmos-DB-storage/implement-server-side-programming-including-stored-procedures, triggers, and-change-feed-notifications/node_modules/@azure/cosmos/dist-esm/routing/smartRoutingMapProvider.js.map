{"version":3,"file":"smartRoutingMapProvider.js","sourceRoot":"","sources":["../../src/routing/smartRoutingMapProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Constants } from \"../common/constants\";\nimport { PartitionKeyRangeCache } from \"./partitionKeyRangeCache\";\nimport { QueryRange } from \"./QueryRange\";\n\n/** @hidden */\nexport const PARITIONKEYRANGE = Constants.PartitionKeyRange;\n\n/** @hidden */\nexport class SmartRoutingMapProvider {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n\n  constructor(clientContext: ClientContext) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);\n  }\n  private static _secondRangeIsAfterFirstRange(range1: QueryRange, range2: QueryRange) {\n    if (typeof range1.max === \"undefined\") {\n      throw new Error(\"range1 must have max\");\n    }\n\n    if (typeof range2.min === \"undefined\") {\n      throw new Error(\"range2 must have min\");\n    }\n\n    if (range1.max > range2.min) {\n      // r.min < #previous_r.max\n      return false;\n    } else {\n      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {\n        // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r\n        // they share a point\n        return false;\n      }\n      return true;\n    }\n  }\n\n  private static _isSortedAndNonOverlapping(ranges: QueryRange[]) {\n    for (let idx = 1; idx < ranges.length; idx++) {\n      const previousR = ranges[idx - 1];\n      const r = ranges[idx];\n      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static _stringMax(a: string, b: string) {\n    return a >= b ? a : b;\n  }\n\n  private static _stringCompare(a: string, b: string) {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  private static _subtractRange(r: QueryRange, partitionKeyRange: any) {\n    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);\n    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;\n    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);\n  }\n\n  /**\n   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges\n   * @param {callback} callback - Function execute on the overlapping partition key ranges result,\n   *                              takes two parameters error, partition key ranges\n   * @param collectionLink\n   * @param sortedRanges\n   * @ignore\n   */\n  public async getOverlappingRanges(\n    collectionLink: string,\n    sortedRanges: QueryRange[]\n  ): Promise<any[]> {\n    // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges\n    if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {\n      throw new Error(\"the list of ranges is not a non-overlapping sorted ranges\");\n    }\n\n    let partitionKeyRanges: any[] = []; // TODO: any ParitionKeyRanges\n\n    if (sortedRanges.length === 0) {\n      return partitionKeyRanges;\n    }\n\n    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(\n      collectionLink\n    );\n\n    let index = 0;\n    let currentProvidedRange = sortedRanges[index];\n    while (true) {\n      if (currentProvidedRange.isEmpty()) {\n        // skip and go to the next item\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n        continue;\n      }\n\n      let queryRange;\n      if (partitionKeyRanges.length > 0) {\n        queryRange = SmartRoutingMapProvider._subtractRange(\n          currentProvidedRange,\n          partitionKeyRanges[partitionKeyRanges.length - 1]\n        );\n      } else {\n        queryRange = currentProvidedRange;\n      }\n\n      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);\n      if (overlappingRanges.length <= 0) {\n        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);\n      }\n      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);\n\n      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(\n        partitionKeyRanges[partitionKeyRanges.length - 1]\n      );\n      if (!lastKnownTargetRange) {\n        throw new Error(\"expected lastKnowTargetRange to be truthy\");\n      }\n      // the overlapping ranges must contain the requested range\n\n      if (\n        SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) >\n        0\n      ) {\n        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \\\n        does not contain the requested range ${queryRange}`);\n      }\n\n      // the current range is contained in partitionKeyRanges just move forward\n      if (++index >= sortedRanges.length) {\n        return partitionKeyRanges;\n      }\n      currentProvidedRange = sortedRanges[index];\n\n      while (\n        SmartRoutingMapProvider._stringCompare(\n          currentProvidedRange.max,\n          lastKnownTargetRange.max\n        ) <= 0\n      ) {\n        // the current range is covered too.just move forward\n        if (++index >= sortedRanges.length) {\n          return partitionKeyRanges;\n        }\n        currentProvidedRange = sortedRanges[index];\n      }\n    }\n  }\n}\n"]}