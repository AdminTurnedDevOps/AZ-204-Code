import { __awaiter } from "tslib";
import { getIdFromLink } from "../common/helper";
import { createCompleteRoutingMap } from "./CollectionRoutingMapFactory";
/** @hidden */
export class PartitionKeyRangeCache {
    constructor(clientContext) {
        this.clientContext = clientContext;
        this.collectionRoutingMapByCollectionId = {};
    }
    /**
     * Finds or Instantiates the requested Collection Routing Map
     * @param {string} collectionLink            - Requested collectionLink
     * @ignore
     */
    onCollectionRoutingMap(collectionLink) {
        return __awaiter(this, void 0, void 0, function* () {
            const collectionId = getIdFromLink(collectionLink);
            if (this.collectionRoutingMapByCollectionId[collectionId] === undefined) {
                this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(collectionLink);
            }
            return this.collectionRoutingMapByCollectionId[collectionId];
        });
    }
    /**
     * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges
     * @param collectionLink
     * @param queryRange
     * @ignore
     */
    getOverlappingRanges(collectionLink, queryRange) {
        return __awaiter(this, void 0, void 0, function* () {
            const crm = yield this.onCollectionRoutingMap(collectionLink);
            return crm.getOverlappingRanges(queryRange);
        });
    }
    requestCollectionRoutingMap(collectionLink) {
        return __awaiter(this, void 0, void 0, function* () {
            const { resources } = yield this.clientContext
                .queryPartitionKeyRanges(collectionLink)
                .fetchAll();
            return createCompleteRoutingMap(resources.map((r) => [r, true]));
        });
    }
}
//# sourceMappingURL=partitionKeyRangeCache.js.map