{"version":3,"file":"globalEndpointManager.js","sourceRoot":"","sources":["../src/globalEndpointManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { Location, DatabaseAccount } from \"./documents\";\nimport { RequestOptions } from \"./index\";\nimport { ResourceResponse } from \"./request\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n * @property {object} client                       - The document client instance.\n * @property {string} defaultEndpoint              - The endpoint used to create the client instance.\n * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests\n *                                                   based on read/write operations.\n * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations\n *                                                   for read requests.\n * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.\n */\nexport class GlobalEndpointManager {\n  private defaultEndpoint: string;\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  private preferredLocations: string[];\n  private writeableLocations: Location[];\n  private readableLocations: Location[];\n\n  /**\n   * @constructor GlobalEndpointManager\n   * @param {object} options                          - The document client instance.\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      opts: RequestOptions\n    ) => Promise<ResourceResponse<DatabaseAccount>>\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async markCurrentLocationUnavailableForRead(endpoint: string) {\n    await this.refreshEndpointList();\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(endpoint: string) {\n    await this.refreshEndpointList();\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint\n    );\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType\n  ): boolean {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  public async resolveServiceEndpoint(resourceType: ResourceType, operationType: OperationType) {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      return this.defaultEndpoint;\n    }\n\n    if (!this.readableLocations || !this.writeableLocations) {\n      const { resource: databaseAccount } = await this.readDatabaseAccount({\n        urlConnection: this.defaultEndpoint\n      });\n      this.writeableLocations = databaseAccount.writableLocations;\n      this.readableLocations = databaseAccount.readableLocations;\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (this.preferredLocations && this.preferredLocations.length > 0) {\n      for (const preferredLocation of this.preferredLocations) {\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation)\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      location = locations.find((loc) => {\n        return loc.unavailable !== true;\n      });\n    }\n\n    return location ? location.databaseAccountEndpoint : this.defaultEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by retrieving the writable and readable locations\n   *  from the geo-replicated database account and then updating the locations cache.\n   *   We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint();\n      if (databaseAccount) {\n        this.refreshEndpoints(databaseAccount);\n      }\n\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount) {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   * @memberof GlobalEndpointManager\n   * @instance\n   * @param {string} defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param {string} locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string) {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname\n        .toString()\n        .toLowerCase()\n        .split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction normalizeEndpoint(endpoint: string) {\n  return endpoint\n    .split(\" \")\n    .join(\"\")\n    .toLowerCase();\n}\n"]}