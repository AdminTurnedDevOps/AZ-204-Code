{"version":3,"file":"auth.js","sourceRoot":"","sources":["../src/auth.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { generateHeaders } from \"./utils/headers\";\nimport { Constants, getResourceIdFromPath, HTTPMethod, ResourceType } from \"./common\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { CosmosHeaders } from \"./queryExecutionContext\";\n\n/** @hidden */\nexport interface RequestInfo {\n  verb: HTTPMethod;\n  path: string;\n  resourceId: string;\n  resourceType: ResourceType;\n  headers: CosmosHeaders;\n}\n\nexport type TokenProvider = (requestInfo: RequestInfo) => Promise<string>;\n\n/**\n * @ignore\n * @param clientOptions\n * @param verb\n * @param path\n * @param resourceId\n * @param resourceType\n * @param headers\n */\nexport async function setAuthorizationHeader(\n  clientOptions: CosmosClientOptions,\n  verb: HTTPMethod,\n  path: string,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders\n): Promise<void> {\n  if (clientOptions.permissionFeed) {\n    clientOptions.resourceTokens = {};\n    for (const permission of clientOptions.permissionFeed) {\n      const id = getResourceIdFromPath(permission.resource);\n      if (!id) {\n        throw new Error(`authorization error: ${id} \\\n                          is an invalid resourceId in permissionFeed`);\n      }\n\n      clientOptions.resourceTokens[id] = (permission as any)._token; // TODO: any\n    }\n  }\n\n  if (clientOptions.key) {\n    await setAuthorizationTokenHeaderUsingMasterKey(\n      verb,\n      resourceId,\n      resourceType,\n      headers,\n      clientOptions.key\n    );\n  } else if (clientOptions.resourceTokens) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId)\n    );\n  } else if (clientOptions.tokenProvider) {\n    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(\n      await clientOptions.tokenProvider({ verb, path, resourceId, resourceType, headers })\n    );\n  }\n}\n\n/**\n * The default function for setting header token using the masterKey\n * @ignore\n */\nexport async function setAuthorizationTokenHeaderUsingMasterKey(\n  verb: HTTPMethod,\n  resourceId: string,\n  resourceType: ResourceType,\n  headers: CosmosHeaders,\n  masterKey: string\n) {\n  // TODO This should live in cosmos-sign\n  if (resourceType === ResourceType.offer) {\n    resourceId = resourceId && resourceId.toLowerCase();\n  }\n  headers = Object.assign(\n    headers,\n    await generateHeaders(masterKey, verb, resourceType, resourceId)\n  );\n}\n\n/**\n * @ignore\n * @param resourceTokens\n * @param path\n * @param resourceId\n */\n// TODO: Resource tokens\nfunction getAuthorizationTokenUsingResourceTokens(\n  resourceTokens: { [resourceId: string]: string },\n  path: string,\n  resourceId: string\n) {\n  if (resourceTokens && Object.keys(resourceTokens).length > 0) {\n    // For database account access(through getDatabaseAccount API), path and resourceId are \"\",\n    // so in this case we return the first token to be used for creating the auth header as the\n    // service will accept any token in this case\n    if (!path && !resourceId) {\n      return resourceTokens[Object.keys(resourceTokens)[0]];\n    }\n\n    if (resourceId && resourceTokens[resourceId]) {\n      return resourceTokens[resourceId];\n    }\n\n    // minimum valid path /dbs\n    if (!path || path.length < 4) {\n      return null;\n    }\n\n    // remove '/' from left and right of path\n    path = path[0] === \"/\" ? path.substring(1) : path;\n    path = path[path.length - 1] === \"/\" ? path.substring(0, path.length - 1) : path;\n\n    const pathSegments = (path && path.split(\"/\")) || [];\n\n    // if it's an incomplete path like /dbs/db1/colls/, start from the paretn resource\n    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;\n    for (; index > 0; index -= 2) {\n      const id = decodeURI(pathSegments[index]);\n      if (resourceTokens[id]) {\n        return resourceTokens[id];\n      }\n    }\n  }\n  return null;\n}\n"]}