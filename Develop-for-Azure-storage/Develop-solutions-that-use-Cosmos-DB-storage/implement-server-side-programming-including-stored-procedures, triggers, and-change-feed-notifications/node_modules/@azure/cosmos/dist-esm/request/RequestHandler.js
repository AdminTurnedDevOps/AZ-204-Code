import { __awaiter } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import AbortController from "node-abort-controller";
import fetch from "node-fetch";
import { trimSlashes } from "../common";
import { Constants } from "../common/constants";
import { logger } from "../common/logger";
import { executePlugins, PluginOn } from "../plugins/Plugin";
import * as RetryUtility from "../retry/retryUtility";
import { defaultHttpAgent, defaultHttpsAgent } from "./defaultAgent";
import { bodyFromData } from "./request";
import { TimeoutError } from "./TimeoutError";
/** @hidden */
const log = logger("RequestHandler");
function executeRequest(requestContext) {
    return __awaiter(this, void 0, void 0, function* () {
        return executePlugins(requestContext, httpRequest, PluginOn.request);
    });
}
/**
 * @ignore
 * @param requestContext
 */
function httpRequest(requestContext) {
    return __awaiter(this, void 0, void 0, function* () {
        const controller = new AbortController();
        const signal = controller.signal;
        // Wrap users passed abort events and call our own internal abort()
        const userSignal = requestContext.options && requestContext.options.abortSignal;
        if (userSignal) {
            if (userSignal) {
                controller.abort();
            }
            else {
                userSignal.addEventListener("abort", () => {
                    controller.abort();
                });
            }
        }
        const timeout = setTimeout(() => {
            controller.abort();
        }, requestContext.connectionPolicy.requestTimeout);
        let response;
        if (requestContext.body) {
            requestContext.body = bodyFromData(requestContext.body);
        }
        try {
            response = yield fetch(trimSlashes(requestContext.endpoint) + requestContext.path, {
                method: requestContext.method,
                headers: requestContext.headers,
                agent: (parsedUrl) => {
                    if (requestContext.requestAgent) {
                        return requestContext.requestAgent;
                    }
                    return parsedUrl.protocol === "http" ? defaultHttpAgent : defaultHttpsAgent;
                },
                signal,
                body: requestContext.body
            });
        }
        catch (error) {
            if (error.name === "AbortError") {
                // If the user passed signal caused the abort, cancel the timeout and rethrow the error
                if (userSignal && userSignal.aborted === true) {
                    clearTimeout(timeout);
                    throw error;
                }
                // If the user didn't cancel, it must be an abort we called due to timeout
                throw new TimeoutError();
            }
            throw error;
        }
        clearTimeout(timeout);
        const result = response.status === 204 || response.status === 304 ? null : yield response.json();
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        const substatus = headers[Constants.HttpHeaders.SubStatus]
            ? parseInt(headers[Constants.HttpHeaders.SubStatus], 10)
            : undefined;
        if (response.status >= 400) {
            const errorResponse = new Error(result.message);
            log.warn(response.status +
                " " +
                requestContext.endpoint +
                " " +
                requestContext.path +
                " " +
                result.message);
            errorResponse.code = response.status;
            errorResponse.body = result;
            errorResponse.headers = headers;
            if (Constants.HttpHeaders.ActivityId in headers) {
                errorResponse.activityId = headers[Constants.HttpHeaders.ActivityId];
            }
            if (Constants.HttpHeaders.SubStatus in headers) {
                errorResponse.substatus = substatus;
            }
            if (Constants.HttpHeaders.RetryAfterInMs in headers) {
                errorResponse.retryAfterInMs = parseInt(headers[Constants.HttpHeaders.RetryAfterInMs], 10);
                Object.defineProperty(errorResponse, "retryAfterInMilliseconds", {
                    get: () => {
                        return errorResponse.retryAfterInMs;
                    }
                });
            }
            throw errorResponse;
        }
        return {
            headers,
            result,
            code: response.status,
            substatus
        };
    });
}
/**
 * @ignore
 * @param requestContext
 */
export function request(requestContext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (requestContext.body) {
            requestContext.body = bodyFromData(requestContext.body);
            if (!requestContext.body) {
                throw new Error("parameter data must be a javascript object, string, or Buffer");
            }
        }
        return RetryUtility.execute({
            requestContext,
            executeRequest
        });
    });
}
//# sourceMappingURL=RequestHandler.js.map