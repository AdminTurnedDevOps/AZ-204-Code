import { __awaiter } from "tslib";
import { Constants, getIdFromLink, getPathFromLink, ResourceType, StatusCodes, SubStatusCodes } from "../common";
import { DefaultQueryExecutionContext } from "./defaultQueryExecutionContext";
import { FetchResult, FetchResultType } from "./FetchResult";
import { getInitialHeader, mergeHeaders } from "./headerUtils";
/** @hidden */
export class DocumentProducer {
    /**
     * Provides the Target Partition Range Query Execution Context.
     * @constructor DocumentProducer
     * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
     * @param {String} collectionLink                - Represents collection link
     * @param {SqlQuerySpec | string} query          - A SQL query.
     * @param {object} targetPartitionKeyRange       - Query Target Partition key Range
     * @ignore
     */
    constructor(clientContext, collectionLink, query, targetPartitionKeyRange, // TODO: any partition key range
    options) {
        this.clientContext = clientContext;
        this.generation = 0;
        this.fetchFunction = (options) => __awaiter(this, void 0, void 0, function* () {
            const path = getPathFromLink(this.collectionLink, ResourceType.item);
            const id = getIdFromLink(this.collectionLink);
            return this.clientContext.queryFeed({
                path,
                resourceType: ResourceType.item,
                resourceId: id,
                resultFn: (result) => result.Documents,
                query: this.query,
                options,
                partitionKeyRangeId: this.targetPartitionKeyRange["id"]
            });
        });
        // TODO: any options
        this.collectionLink = collectionLink;
        this.query = query;
        this.targetPartitionKeyRange = targetPartitionKeyRange;
        this.fetchResults = [];
        this.allFetched = false;
        this.err = undefined;
        this.previousContinuationToken = undefined;
        this.continuationToken = undefined;
        this.respHeaders = getInitialHeader();
        // tslint:disable-next-line:no-shadowed-variable
        this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction);
    }
    /**
     * Synchronously gives the contiguous buffered results (stops at the first non result) if any
     * @returns {Object}       - buffered current items if any
     * @ignore
     */
    peekBufferedItems() {
        const bufferedResults = [];
        for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {
            const fetchResult = this.fetchResults[i];
            switch (fetchResult.fetchResultType) {
                case FetchResultType.Done:
                    done = true;
                    break;
                case FetchResultType.Exception:
                    done = true;
                    break;
                case FetchResultType.Result:
                    bufferedResults.push(fetchResult.feedResponse);
                    break;
            }
        }
        return bufferedResults;
    }
    hasMoreResults() {
        return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;
    }
    gotSplit() {
        const fetchResult = this.fetchResults[0];
        if (fetchResult.fetchResultType === FetchResultType.Exception) {
            if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {
                return true;
            }
        }
        return false;
    }
    _getAndResetActiveResponseHeaders() {
        const ret = this.respHeaders;
        this.respHeaders = getInitialHeader();
        return ret;
    }
    _updateStates(err, allFetched) {
        // TODO: any Error
        if (err) {
            this.err = err;
            return;
        }
        if (allFetched) {
            this.allFetched = true;
        }
        if (this.internalExecutionContext.continuationToken === this.continuationToken) {
            // nothing changed
            return;
        }
        this.previousContinuationToken = this.continuationToken;
        this.continuationToken = this.internalExecutionContext.continuationToken;
    }
    static _needPartitionKeyRangeCacheRefresh(error) {
        // TODO: error
        return (error.code === StatusCodes.Gone &&
            "substatus" in error &&
            error["substatus"] === SubStatusCodes.PartitionKeyRangeGone);
    }
    /**
     * Fetches and bufferes the next page of results and executes the given callback
     * @memberof DocumentProducer
     * @instance
     */
    bufferMore() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.err) {
                throw this.err;
            }
            try {
                const { result: resources, headers: headerResponse } = yield this.internalExecutionContext.fetchMore();
                ++this.generation;
                this._updateStates(undefined, resources === undefined);
                if (resources !== undefined) {
                    // some more results
                    resources.forEach((element) => {
                        // TODO: resources any
                        this.fetchResults.push(new FetchResult(element, undefined));
                    });
                }
                // need to modify the header response so that the query metrics are per partition
                if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {
                    // "0" is the default partition before one is actually assigned.
                    const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics]["0"];
                    // Wraping query metrics in a object where the keys are the partition key range.
                    headerResponse[Constants.HttpHeaders.QueryMetrics] = {};
                    headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;
                }
                return { result: resources, headers: headerResponse };
            }
            catch (err) {
                // TODO: any error
                if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {
                    // Split just happend
                    // Buffer the error so the execution context can still get the feedResponses in the itemBuffer
                    const bufferedError = new FetchResult(undefined, err);
                    this.fetchResults.push(bufferedError);
                    // Putting a dummy result so that the rest of code flows
                    return { result: [bufferedError], headers: err.headers };
                }
                else {
                    this._updateStates(err, err.resources === undefined);
                    throw err;
                }
            }
        });
    }
    /**
     * Synchronously gives the bufferend current item if any
     * @returns {Object}       - buffered current item if any
     * @ignore
     */
    getTargetParitionKeyRange() {
        return this.targetPartitionKeyRange;
    }
    /**
     * Execute a provided function on the next element in the DocumentProducer.
     * @memberof DocumentProducer
     * @instance
     * @param {callback} callback - Function to execute for each element. the function \
     * takes two parameters error, element.
     */
    nextItem() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.err) {
                this._updateStates(this.err, undefined);
                throw this.err;
            }
            try {
                const { result, headers } = yield this.current();
                const fetchResult = this.fetchResults.shift();
                this._updateStates(undefined, result === undefined);
                if (fetchResult.feedResponse !== result) {
                    throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);
                }
                switch (fetchResult.fetchResultType) {
                    case FetchResultType.Done:
                        return { result: undefined, headers };
                    case FetchResultType.Exception:
                        fetchResult.error.headers = headers;
                        throw fetchResult.error;
                    case FetchResultType.Result:
                        return { result: fetchResult.feedResponse, headers };
                }
            }
            catch (err) {
                this._updateStates(err, err.item === undefined);
                throw err;
            }
        });
    }
    /**
     * Retrieve the current element on the DocumentProducer.
     * @memberof DocumentProducer
     * @instance
     * @param {callback} callback - Function to execute for the current element. \
     * the function takes two parameters error, element.
     */
    current() {
        return __awaiter(this, void 0, void 0, function* () {
            // If something is buffered just give that
            if (this.fetchResults.length > 0) {
                const fetchResult = this.fetchResults[0];
                // Need to unwrap fetch results
                switch (fetchResult.fetchResultType) {
                    case FetchResultType.Done:
                        return {
                            result: undefined,
                            headers: this._getAndResetActiveResponseHeaders()
                        };
                    case FetchResultType.Exception:
                        fetchResult.error.headers = this._getAndResetActiveResponseHeaders();
                        throw fetchResult.error;
                    case FetchResultType.Result:
                        return {
                            result: fetchResult.feedResponse,
                            headers: this._getAndResetActiveResponseHeaders()
                        };
                }
            }
            // If there isn't anymore items left to fetch then let the user know.
            if (this.allFetched) {
                return {
                    result: undefined,
                    headers: this._getAndResetActiveResponseHeaders()
                };
            }
            // If there are no more bufferd items and there are still items to be fetched then buffer more
            const { result, headers } = yield this.bufferMore();
            mergeHeaders(this.respHeaders, headers);
            if (result === undefined) {
                return { result: undefined, headers: this.respHeaders };
            }
            return this.current();
        });
    }
}
//# sourceMappingURL=documentProducer.js.map