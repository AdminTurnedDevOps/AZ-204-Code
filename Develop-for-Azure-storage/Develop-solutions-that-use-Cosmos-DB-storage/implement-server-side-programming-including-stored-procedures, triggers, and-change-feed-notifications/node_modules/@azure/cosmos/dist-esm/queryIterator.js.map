{"version":3,"file":"queryIterator.js","sourceRoot":"","sources":["../src/queryIterator.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference lib=\"esnext.asynciterable\" />\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"./ClientContext\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common\";\nimport {\n  CosmosHeaders,\n  DefaultQueryExecutionContext,\n  ExecutionContext,\n  FetchFunctionCallback,\n  getInitialHeader,\n  mergeHeaders,\n  PipelinedQueryExecutionContext,\n  SqlQuerySpec\n} from \"./queryExecutionContext\";\nimport { Response } from \"./request\";\nimport { ErrorResponse, PartitionedQueryExecutionInfo } from \"./request/ErrorResponse\";\nimport { FeedOptions } from \"./request/FeedOptions\";\nimport { FeedResponse } from \"./request/FeedResponse\";\n\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\nexport class QueryIterator<T> {\n  private fetchAllTempResources: T[]; // TODO\n  private fetchAllLastResHeaders: CosmosHeaders;\n  private queryExecutionContext: ExecutionContext;\n  private queryPlanPromise: Promise<Response<PartitionedQueryExecutionInfo>>;\n  private isInitialized: boolean;\n  /**\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private query: SqlQuerySpec | string,\n    private options: FeedOptions,\n    private fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    private resourceLink?: string,\n    private resourceType?: ResourceType\n  ) {\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```typescript\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```typescript\n   * for await(const {result: db} in client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db.id} from AsyncIterator`);\n   * }\n   * ```\n   */\n  public async *getAsyncIterator(): AsyncIterable<FeedResponse<T>> {\n    this.reset();\n    this.queryPlanPromise = this.fetchQueryPlan();\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore();\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          await this.createPipelinedExecutionContext();\n          try {\n            response = await this.queryExecutionContext.fetchMore();\n          } catch (error) {\n            this.handleSplitError(error);\n          }\n        } else {\n          throw error;\n        }\n      }\n      const feedResponse = new FeedResponse<T>(\n        response.result,\n        response.headers,\n        this.queryExecutionContext.hasMoreResults()\n      );\n      if (response.result !== undefined) {\n        yield feedResponse;\n      }\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on the value of the continuation token or the\\\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns {Boolean} true if there is other elements to process in the QueryIterator.\n   */\n  public hasMoreResults(): boolean {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n\n  public async fetchAll(): Promise<FeedResponse<T>> {\n    this.reset();\n    this.fetchAllTempResources = [];\n    let response: FeedResponse<T>;\n    try {\n      response = await this.toArrayImplementation();\n    } catch (error) {\n      this.handleSplitError(error);\n    }\n    return response;\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   */\n  public async fetchNext(): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = this.fetchQueryPlan();\n    if (!this.isInitialized) {\n      await this.init();\n    }\n\n    let response: Response<any>;\n    try {\n      response = await this.queryExecutionContext.fetchMore();\n    } catch (error) {\n      if (this.needsQueryPlan(error)) {\n        await this.createPipelinedExecutionContext();\n        try {\n          response = await this.queryExecutionContext.fetchMore();\n        } catch (error) {\n          this.handleSplitError(error);\n        }\n      } else {\n        throw error;\n      }\n    }\n    return new FeedResponse<T>(\n      response.result,\n      response.headers,\n      this.queryExecutionContext.hasMoreResults()\n    );\n  }\n\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   */\n  public reset() {\n    this.queryPlanPromise = undefined;\n    this.queryExecutionContext = new DefaultQueryExecutionContext(\n      this.options,\n      this.fetchFunctions\n    );\n  }\n\n  private async toArrayImplementation(): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = this.fetchQueryPlan();\n    if (!this.isInitialized) {\n      await this.init();\n    }\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.nextItem();\n      } catch (error) {\n        if (this.needsQueryPlan(error)) {\n          await this.createPipelinedExecutionContext();\n          response = await this.queryExecutionContext.nextItem();\n        } else {\n          throw error;\n        }\n      }\n      const { result, headers } = response;\n      // concatenate the results and fetch more\n      mergeHeaders(this.fetchAllLastResHeaders, headers);\n\n      if (result !== undefined) {\n        this.fetchAllTempResources.push(result);\n      }\n    }\n    return new FeedResponse(\n      this.fetchAllTempResources,\n      this.fetchAllLastResHeaders,\n      this.queryExecutionContext.hasMoreResults()\n    );\n  }\n\n  private async createPipelinedExecutionContext() {\n    const queryPlanResponse = await this.queryPlanPromise;\n\n    // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n    if (queryPlanResponse instanceof Error) {\n      throw queryPlanResponse;\n    }\n\n    const queryPlan = queryPlanResponse.result;\n    const queryInfo = queryPlan.queryInfo;\n    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n      throw new Error(\"Aggregate queries must use the VALUE keyword\");\n    }\n    this.queryExecutionContext = new PipelinedQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.query,\n      this.options,\n      queryPlan\n    );\n  }\n\n  private async fetchQueryPlan() {\n    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n      return this.clientContext\n        .getQueryPlan(\n          getPathFromLink(this.resourceLink) + \"/docs\",\n          ResourceType.item,\n          this.resourceLink,\n          this.query,\n          this.options\n        )\n        .catch((error: any) => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n    }\n    return this.queryPlanPromise;\n  }\n\n  private needsQueryPlan(error: any): error is ErrorResponse {\n    return error.code === StatusCodes.BadRequest;\n  }\n\n  private initPromise: Promise<void>;\n  private async init() {\n    if (this.isInitialized === true) {\n      return;\n    }\n    if (this.initPromise === undefined) {\n      this.initPromise = this._init();\n    }\n    return this.initPromise;\n  }\n  private async _init() {\n    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n      await this.createPipelinedExecutionContext();\n    }\n    this.isInitialized = true;\n  }\n\n  private handleSplitError(err: any) {\n    if (err.code === 410) {\n      const error = new Error(\n        \"Encountered partition split and could not recover. This request is retryable\"\n      ) as any;\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n}\n"]}