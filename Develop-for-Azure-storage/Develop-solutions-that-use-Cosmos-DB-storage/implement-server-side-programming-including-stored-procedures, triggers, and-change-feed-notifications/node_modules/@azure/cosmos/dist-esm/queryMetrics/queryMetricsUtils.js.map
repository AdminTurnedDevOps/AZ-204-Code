{"version":3,"file":"queryMetricsUtils.js","sourceRoot":"","sources":["../../src/queryMetrics/queryMetricsUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAClC,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AAEtC;;;GAGG;AACH,MAAM,UAAU,oBAAoB,CAAC,eAAuB;IAC1D,IAAI,eAAe,IAAI,IAAI,EAAE;QAC3B,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;KACzD;IAED,MAAM,OAAO,GAA2B,EAAE,CAAC;IAE3C,MAAM,gBAAgB,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACpD,KAAK,MAAM,SAAS,IAAI,gBAAgB,EAAE;QACxC,MAAM,iBAAiB,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAE/C,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAClC,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;SAC1D;QAED,MAAM,YAAY,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC;QAC1C,MAAM,cAAc,GAAG,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC;QAExD,OAAO,CAAC,YAAY,CAAC,GAAG,cAAc,CAAC;KACxC;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,mBAAmB,CAAC,OAA+B,CAAC,eAAe,EAAE,GAAW;IAC9F,IAAI,GAAG,IAAI,OAAO,EAAE;QAClB,OAAO,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;KAChD;IAED,OAAO,QAAQ,CAAC,IAAI,CAAC;AACvB,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,SAAS,CAAC,KAAU;IAClC,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;AACtD,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { TimeSpan } from \"./timeSpan\";\n\n/**\n * @ignore\n * @param delimitedString\n */\nexport function parseDelimitedString(delimitedString: string) {\n  if (delimitedString == null) {\n    throw new Error(\"delimitedString is null or undefined\");\n  }\n\n  const metrics: { [key: string]: any } = {};\n\n  const headerAttributes = delimitedString.split(\";\");\n  for (const attribute of headerAttributes) {\n    const attributeKeyValue = attribute.split(\"=\");\n\n    if (attributeKeyValue.length !== 2) {\n      throw new Error(\"recieved a malformed delimited string\");\n    }\n\n    const attributeKey = attributeKeyValue[0];\n    const attributeValue = parseFloat(attributeKeyValue[1]);\n\n    metrics[attributeKey] = attributeValue;\n  }\n\n  return metrics;\n}\n\n/**\n * @ignore\n * @param metrics\n * @param key\n */\nexport function timeSpanFromMetrics(metrics: { [key: string]: any } /* TODO: any */, key: string) {\n  if (key in metrics) {\n    return TimeSpan.fromMilliseconds(metrics[key]);\n  }\n\n  return TimeSpan.zero;\n}\n\n/**\n * @ignore\n * @param input\n */\nexport function isNumeric(input: any) {\n  return !isNaN(parseFloat(input)) && isFinite(input);\n}\n"]}