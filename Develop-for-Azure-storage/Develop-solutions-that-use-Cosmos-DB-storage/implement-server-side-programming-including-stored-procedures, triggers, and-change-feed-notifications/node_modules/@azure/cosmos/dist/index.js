(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('os-name'), require('tslib'), require('crypto'), require('debug'), require('priorityqueuejs'), require('semaphore'), require('fast-json-stable-stringify'), require('uuid/v4'), require('node-abort-controller'), require('node-fetch')) :
    typeof define === 'function' && define.amd ? define(['exports', 'os-name', 'tslib', 'crypto', 'debug', 'priorityqueuejs', 'semaphore', 'fast-json-stable-stringify', 'uuid/v4', 'node-abort-controller', 'node-fetch'], factory) :
    (global = global || self, factory((global.Microsoft = global.Microsoft || {}, global.Microsoft.Azure = global.Microsoft.Azure || {}, global.Microsoft.Azure.Cosmos = {}), global.osName, global.tslib_1, global.crypto, global.debugLib, global.PriorityQueue, global.semaphore, global.stableStringify, global.uuid, global.AbortController, global.fetch));
}(this, (function (exports, osName, tslib, crypto, debugLib, PriorityQueue, semaphore, stableStringify, uuid, AbortController, fetch) { 'use strict';

    osName = osName && Object.prototype.hasOwnProperty.call(osName, 'default') ? osName['default'] : osName;
    debugLib = debugLib && Object.prototype.hasOwnProperty.call(debugLib, 'default') ? debugLib['default'] : debugLib;
    PriorityQueue = PriorityQueue && Object.prototype.hasOwnProperty.call(PriorityQueue, 'default') ? PriorityQueue['default'] : PriorityQueue;
    semaphore = semaphore && Object.prototype.hasOwnProperty.call(semaphore, 'default') ? semaphore['default'] : semaphore;
    stableStringify = stableStringify && Object.prototype.hasOwnProperty.call(stableStringify, 'default') ? stableStringify['default'] : stableStringify;
    uuid = uuid && Object.prototype.hasOwnProperty.call(uuid, 'default') ? uuid['default'] : uuid;
    AbortController = AbortController && Object.prototype.hasOwnProperty.call(AbortController, 'default') ? AbortController['default'] : AbortController;
    fetch = fetch && Object.prototype.hasOwnProperty.call(fetch, 'default') ? fetch['default'] : fetch;

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const DEFAULT_PARTITION_KEY_PATH = "/_partitionKey";

    /**
     * @ignore
     */
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const Constants = {
        HttpHeaders: {
            Authorization: "authorization",
            ETag: "etag",
            MethodOverride: "X-HTTP-Method",
            Slug: "Slug",
            ContentType: "Content-Type",
            LastModified: "Last-Modified",
            ContentEncoding: "Content-Encoding",
            CharacterSet: "CharacterSet",
            UserAgent: "User-Agent",
            IfModifiedSince: "If-Modified-Since",
            IfMatch: "If-Match",
            IfNoneMatch: "If-None-Match",
            ContentLength: "Content-Length",
            AcceptEncoding: "Accept-Encoding",
            KeepAlive: "Keep-Alive",
            CacheControl: "Cache-Control",
            TransferEncoding: "Transfer-Encoding",
            ContentLanguage: "Content-Language",
            ContentLocation: "Content-Location",
            ContentMd5: "Content-Md5",
            ContentRange: "Content-Range",
            Accept: "Accept",
            AcceptCharset: "Accept-Charset",
            AcceptLanguage: "Accept-Language",
            IfRange: "If-Range",
            IfUnmodifiedSince: "If-Unmodified-Since",
            MaxForwards: "Max-Forwards",
            ProxyAuthorization: "Proxy-Authorization",
            AcceptRanges: "Accept-Ranges",
            ProxyAuthenticate: "Proxy-Authenticate",
            RetryAfter: "Retry-After",
            SetCookie: "Set-Cookie",
            WwwAuthenticate: "Www-Authenticate",
            Origin: "Origin",
            Host: "Host",
            AccessControlAllowOrigin: "Access-Control-Allow-Origin",
            AccessControlAllowHeaders: "Access-Control-Allow-Headers",
            KeyValueEncodingFormat: "application/x-www-form-urlencoded",
            WrapAssertionFormat: "wrap_assertion_format",
            WrapAssertion: "wrap_assertion",
            WrapScope: "wrap_scope",
            SimpleToken: "SWT",
            HttpDate: "date",
            Prefer: "Prefer",
            Location: "Location",
            Referer: "referer",
            A_IM: "A-IM",
            // Query
            Query: "x-ms-documentdb-query",
            IsQuery: "x-ms-documentdb-isquery",
            IsQueryPlan: "x-ms-cosmos-is-query-plan-request",
            SupportedQueryFeatures: "x-ms-cosmos-supported-query-features",
            QueryVersion: "x-ms-cosmos-query-version",
            // Our custom Azure Cosmos DB headers
            Continuation: "x-ms-continuation",
            PageSize: "x-ms-max-item-count",
            ItemCount: "x-ms-item-count",
            // Request sender generated. Simply echoed by backend.
            ActivityId: "x-ms-activity-id",
            PreTriggerInclude: "x-ms-documentdb-pre-trigger-include",
            PreTriggerExclude: "x-ms-documentdb-pre-trigger-exclude",
            PostTriggerInclude: "x-ms-documentdb-post-trigger-include",
            PostTriggerExclude: "x-ms-documentdb-post-trigger-exclude",
            IndexingDirective: "x-ms-indexing-directive",
            SessionToken: "x-ms-session-token",
            ConsistencyLevel: "x-ms-consistency-level",
            XDate: "x-ms-date",
            CollectionPartitionInfo: "x-ms-collection-partition-info",
            CollectionServiceInfo: "x-ms-collection-service-info",
            // Deprecated, use RetryAfterInMs instead.
            RetryAfterInMilliseconds: "x-ms-retry-after-ms",
            RetryAfterInMs: "x-ms-retry-after-ms",
            IsFeedUnfiltered: "x-ms-is-feed-unfiltered",
            ResourceTokenExpiry: "x-ms-documentdb-expiry-seconds",
            EnableScanInQuery: "x-ms-documentdb-query-enable-scan",
            EmitVerboseTracesInQuery: "x-ms-documentdb-query-emit-traces",
            EnableCrossPartitionQuery: "x-ms-documentdb-query-enablecrosspartition",
            ParallelizeCrossPartitionQuery: "x-ms-documentdb-query-parallelizecrosspartitionquery",
            ResponseContinuationTokenLimitInKB: "x-ms-documentdb-responsecontinuationtokenlimitinkb",
            // QueryMetrics
            // Request header to tell backend to give you query metrics.
            PopulateQueryMetrics: "x-ms-documentdb-populatequerymetrics",
            // Response header that holds the serialized version of query metrics.
            QueryMetrics: "x-ms-documentdb-query-metrics",
            // Version headers and values
            Version: "x-ms-version",
            // Owner name
            OwnerFullName: "x-ms-alt-content-path",
            // Owner ID used for name based request in session token.
            OwnerId: "x-ms-content-path",
            // Partition Key
            PartitionKey: "x-ms-documentdb-partitionkey",
            PartitionKeyRangeID: "x-ms-documentdb-partitionkeyrangeid",
            // Quota Info
            MaxEntityCount: "x-ms-root-entity-max-count",
            CurrentEntityCount: "x-ms-root-entity-current-count",
            CollectionQuotaInMb: "x-ms-collection-quota-mb",
            CollectionCurrentUsageInMb: "x-ms-collection-usage-mb",
            MaxMediaStorageUsageInMB: "x-ms-max-media-storage-usage-mb",
            CurrentMediaStorageUsageInMB: "x-ms-media-storage-usage-mb",
            RequestCharge: "x-ms-request-charge",
            PopulateQuotaInfo: "x-ms-documentdb-populatequotainfo",
            MaxResourceQuota: "x-ms-resource-quota",
            // Offer header
            OfferType: "x-ms-offer-type",
            OfferThroughput: "x-ms-offer-throughput",
            // Custom RUs/minute headers
            DisableRUPerMinuteUsage: "x-ms-documentdb-disable-ru-per-minute-usage",
            IsRUPerMinuteUsed: "x-ms-documentdb-is-ru-per-minute-used",
            OfferIsRUPerMinuteThroughputEnabled: "x-ms-offer-is-ru-per-minute-throughput-enabled",
            // Index progress headers
            IndexTransformationProgress: "x-ms-documentdb-collection-index-transformation-progress",
            LazyIndexingProgress: "x-ms-documentdb-collection-lazy-indexing-progress",
            // Upsert header
            IsUpsert: "x-ms-documentdb-is-upsert",
            // Sub status of the error
            SubStatus: "x-ms-substatus",
            // StoredProcedure related headers
            EnableScriptLogging: "x-ms-documentdb-script-enable-logging",
            ScriptLogResults: "x-ms-documentdb-script-log-results",
            // Multi-Region Write
            ALLOW_MULTIPLE_WRITES: "x-ms-cosmos-allow-tentative-writes"
        },
        // GlobalDB related constants
        WritableLocations: "writableLocations",
        ReadableLocations: "readableLocations",
        // ServiceDocument Resource
        ENABLE_MULTIPLE_WRITABLE_LOCATIONS: "enableMultipleWriteLocations",
        // Background refresh time
        DefaultUnavailableLocationExpirationTimeMS: 5 * 60 * 1000,
        // Client generated retry count response header
        ThrottleRetryCount: "x-ms-throttle-retry-count",
        ThrottleRetryWaitTimeInMs: "x-ms-throttle-retry-wait-time-ms",
        CurrentVersion: "2018-12-31",
        SDKName: "azure-cosmos-js",
        SDKVersion: "3.6.3",
        Quota: {
            CollectionSize: "collectionSize"
        },
        Path: {
            DatabasesPathSegment: "dbs",
            CollectionsPathSegment: "colls",
            UsersPathSegment: "users",
            DocumentsPathSegment: "docs",
            PermissionsPathSegment: "permissions",
            StoredProceduresPathSegment: "sprocs",
            TriggersPathSegment: "triggers",
            UserDefinedFunctionsPathSegment: "udfs",
            ConflictsPathSegment: "conflicts",
            AttachmentsPathSegment: "attachments",
            PartitionKeyRangesPathSegment: "pkranges",
            SchemasPathSegment: "schemas",
            OffersPathSegment: "offers",
            TopologyPathSegment: "topology",
            DatabaseAccountPathSegment: "databaseaccount"
        },
        PartitionKeyRange: {
            // Partition Key Range Constants
            MinInclusive: "minInclusive",
            MaxExclusive: "maxExclusive",
            Id: "id"
        },
        QueryRangeConstants: {
            // Partition Key Range Constants
            MinInclusive: "minInclusive",
            MaxExclusive: "maxExclusive",
            min: "min"
        },
        EffectiveParitionKeyConstants: {
            MinimumInclusiveEffectivePartitionKey: "",
            MaximumExclusiveEffectivePartitionKey: "FF"
        }
    };
    /**
     * @ignore
     */
    var ResourceType;
    (function (ResourceType) {
        ResourceType["none"] = "";
        ResourceType["database"] = "dbs";
        ResourceType["offer"] = "offers";
        ResourceType["user"] = "users";
        ResourceType["permission"] = "permissions";
        ResourceType["container"] = "colls";
        ResourceType["conflicts"] = "conflicts";
        ResourceType["sproc"] = "sprocs";
        ResourceType["udf"] = "udfs";
        ResourceType["trigger"] = "triggers";
        ResourceType["item"] = "docs";
        ResourceType["pkranges"] = "pkranges";
    })(ResourceType || (ResourceType = {}));
    /**
     * @ignore
     */
    var HTTPMethod;
    (function (HTTPMethod) {
        HTTPMethod["get"] = "GET";
        HTTPMethod["post"] = "POST";
        HTTPMethod["put"] = "PUT";
        HTTPMethod["delete"] = "DELETE";
    })(HTTPMethod || (HTTPMethod = {}));
    (function (OperationType) {
        OperationType["Create"] = "create";
        OperationType["Replace"] = "replace";
        OperationType["Upsert"] = "upsert";
        OperationType["Delete"] = "delete";
        OperationType["Read"] = "read";
        OperationType["Query"] = "query";
        OperationType["Execute"] = "execute";
    })(exports.OperationType || (exports.OperationType = {}));

    const trimLeftSlashes = new RegExp("^[/]+");
    const trimRightSlashes = new RegExp("[/]+$");
    const illegalResourceIdCharacters = new RegExp("[/\\\\?#]");
    /** @hidden */
    function jsonStringifyAndEscapeNonASCII(arg) {
        // TODO: better way for this? Not sure.
        // escapes non-ASCII characters as \uXXXX
        return JSON.stringify(arg).replace(/[\u0080-\uFFFF]/g, (m) => {
            return "\\u" + ("0000" + m.charCodeAt(0).toString(16)).slice(-4);
        });
    }
    /**
     * @ignore
     */
    function parseLink(resourcePath) {
        if (resourcePath.length === 0) {
            /* for DatabaseAccount case, both type and objectBody will be undefined. */
            return {
                type: undefined,
                objectBody: undefined
            };
        }
        if (resourcePath[resourcePath.length - 1] !== "/") {
            resourcePath = resourcePath + "/";
        }
        if (resourcePath[0] !== "/") {
            resourcePath = "/" + resourcePath;
        }
        /*
               The path will be in the form of /[resourceType]/[resourceId]/ ....
               /[resourceType]//[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/
               or /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId]/[resourceType]/[resourceId]/ ....
                /[resourceType]/[resourceId]/
               The result of split will be in the form of
               [[[resourceType], [resourceId] ... ,[resourceType], [resourceId], ""]
               In the first case, to extract the resourceId it will the element before last ( at length -2 )
               and the type will be before it ( at length -3 )
               In the second case, to extract the resource type it will the element before last ( at length -2 )
              */
        const pathParts = resourcePath.split("/");
        let id;
        let type;
        if (pathParts.length % 2 === 0) {
            // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/[resourceId].
            id = pathParts[pathParts.length - 2];
            type = pathParts[pathParts.length - 3];
        }
        else {
            // request in form /[resourceType]/[resourceId]/ .... /[resourceType]/.
            id = pathParts[pathParts.length - 3];
            type = pathParts[pathParts.length - 2];
        }
        const result = {
            type,
            objectBody: {
                id,
                self: resourcePath
            }
        };
        return result;
    }
    /**
     * @ignore
     */
    function isReadRequest(operationType) {
        return operationType === exports.OperationType.Read || operationType === exports.OperationType.Query;
    }
    /**
     * @ignore
     */
    function sleep(time) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, time);
        });
    }
    /**
     * @ignore
     */
    function getContainerLink(link) {
        return link
            .split("/")
            .slice(0, 4)
            .join("/");
    }
    /**
     * @ignore
     */
    function trimSlashes(source) {
        return source.replace(trimLeftSlashes, "").replace(trimRightSlashes, "");
    }
    /**
     * @ignore
     */
    function parsePath(path) {
        const pathParts = [];
        let currentIndex = 0;
        const throwError = () => {
            throw new Error("Path " + path + " is invalid at index " + currentIndex);
        };
        const getEscapedToken = () => {
            const quote = path[currentIndex];
            let newIndex = ++currentIndex;
            while (true) {
                newIndex = path.indexOf(quote, newIndex);
                if (newIndex === -1) {
                    throwError();
                }
                if (path[newIndex - 1] !== "\\") {
                    break;
                }
                ++newIndex;
            }
            const token = path.substr(currentIndex, newIndex - currentIndex);
            currentIndex = newIndex + 1;
            return token;
        };
        const getToken = () => {
            const newIndex = path.indexOf("/", currentIndex);
            let token = null;
            if (newIndex === -1) {
                token = path.substr(currentIndex);
                currentIndex = path.length;
            }
            else {
                token = path.substr(currentIndex, newIndex - currentIndex);
                currentIndex = newIndex;
            }
            token = token.trim();
            return token;
        };
        while (currentIndex < path.length) {
            if (path[currentIndex] !== "/") {
                throwError();
            }
            if (++currentIndex === path.length) {
                break;
            }
            if (path[currentIndex] === '"' || path[currentIndex] === "'") {
                pathParts.push(getEscapedToken());
            }
            else {
                pathParts.push(getToken());
            }
        }
        return pathParts;
    }
    /**
     * @ignore
     */
    function isResourceValid(resource, err) {
        // TODO: any TODO: code smell
        if (resource.id) {
            if (typeof resource.id !== "string") {
                err.message = "Id must be a string.";
                return false;
            }
            if (resource.id.indexOf("/") !== -1 ||
                resource.id.indexOf("\\") !== -1 ||
                resource.id.indexOf("?") !== -1 ||
                resource.id.indexOf("#") !== -1) {
                err.message = "Id contains illegal chars.";
                return false;
            }
            if (resource.id[resource.id.length - 1] === " ") {
                err.message = "Id ends with a space.";
                return false;
            }
        }
        return true;
    }
    /** @ignore */
    function getIdFromLink(resourceLink) {
        resourceLink = trimSlashes(resourceLink);
        return resourceLink;
    }
    /** @ignore */
    function getPathFromLink(resourceLink, resourceType) {
        resourceLink = trimSlashes(resourceLink);
        if (resourceType) {
            return "/" + encodeURI(resourceLink) + "/" + resourceType;
        }
        else {
            return "/" + encodeURI(resourceLink);
        }
    }
    /**
     * @ignore
     */
    function isStringNullOrEmpty(inputString) {
        // checks whether string is null, undefined, empty or only contains space
        return !inputString || /^\s*$/.test(inputString);
    }
    /**
     * @ignore
     */
    function trimSlashFromLeftAndRight(inputString) {
        if (typeof inputString !== "string") {
            throw new Error("invalid input: input is not string");
        }
        return inputString.replace(trimLeftSlashes, "").replace(trimRightSlashes, "");
    }
    /**
     * @ignore
     */
    function validateResourceId(resourceId) {
        // if resourceId is not a string or is empty throw an error
        if (typeof resourceId !== "string" || isStringNullOrEmpty(resourceId)) {
            throw new Error("Resource Id must be a string and cannot be undefined, null or empty");
        }
        // if resourceId starts or ends with space throw an error
        if (resourceId[resourceId.length - 1] === " ") {
            throw new Error("Resource Id cannot end with space");
        }
        // if resource id contains illegal characters throw an error
        if (illegalResourceIdCharacters.test(resourceId)) {
            throw new Error("Illegal characters ['/', '\\', '?', '#'] cannot be used in resourceId");
        }
        return true;
    }
    /**
     * @ignore
     * @param resourcePath
     */
    function getResourceIdFromPath(resourcePath) {
        if (!resourcePath || typeof resourcePath !== "string") {
            return null;
        }
        const trimmedPath = trimSlashFromLeftAndRight(resourcePath);
        const pathSegments = trimmedPath.split("/");
        // number of segments of a path must always be even
        if (pathSegments.length % 2 !== 0) {
            return null;
        }
        return pathSegments[pathSegments.length - 1];
    }
    /**
     * @ignore
     */
    function parseConnectionString(connectionString) {
        const keyValueStrings = connectionString.split(";");
        const { AccountEndpoint, AccountKey } = keyValueStrings.reduce((connectionObject, keyValueString) => {
            const [key, ...value] = keyValueString.split("=");
            connectionObject[key] = value.join("=");
            return connectionObject;
        }, {});
        if (!AccountEndpoint || !AccountKey) {
            throw new Error("Could not parse the provided connection string");
        }
        return {
            endpoint: AccountEndpoint,
            key: AccountKey
        };
    }
    /**
     * @ignore
     */
    // https://github.com/iliakan/detect-node/blob/master/index.js
    const isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) ===
        "[object process]";

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * @ignore
     */
    const StatusCodes = {
        // Success
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NoContent: 204,
        NotModified: 304,
        // Client error
        BadRequest: 400,
        Unauthorized: 401,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        PreconditionFailed: 412,
        RequestEntityTooLarge: 413,
        TooManyRequests: 429,
        RetryWith: 449,
        // Server Error
        InternalServerError: 500,
        ServiceUnavailable: 503,
        // Operation pause and cancel. These are FAKE status codes for QOS logging purpose only.
        OperationPaused: 1200,
        OperationCancelled: 1201
    };
    /**
     * @ignore
     */
    const SubStatusCodes = {
        Unknown: 0,
        // 400: Bad Request Substatus
        CrossPartitionQueryNotServable: 1004,
        // 410: StatusCodeType_Gone: substatus
        PartitionKeyRangeGone: 1002,
        // 404: NotFound Substatus
        ReadSessionNotAvailable: 1002,
        // 403: Forbidden Substatus
        WriteForbidden: 3,
        DatabaseAccountNotFound: 1008
    };

    // Copyright (c) Microsoft Corporation.
    /**
     * @ignore
     * Given a database id, this creates a database link.
     * @param {string} databaseId -The database id
     * @returns {string}          -A database link in the format of dbs/{0} \
     * with {0} being a Uri escaped version of the databaseId
     * @description Would be used when creating or deleting a DocumentCollection \
     * or a User in Azure Cosmos DB database service
     */
    function createDatabaseUri(databaseId) {
        databaseId = trimSlashFromLeftAndRight(databaseId);
        validateResourceId(databaseId);
        return Constants.Path.DatabasesPathSegment + "/" + databaseId;
    }
    /**
     * Given a database and collection id, this creates a collection link.
     * @param {string} databaseId        -The database id
     * @param {string} collectionId      -The collection id
     * @returns {string}                 A collection link in the format of dbs/{0}/colls/{1} \
     * with {0} being a Uri escaped version of the databaseId and {1} being collectionId
     * @description Would be used when updating or deleting a DocumentCollection, creating a \
     * Document, a StoredProcedure, a Trigger, a UserDefinedFunction, or when executing a query \
     * with CreateDocumentQuery in Azure Cosmos DB database service.
     * @ignore
     */
    function createDocumentCollectionUri(databaseId, collectionId) {
        collectionId = trimSlashFromLeftAndRight(collectionId);
        validateResourceId(collectionId);
        return (createDatabaseUri(databaseId) + "/" + Constants.Path.CollectionsPathSegment + "/" + collectionId);
    }
    /**
     * Given a database and user id, this creates a user link.
     * @param {string} databaseId        -The database id
     * @param {string} userId            -The user id
     * @returns {string}                 A user link in the format of dbs/{0}/users/{1} \
     * with {0} being a Uri escaped version of the databaseId and {1} being userId
     * @description Would be used when creating a Permission, or when replacing or deleting \
     * a User in Azure Cosmos DB database service
     * @ignore
     */
    function createUserUri(databaseId, userId) {
        userId = trimSlashFromLeftAndRight(userId);
        validateResourceId(userId);
        return createDatabaseUri(databaseId) + "/" + Constants.Path.UsersPathSegment + "/" + userId;
    }
    /**
     * Given a database and collection id, this creates a collection link.
     * @param {string} databaseId        -The database id
     * @param {string} collectionId      -The collection id
     * @param {string} documentId        -The document id
     * @returns {string}                 -A document link in the format of \
     * dbs/{0}/colls/{1}/docs/{2} with {0} being a Uri escaped version of \
     * the databaseId, {1} being collectionId and {2} being the documentId
     * @description Would be used when creating an Attachment, or when replacing \
     * or deleting a Document in Azure Cosmos DB database service
     * @ignore
     */
    function createDocumentUri(databaseId, collectionId, documentId) {
        documentId = trimSlashFromLeftAndRight(documentId);
        validateResourceId(documentId);
        return (createDocumentCollectionUri(databaseId, collectionId) +
            "/" +
            Constants.Path.DocumentsPathSegment +
            "/" +
            documentId);
    }
    /**
     * Given a database, collection and document id, this creates a document link.
     * @param {string} databaseId    -The database Id
     * @param {string} userId        -The user Id
     * @param {string} permissionId  - The permissionId
     * @returns {string} A permission link in the format of dbs/{0}/users/{1}/permissions/{2} \
     * with {0} being a Uri escaped version of the databaseId, {1} being userId and {2} being permissionId
     * @description Would be used when replacing or deleting a Permission in Azure Cosmos DB database service.
     * @ignore
     */
    function createPermissionUri(databaseId, userId, permissionId) {
        permissionId = trimSlashFromLeftAndRight(permissionId);
        validateResourceId(permissionId);
        return (createUserUri(databaseId, userId) +
            "/" +
            Constants.Path.PermissionsPathSegment +
            "/" +
            permissionId);
    }
    /**
     * Given a database, collection and stored proc id, this creates a stored proc link.
     * @param {string} databaseId        -The database Id
     * @param {string} collectionId      -The collection Id
     * @param {string} storedProcedureId -The stored procedure Id
     * @returns {string}                 -A stored procedure link in the format of \
     * dbs/{0}/colls/{1}/sprocs/{2} with {0} being a Uri escaped version of the databaseId, \
     * {1} being collectionId and {2} being the storedProcedureId
     * @description Would be used when replacing, executing, or deleting a StoredProcedure in \
     * Azure Cosmos DB database service.
     * @ignore
     */
    function createStoredProcedureUri(databaseId, collectionId, storedProcedureId) {
        storedProcedureId = trimSlashFromLeftAndRight(storedProcedureId);
        validateResourceId(storedProcedureId);
        return (createDocumentCollectionUri(databaseId, collectionId) +
            "/" +
            Constants.Path.StoredProceduresPathSegment +
            "/" +
            storedProcedureId);
    }
    /**
     * @summary Given a database, collection and trigger id, this creates a trigger link.
     * @param {string} databaseId        -The database Id
     * @param {string} collectionId      -The collection Id
     * @param {string} triggerId         -The trigger Id
     * @returns {string}                 -A trigger link in the format of \
     * dbs/{0}/colls/{1}/triggers/{2} with {0} being a Uri escaped version of the databaseId, \
     * {1} being collectionId and {2} being the triggerId
     * @description Would be used when replacing, executing, or deleting a Trigger in Azure Cosmos DB database service
     * @ignore
     */
    function createTriggerUri(databaseId, collectionId, triggerId) {
        triggerId = trimSlashFromLeftAndRight(triggerId);
        validateResourceId(triggerId);
        return (createDocumentCollectionUri(databaseId, collectionId) +
            "/" +
            Constants.Path.TriggersPathSegment +
            "/" +
            triggerId);
    }
    /**
     * @summary Given a database, collection and udf id, this creates a udf link.
     * @param {string} databaseId        -The database Id
     * @param {string} collectionId      -The collection Id
     * @param {string} udfId             -The User Defined Function Id
     * @returns {string}                 -A udf link in the format of dbs/{0}/colls/{1}/udfs/{2} \
     * with {0} being a Uri escaped version of the databaseId, {1} being collectionId and {2} being the udfId
     * @description Would be used when replacing, executing, or deleting a UserDefinedFunction in \
     * Azure Cosmos DB database service
     * @ignore
     */
    function createUserDefinedFunctionUri(databaseId, collectionId, udfId) {
        udfId = trimSlashFromLeftAndRight(udfId);
        validateResourceId(udfId);
        return (createDocumentCollectionUri(databaseId, collectionId) +
            "/" +
            Constants.Path.UserDefinedFunctionsPathSegment +
            "/" +
            udfId);
    }

    function userAgent() {
        try {
            return `Node.js/${process.version.substr(1)} (${osName()}; ${process.arch})`;
        }
        catch (error) {
            if (/wmic os get Caption/.test(error.message)) {
                return "Windows <version undetectable>";
            }
            throw error;
        }
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * @ignore
     */
    function getUserAgent(suffix) {
        const ua = `${userAgent()} ${Constants.SDKName}/${Constants.SDKVersion}`;
        if (suffix) {
            return ua + " " + suffix;
        }
        return ua;
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * @ignore
     * @param document
     * @param partitionKeyDefinition
     */
    function extractPartitionKey(document, partitionKeyDefinition) {
        if (partitionKeyDefinition &&
            partitionKeyDefinition.paths &&
            partitionKeyDefinition.paths.length > 0) {
            const partitionKey = [];
            partitionKeyDefinition.paths.forEach((path) => {
                const pathParts = parsePath(path);
                let obj = document;
                for (const part of pathParts) {
                    if (!(typeof obj === "object" && part in obj)) {
                        obj = undefined;
                        break;
                    }
                    obj = obj[part];
                }
                partitionKey.push(obj);
            });
            if (partitionKey.length === 1 && partitionKey[0] === undefined) {
                return undefinedPartitionKey(partitionKeyDefinition);
            }
            return partitionKey;
        }
    }
    /**
     * @ignore
     * @param partitionKeyDefinition
     */
    function undefinedPartitionKey(partitionKeyDefinition) {
        if (partitionKeyDefinition.systemKey === true) {
            return [];
        }
        else {
            return [{}];
        }
    }

    function hmac(key, message) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return crypto.createHmac("sha256", Buffer.from(key, "base64"))
                .update(message)
                .digest("base64");
        });
    }

    function generateHeaders(masterKey, method, resourceType = ResourceType.none, resourceId = "", date = new Date()) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const sig = yield signature(masterKey, method, resourceType, resourceId, date);
            return {
                Authorization: sig,
                "x-ms-date": date.toUTCString()
            };
        });
    }
    function signature(masterKey, method, resourceType, resourceId = "", date = new Date()) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const type = "master";
            const version = "1.0";
            const text = method.toLowerCase() +
                "\n" +
                resourceType.toLowerCase() +
                "\n" +
                resourceId +
                "\n" +
                date.toUTCString().toLowerCase() +
                "\n" +
                "" +
                "\n";
            const signed = yield hmac(masterKey, text);
            return encodeURIComponent("type=" + type + "&ver=" + version + "&sig=" + signed);
        });
    }

    /**
     * @ignore
     * @param clientOptions
     * @param verb
     * @param path
     * @param resourceId
     * @param resourceType
     * @param headers
     */
    function setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (clientOptions.permissionFeed) {
                clientOptions.resourceTokens = {};
                for (const permission of clientOptions.permissionFeed) {
                    const id = getResourceIdFromPath(permission.resource);
                    if (!id) {
                        throw new Error(`authorization error: ${id} \
                          is an invalid resourceId in permissionFeed`);
                    }
                    clientOptions.resourceTokens[id] = permission._token; // TODO: any
                }
            }
            if (clientOptions.key) {
                yield setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, clientOptions.key);
            }
            else if (clientOptions.resourceTokens) {
                headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId));
            }
            else if (clientOptions.tokenProvider) {
                headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(yield clientOptions.tokenProvider({ verb, path, resourceId, resourceType, headers }));
            }
        });
    }
    /**
     * The default function for setting header token using the masterKey
     * @ignore
     */
    function setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, masterKey) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // TODO This should live in cosmos-sign
            if (resourceType === ResourceType.offer) {
                resourceId = resourceId && resourceId.toLowerCase();
            }
            headers = Object.assign(headers, yield generateHeaders(masterKey, verb, resourceType, resourceId));
        });
    }
    /**
     * @ignore
     * @param resourceTokens
     * @param path
     * @param resourceId
     */
    // TODO: Resource tokens
    function getAuthorizationTokenUsingResourceTokens(resourceTokens, path, resourceId) {
        if (resourceTokens && Object.keys(resourceTokens).length > 0) {
            // For database account access(through getDatabaseAccount API), path and resourceId are "",
            // so in this case we return the first token to be used for creating the auth header as the
            // service will accept any token in this case
            if (!path && !resourceId) {
                return resourceTokens[Object.keys(resourceTokens)[0]];
            }
            if (resourceId && resourceTokens[resourceId]) {
                return resourceTokens[resourceId];
            }
            // minimum valid path /dbs
            if (!path || path.length < 4) {
                return null;
            }
            // remove '/' from left and right of path
            path = path[0] === "/" ? path.substring(1) : path;
            path = path[path.length - 1] === "/" ? path.substring(0, path.length - 1) : path;
            const pathSegments = (path && path.split("/")) || [];
            // if it's an incomplete path like /dbs/db1/colls/, start from the paretn resource
            let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;
            for (; index > 0; index -= 2) {
                const id = decodeURI(pathSegments[index]);
                if (resourceTokens[id]) {
                    return resourceTokens[id];
                }
            }
        }
        return null;
    }

    // Copyright (c) Microsoft Corporation.
    (function (ConnectionMode) {
        /** Gateway mode talks to a intermediate gateway which handles the direct communicationi with your individual partitions. */
        ConnectionMode[ConnectionMode["Gateway"] = 0] = "Gateway";
    })(exports.ConnectionMode || (exports.ConnectionMode = {}));

    /**
     * @ignore
     */
    const defaultConnectionPolicy = Object.freeze({
        connectionMode: exports.ConnectionMode.Gateway,
        requestTimeout: 60000,
        enableEndpointDiscovery: true,
        preferredLocations: [],
        retryOptions: {},
        useMultipleWriteLocations: true
    });

    // Copyright (c) Microsoft Corporation.
    (function (ConsistencyLevel) {
        /**
         * Strong Consistency guarantees that read operations always return the value that was last written.
         */
        ConsistencyLevel["Strong"] = "Strong";
        /**
         * Bounded Staleness guarantees that reads are not too out-of-date.
         * This can be configured based on number of operations (MaxStalenessPrefix) or time (MaxStalenessIntervalInSeconds).
         */
        ConsistencyLevel["BoundedStaleness"] = "BoundedStaleness";
        /**
         * Session Consistency guarantees monotonic reads (you never read old data, then new, then old again),
         * monotonic writes (writes are ordered) and read your writes (your writes are immediately visible to your reads)
         * within any single session.
         */
        ConsistencyLevel["Session"] = "Session";
        /**
         * Eventual Consistency guarantees that reads will return a subset of writes.
         * All writes will be eventually be available for reads.
         */
        ConsistencyLevel["Eventual"] = "Eventual";
        /**
         * ConsistentPrefix Consistency guarantees that reads will return some prefix of all writes with no gaps.
         * All writes will be eventually be available for reads.`
         */
        ConsistencyLevel["ConsistentPrefix"] = "ConsistentPrefix";
    })(exports.ConsistencyLevel || (exports.ConsistencyLevel = {}));

    // Copyright (c) Microsoft Corporation.
    /**
     * Represents a DatabaseAccount in the Azure Cosmos DB database service.
     */
    class DatabaseAccount {
        // TODO: body - any
        constructor(body, headers) {
            /** The list of writable locations for a geo-replicated database account. */
            this.writableLocations = [];
            /** The list of readable locations for a geo-replicated database account. */
            this.readableLocations = [];
            this.databasesLink = "/dbs/";
            this.mediaLink = "/media/";
            this.maxMediaStorageUsageInMB = headers[Constants.HttpHeaders.MaxMediaStorageUsageInMB];
            this.currentMediaStorageUsageInMB = headers[Constants.HttpHeaders.CurrentMediaStorageUsageInMB];
            this.consistencyPolicy = body.UserConsistencyPolicy
                ? body.UserConsistencyPolicy.defaultConsistencyLevel
                : exports.ConsistencyLevel.Session;
            if (body[Constants.WritableLocations] && body.id !== "localhost") {
                this.writableLocations = body[Constants.WritableLocations];
            }
            if (body[Constants.ReadableLocations] && body.id !== "localhost") {
                this.readableLocations = body[Constants.ReadableLocations];
            }
            if (body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS]) {
                this.enableMultipleWritableLocations =
                    body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS] === true ||
                        body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS] === "true";
            }
        }
        /**
         * The self-link for Databases in the databaseAccount.
         * @deprecated Use `databasesLink`
         */
        get DatabasesLink() {
            return this.databasesLink;
        }
        /**
         * The self-link for Media in the databaseAccount.
         * @deprecated Use `mediaLink`
         */
        get MediaLink() {
            return this.mediaLink;
        }
        /**
         * Attachment content (media) storage quota in MBs ( Retrieved from gateway ).
         * @deprecated use `maxMediaStorageUsageInMB
         */
        get MaxMediaStorageUsageInMB() {
            return this.maxMediaStorageUsageInMB;
        }
        /**
         * Current attachment content (media) usage in MBs (Retrieved from gateway )
         *
         * Value is returned from cached information updated periodically and is not guaranteed
         * to be real time.
         *
         * @deprecated use `currentMediaStorageUsageInMB`
         */
        get CurrentMediaStorageUsageInMB() {
            return this.currentMediaStorageUsageInMB;
        }
        /**
         * Gets the UserConsistencyPolicy settings.
         * @deprecated use `consistencyPolicy`
         */
        get ConsistencyPolicy() {
            return this.consistencyPolicy;
        }
    }

    // Copyright (c) Microsoft Corporation.
    (function (DataType) {
        /** Represents a numeric data type. */
        DataType["Number"] = "Number";
        /** Represents a string data type. */
        DataType["String"] = "String";
        /** Represents a point data type. */
        DataType["Point"] = "Point";
        /** Represents a line string data type. */
        DataType["LineString"] = "LineString";
        /** Represents a polygon data type. */
        DataType["Polygon"] = "Polygon";
        /** Represents a multi-polygon data type. */
        DataType["MultiPolygon"] = "MultiPolygon";
    })(exports.DataType || (exports.DataType = {}));

    // Copyright (c) Microsoft Corporation.
    (function (IndexingMode) {
        /**
         * Index is updated synchronously with a create or update operation.
         *
         * With consistent indexing, query behavior is the same as the default consistency level for the container.
         * The index is always kept up to date with the data.
         */
        IndexingMode["consistent"] = "consistent";
        /**
         * Index is updated asynchronously with respect to a create or update operation.
         *
         * With lazy indexing, queries are eventually consistent. The index is updated when the container is idle.
         */
        IndexingMode["lazy"] = "lazy";
        /** No Index is provided. */
        IndexingMode["none"] = "none";
    })(exports.IndexingMode || (exports.IndexingMode = {}));

    /* The target data type of a spatial path */
    var SpatialType;
    (function (SpatialType) {
        SpatialType["LineString"] = "LineString";
        SpatialType["MultiPolygon"] = "MultiPolygon";
        SpatialType["Point"] = "Point";
        SpatialType["Polygon"] = "Polygon";
    })(SpatialType || (SpatialType = {}));

    // Copyright (c) Microsoft Corporation.
    (function (IndexKind) {
        /**
         * This is supplied for a path which requires sorting.
         */
        IndexKind["Range"] = "Range";
        /**
         * This is supplied for a path which requires geospatial indexing.
         */
        IndexKind["Spatial"] = "Spatial";
    })(exports.IndexKind || (exports.IndexKind = {}));

    // Copyright (c) Microsoft Corporation.
    (function (PermissionMode) {
        /** Permission not valid. */
        PermissionMode["None"] = "none";
        /** Permission applicable for read operations only. */
        PermissionMode["Read"] = "read";
        /** Permission applicable for all operations. */
        PermissionMode["All"] = "all";
    })(exports.PermissionMode || (exports.PermissionMode = {}));

    // Copyright (c) Microsoft Corporation.
    (function (TriggerOperation) {
        /** All operations. */
        TriggerOperation["All"] = "all";
        /** Create operations only. */
        TriggerOperation["Create"] = "create";
        /** Update operations only. */
        TriggerOperation["Update"] = "update";
        /** Delete operations only. */
        TriggerOperation["Delete"] = "delete";
        /** Replace operations only. */
        TriggerOperation["Replace"] = "replace";
    })(exports.TriggerOperation || (exports.TriggerOperation = {}));

    // Copyright (c) Microsoft Corporation.
    (function (TriggerType) {
        /** Trigger should be executed before the associated operation(s). */
        TriggerType["Pre"] = "pre";
        /** Trigger should be executed after the associated operation(s). */
        TriggerType["Post"] = "post";
    })(exports.TriggerType || (exports.TriggerType = {}));

    // Copyright (c) Microsoft Corporation.
    (function (UserDefinedFunctionType) {
        /** The User Defined Function is written in JavaScript. This is currently the only option. */
        UserDefinedFunctionType["Javascript"] = "Javascript";
    })(exports.UserDefinedFunctionType || (exports.UserDefinedFunctionType = {}));

    // Copyright (c) Microsoft Corporation.
    class ResourceResponse {
        constructor(resource, headers, statusCode, substatus) {
            this.resource = resource;
            this.headers = headers;
            this.statusCode = statusCode;
            this.substatus = substatus;
        }
        get requestCharge() {
            return Number(this.headers[Constants.HttpHeaders.RequestCharge]) || 0;
        }
        get activityId() {
            return this.headers[Constants.HttpHeaders.ActivityId];
        }
        get etag() {
            return this.headers[Constants.HttpHeaders.ETag];
        }
    }

    // Copyright (c) Microsoft Corporation.
    class FeedResponse {
        constructor(resources, headers, hasMoreResults) {
            this.resources = resources;
            this.headers = headers;
            this.hasMoreResults = hasMoreResults;
        }
        get continuation() {
            return this.continuationToken;
        }
        get continuationToken() {
            return this.headers[Constants.HttpHeaders.Continuation];
        }
        get queryMetrics() {
            return this.headers[Constants.HttpHeaders.QueryMetrics];
        }
        get requestCharge() {
            return this.headers[Constants.HttpHeaders.RequestCharge];
        }
        get activityId() {
            return this.headers[Constants.HttpHeaders.ActivityId];
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    class ClientSideMetrics {
        constructor(requestCharge) {
            this.requestCharge = requestCharge;
        }
        /**
         * Adds one or more ClientSideMetrics to a copy of this instance and returns the result.
         */
        add(...clientSideMetricsArray) {
            let requestCharge = this.requestCharge;
            for (const clientSideMetrics of clientSideMetricsArray) {
                if (clientSideMetrics == null) {
                    throw new Error("clientSideMetrics has null or undefined item(s)");
                }
                requestCharge += clientSideMetrics.requestCharge;
            }
            return new ClientSideMetrics(requestCharge);
        }
        static createFromArray(...clientSideMetricsArray) {
            if (clientSideMetricsArray == null) {
                throw new Error("clientSideMetricsArray is null or undefined item(s)");
            }
            return this.zero.add(...clientSideMetricsArray);
        }
    }
    ClientSideMetrics.zero = new ClientSideMetrics(0);

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var QueryMetricsConstants = {
        // QueryMetrics
        RetrievedDocumentCount: "retrievedDocumentCount",
        RetrievedDocumentSize: "retrievedDocumentSize",
        OutputDocumentCount: "outputDocumentCount",
        OutputDocumentSize: "outputDocumentSize",
        IndexHitRatio: "indexUtilizationRatio",
        IndexHitDocumentCount: "indexHitDocumentCount",
        TotalQueryExecutionTimeInMs: "totalExecutionTimeInMs",
        // QueryPreparationTimes
        QueryCompileTimeInMs: "queryCompileTimeInMs",
        LogicalPlanBuildTimeInMs: "queryLogicalPlanBuildTimeInMs",
        PhysicalPlanBuildTimeInMs: "queryPhysicalPlanBuildTimeInMs",
        QueryOptimizationTimeInMs: "queryOptimizationTimeInMs",
        // QueryTimes
        IndexLookupTimeInMs: "indexLookupTimeInMs",
        DocumentLoadTimeInMs: "documentLoadTimeInMs",
        VMExecutionTimeInMs: "VMExecutionTimeInMs",
        DocumentWriteTimeInMs: "writeOutputTimeInMs",
        // RuntimeExecutionTimes
        QueryEngineTimes: "queryEngineTimes",
        SystemFunctionExecuteTimeInMs: "systemFunctionExecuteTimeInMs",
        UserDefinedFunctionExecutionTimeInMs: "userFunctionExecuteTimeInMs",
        // QueryMetrics Text
        RetrievedDocumentCountText: "Retrieved Document Count",
        RetrievedDocumentSizeText: "Retrieved Document Size",
        OutputDocumentCountText: "Output Document Count",
        OutputDocumentSizeText: "Output Document Size",
        IndexUtilizationText: "Index Utilization",
        TotalQueryExecutionTimeText: "Total Query Execution Time",
        // QueryPreparationTimes Text
        QueryPreparationTimesText: "Query Preparation Times",
        QueryCompileTimeText: "Query Compilation Time",
        LogicalPlanBuildTimeText: "Logical Plan Build Time",
        PhysicalPlanBuildTimeText: "Physical Plan Build Time",
        QueryOptimizationTimeText: "Query Optimization Time",
        // QueryTimes Text
        QueryEngineTimesText: "Query Engine Times",
        IndexLookupTimeText: "Index Lookup Time",
        DocumentLoadTimeText: "Document Load Time",
        WriteOutputTimeText: "Document Write Time",
        // RuntimeExecutionTimes Text
        RuntimeExecutionTimesText: "Runtime Execution Times",
        TotalExecutionTimeText: "Query Engine Execution Time",
        SystemFunctionExecuteTimeText: "System Function Execution Time",
        UserDefinedFunctionExecutionTimeText: "User-defined Function Execution Time",
        // ClientSideQueryMetrics Text
        ClientSideQueryMetricsText: "Client Side Metrics",
        RetriesText: "Retry Count",
        RequestChargeText: "Request Charge",
        FetchExecutionRangesText: "Partition Execution Timeline",
        SchedulingMetricsText: "Scheduling Metrics"
    };

    // Ported this implementation to javascript:
    // https://referencesource.microsoft.com/#mscorlib/system/timespan.cs,83e476c1ae112117
    /** @hidden */
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    const ticksPerMillisecond = 10000;
    /** @hidden */
    const millisecondsPerTick = 1.0 / ticksPerMillisecond;
    /** @hidden */
    const ticksPerSecond = ticksPerMillisecond * 1000; // 10,000,000
    /** @hidden */
    const secondsPerTick = 1.0 / ticksPerSecond; // 0.0001
    /** @hidden */
    const ticksPerMinute = ticksPerSecond * 60; // 600,000,000
    /** @hidden */
    const minutesPerTick = 1.0 / ticksPerMinute; // 1.6666666666667e-9
    /** @hidden */
    const ticksPerHour = ticksPerMinute * 60; // 36,000,000,000
    /** @hidden */
    const hoursPerTick = 1.0 / ticksPerHour; // 2.77777777777777778e-11
    /** @hidden */
    const ticksPerDay = ticksPerHour * 24; // 864,000,000,000
    /** @hidden */
    const daysPerTick = 1.0 / ticksPerDay; // 1.1574074074074074074e-12
    /** @hidden */
    const millisPerSecond = 1000;
    /** @hidden */
    const millisPerMinute = millisPerSecond * 60; //     60,000
    /** @hidden */
    const millisPerHour = millisPerMinute * 60; //  3,600,000
    /** @hidden */
    const millisPerDay = millisPerHour * 24; // 86,400,000
    /** @hidden */
    const maxMilliSeconds = Number.MAX_SAFE_INTEGER / ticksPerMillisecond;
    /** @hidden */
    const minMilliSeconds = Number.MIN_SAFE_INTEGER / ticksPerMillisecond;
    /**
     * Represents a time interval.
     *
     * @constructor TimeSpan
     * @param {number} days                 - Number of days.
     * @param {number} hours                - Number of hours.
     * @param {number} minutes              - Number of minutes.
     * @param {number} seconds              - Number of seconds.
     * @param {number} milliseconds         - Number of milliseconds.
     * @ignore
     */
    class TimeSpan {
        constructor(days, hours, minutes, seconds, milliseconds) {
            // Constructor
            if (!Number.isInteger(days)) {
                throw new Error("days is not an integer");
            }
            if (!Number.isInteger(hours)) {
                throw new Error("hours is not an integer");
            }
            if (!Number.isInteger(minutes)) {
                throw new Error("minutes is not an integer");
            }
            if (!Number.isInteger(seconds)) {
                throw new Error("seconds is not an integer");
            }
            if (!Number.isInteger(milliseconds)) {
                throw new Error("milliseconds is not an integer");
            }
            const totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds;
            if (totalMilliSeconds > maxMilliSeconds || totalMilliSeconds < minMilliSeconds) {
                throw new Error("Total number of milliseconds was either too large or too small");
            }
            this._ticks = totalMilliSeconds * ticksPerMillisecond;
        }
        /**
         * Returns a new TimeSpan object whose value is the sum of the specified TimeSpan object and this instance.
         * @param {TimeSpan} ts              - The time interval to add.
         * @memberof TimeSpan
         * @instance
         */
        add(ts) {
            if (TimeSpan.additionDoesOverflow(this._ticks, ts._ticks)) {
                throw new Error("Adding the two timestamps causes an overflow.");
            }
            const results = this._ticks + ts._ticks;
            return TimeSpan.fromTicks(results);
        }
        /**
         * Returns a new TimeSpan object whose value is the difference of the specified TimeSpan object and this instance.
         * @param {TimeSpan} ts              - The time interval to subtract.
         * @memberof TimeSpan
         * @instance
         */
        subtract(ts) {
            if (TimeSpan.subtractionDoesUnderflow(this._ticks, ts._ticks)) {
                throw new Error("Subtracting the two timestamps causes an underflow.");
            }
            const results = this._ticks - ts._ticks;
            return TimeSpan.fromTicks(results);
        }
        /**
         * Compares this instance to a specified object and returns an integer that indicates whether this
         * instance is shorter than, equal to, or longer than the specified object.
         * @param {TimeSpan} value              - The time interval to add.
         * @memberof TimeSpan
         * @instance
         */
        compareTo(value) {
            if (value == null) {
                return 1;
            }
            if (!TimeSpan.isTimeSpan(value)) {
                throw new Error("Argument must be a TimeSpan object");
            }
            return TimeSpan.compare(this, value);
        }
        /**
         * Returns a new TimeSpan object whose value is the absolute value of the current TimeSpan object.
         * @memberof TimeSpan
         * @instance
         */
        duration() {
            return TimeSpan.fromTicks(this._ticks >= 0 ? this._ticks : -this._ticks);
        }
        /**
         * Returns a value indicating whether this instance is equal to a specified object.
         * @memberof TimeSpan
         * @param {TimeSpan} value              - The time interval to check for equality.
         * @instance
         */
        equals(value) {
            if (TimeSpan.isTimeSpan(value)) {
                return this._ticks === value._ticks;
            }
            return false;
        }
        /**
         * Returns a new TimeSpan object whose value is the negated value of this instance.
         * @memberof TimeSpan
         * @param {TimeSpan} value              - The time interval to check for equality.
         * @instance
         */
        negate() {
            return TimeSpan.fromTicks(-this._ticks);
        }
        days() {
            return Math.floor(this._ticks / ticksPerDay);
        }
        hours() {
            return Math.floor(this._ticks / ticksPerHour);
        }
        milliseconds() {
            return Math.floor(this._ticks / ticksPerMillisecond);
        }
        seconds() {
            return Math.floor(this._ticks / ticksPerSecond);
        }
        ticks() {
            return this._ticks;
        }
        totalDays() {
            return this._ticks * daysPerTick;
        }
        totalHours() {
            return this._ticks * hoursPerTick;
        }
        totalMilliseconds() {
            return this._ticks * millisecondsPerTick;
        }
        totalMinutes() {
            return this._ticks * minutesPerTick;
        }
        totalSeconds() {
            return this._ticks * secondsPerTick;
        }
        static fromTicks(value) {
            const timeSpan = new TimeSpan(0, 0, 0, 0, 0);
            timeSpan._ticks = value;
            return timeSpan;
        }
        static isTimeSpan(timespan) {
            return timespan._ticks;
        }
        static additionDoesOverflow(a, b) {
            const c = a + b;
            return a !== c - b || b !== c - a;
        }
        static subtractionDoesUnderflow(a, b) {
            const c = a - b;
            return a !== c + b || b !== a - c;
        }
        static compare(t1, t2) {
            if (t1._ticks > t2._ticks) {
                return 1;
            }
            if (t1._ticks < t2._ticks) {
                return -1;
            }
            return 0;
        }
        static interval(value, scale) {
            if (isNaN(value)) {
                throw new Error("value must be a number");
            }
            const milliseconds = value * scale;
            if (milliseconds > maxMilliSeconds || milliseconds < minMilliSeconds) {
                throw new Error("timespan too long");
            }
            return TimeSpan.fromTicks(Math.floor(milliseconds * ticksPerMillisecond));
        }
        static fromMilliseconds(value) {
            return TimeSpan.interval(value, 1);
        }
        static fromSeconds(value) {
            return TimeSpan.interval(value, millisPerSecond);
        }
        static fromMinutes(value) {
            return TimeSpan.interval(value, millisPerMinute);
        }
        static fromHours(value) {
            return TimeSpan.interval(value, millisPerHour);
        }
        static fromDays(value) {
            return TimeSpan.interval(value, millisPerDay);
        }
    }
    TimeSpan.zero = new TimeSpan(0, 0, 0, 0, 0);
    TimeSpan.maxValue = TimeSpan.fromTicks(Number.MAX_SAFE_INTEGER);
    TimeSpan.minValue = TimeSpan.fromTicks(Number.MIN_SAFE_INTEGER);

    // Copyright (c) Microsoft Corporation.
    /**
     * @ignore
     * @param delimitedString
     */
    function parseDelimitedString(delimitedString) {
        if (delimitedString == null) {
            throw new Error("delimitedString is null or undefined");
        }
        const metrics = {};
        const headerAttributes = delimitedString.split(";");
        for (const attribute of headerAttributes) {
            const attributeKeyValue = attribute.split("=");
            if (attributeKeyValue.length !== 2) {
                throw new Error("recieved a malformed delimited string");
            }
            const attributeKey = attributeKeyValue[0];
            const attributeValue = parseFloat(attributeKeyValue[1]);
            metrics[attributeKey] = attributeValue;
        }
        return metrics;
    }
    /**
     * @ignore
     * @param metrics
     * @param key
     */
    function timeSpanFromMetrics(metrics /* TODO: any */, key) {
        if (key in metrics) {
            return TimeSpan.fromMilliseconds(metrics[key]);
        }
        return TimeSpan.zero;
    }

    // Copyright (c) Microsoft Corporation.
    class QueryPreparationTimes {
        constructor(queryCompilationTime, logicalPlanBuildTime, physicalPlanBuildTime, queryOptimizationTime) {
            this.queryCompilationTime = queryCompilationTime;
            this.logicalPlanBuildTime = logicalPlanBuildTime;
            this.physicalPlanBuildTime = physicalPlanBuildTime;
            this.queryOptimizationTime = queryOptimizationTime;
        }
        /**
         * returns a new QueryPreparationTimes instance that is the addition of this and the arguments.
         */
        add(...queryPreparationTimesArray) {
            let queryCompilationTime = this.queryCompilationTime;
            let logicalPlanBuildTime = this.logicalPlanBuildTime;
            let physicalPlanBuildTime = this.physicalPlanBuildTime;
            let queryOptimizationTime = this.queryOptimizationTime;
            for (const queryPreparationTimes of queryPreparationTimesArray) {
                if (queryPreparationTimes == null) {
                    throw new Error("queryPreparationTimesArray has null or undefined item(s)");
                }
                queryCompilationTime = queryCompilationTime.add(queryPreparationTimes.queryCompilationTime);
                logicalPlanBuildTime = logicalPlanBuildTime.add(queryPreparationTimes.logicalPlanBuildTime);
                physicalPlanBuildTime = physicalPlanBuildTime.add(queryPreparationTimes.physicalPlanBuildTime);
                queryOptimizationTime = queryOptimizationTime.add(queryPreparationTimes.queryOptimizationTime);
            }
            return new QueryPreparationTimes(queryCompilationTime, logicalPlanBuildTime, physicalPlanBuildTime, queryOptimizationTime);
        }
        /**
         * Output the QueryPreparationTimes as a delimited string.
         */
        toDelimitedString() {
            return (`${QueryMetricsConstants.QueryCompileTimeInMs}=${this.queryCompilationTime.totalMilliseconds()};` +
                `${QueryMetricsConstants.LogicalPlanBuildTimeInMs}=${this.logicalPlanBuildTime.totalMilliseconds()};` +
                `${QueryMetricsConstants.PhysicalPlanBuildTimeInMs}=${this.physicalPlanBuildTime.totalMilliseconds()};` +
                `${QueryMetricsConstants.QueryOptimizationTimeInMs}=${this.queryOptimizationTime.totalMilliseconds()}`);
        }
        /**
         * Returns a new instance of the QueryPreparationTimes class that is the
         * aggregation of an array of QueryPreparationTimes.
         * @memberof QueryMetrics
         * @instance
         */
        static createFromArray(queryPreparationTimesArray) {
            if (queryPreparationTimesArray == null) {
                throw new Error("queryPreparationTimesArray is null or undefined item(s)");
            }
            return QueryPreparationTimes.zero.add(...queryPreparationTimesArray);
        }
        /**
         * Returns a new instance of the QueryPreparationTimes class this is deserialized from a delimited string.
         * @memberof QueryMetrics
         * @instance
         */
        static createFromDelimitedString(delimitedString) {
            const metrics = parseDelimitedString(delimitedString);
            return new QueryPreparationTimes(timeSpanFromMetrics(metrics, QueryMetricsConstants.QueryCompileTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.LogicalPlanBuildTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.PhysicalPlanBuildTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.QueryOptimizationTimeInMs));
        }
    }
    QueryPreparationTimes.zero = new QueryPreparationTimes(TimeSpan.zero, TimeSpan.zero, TimeSpan.zero, TimeSpan.zero);

    // Copyright (c) Microsoft Corporation.
    class RuntimeExecutionTimes {
        constructor(queryEngineExecutionTime, systemFunctionExecutionTime, userDefinedFunctionExecutionTime) {
            this.queryEngineExecutionTime = queryEngineExecutionTime;
            this.systemFunctionExecutionTime = systemFunctionExecutionTime;
            this.userDefinedFunctionExecutionTime = userDefinedFunctionExecutionTime;
        }
        /**
         * returns a new RuntimeExecutionTimes instance that is the addition of this and the arguments.
         */
        add(...runtimeExecutionTimesArray) {
            let queryEngineExecutionTime = this.queryEngineExecutionTime;
            let systemFunctionExecutionTime = this.systemFunctionExecutionTime;
            let userDefinedFunctionExecutionTime = this.userDefinedFunctionExecutionTime;
            for (const runtimeExecutionTimes of runtimeExecutionTimesArray) {
                if (runtimeExecutionTimes == null) {
                    throw new Error("runtimeExecutionTimes has null or undefined item(s)");
                }
                queryEngineExecutionTime = queryEngineExecutionTime.add(runtimeExecutionTimes.queryEngineExecutionTime);
                systemFunctionExecutionTime = systemFunctionExecutionTime.add(runtimeExecutionTimes.systemFunctionExecutionTime);
                userDefinedFunctionExecutionTime = userDefinedFunctionExecutionTime.add(runtimeExecutionTimes.userDefinedFunctionExecutionTime);
            }
            return new RuntimeExecutionTimes(queryEngineExecutionTime, systemFunctionExecutionTime, userDefinedFunctionExecutionTime);
        }
        /**
         * Output the RuntimeExecutionTimes as a delimited string.
         */
        toDelimitedString() {
            // tslint:disable-next-line:max-line-length
            return (`${QueryMetricsConstants.SystemFunctionExecuteTimeInMs}=${this.systemFunctionExecutionTime.totalMilliseconds()};` +
                // tslint:disable-next-line:max-line-length
                `${QueryMetricsConstants.UserDefinedFunctionExecutionTimeInMs}=${this.userDefinedFunctionExecutionTime.totalMilliseconds()}`);
        }
        /**
         * Returns a new instance of the RuntimeExecutionTimes class that is
         *  the aggregation of an array of RuntimeExecutionTimes.
         */
        static createFromArray(runtimeExecutionTimesArray) {
            if (runtimeExecutionTimesArray == null) {
                throw new Error("runtimeExecutionTimesArray is null or undefined item(s)");
            }
            return RuntimeExecutionTimes.zero.add(...runtimeExecutionTimesArray);
        }
        /**
         * Returns a new instance of the RuntimeExecutionTimes class this is deserialized from a delimited string.
         */
        static createFromDelimitedString(delimitedString) {
            const metrics = parseDelimitedString(delimitedString);
            const vmExecutionTime = timeSpanFromMetrics(metrics, QueryMetricsConstants.VMExecutionTimeInMs);
            const indexLookupTime = timeSpanFromMetrics(metrics, QueryMetricsConstants.IndexLookupTimeInMs);
            const documentLoadTime = timeSpanFromMetrics(metrics, QueryMetricsConstants.DocumentLoadTimeInMs);
            const documentWriteTime = timeSpanFromMetrics(metrics, QueryMetricsConstants.DocumentWriteTimeInMs);
            let queryEngineExecutionTime = TimeSpan.zero;
            queryEngineExecutionTime = queryEngineExecutionTime.add(vmExecutionTime);
            queryEngineExecutionTime = queryEngineExecutionTime.subtract(indexLookupTime);
            queryEngineExecutionTime = queryEngineExecutionTime.subtract(documentLoadTime);
            queryEngineExecutionTime = queryEngineExecutionTime.subtract(documentWriteTime);
            return new RuntimeExecutionTimes(queryEngineExecutionTime, timeSpanFromMetrics(metrics, QueryMetricsConstants.SystemFunctionExecuteTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.UserDefinedFunctionExecutionTimeInMs));
        }
    }
    RuntimeExecutionTimes.zero = new RuntimeExecutionTimes(TimeSpan.zero, TimeSpan.zero, TimeSpan.zero);

    // Copyright (c) Microsoft Corporation.
    class QueryMetrics {
        constructor(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitDocumentCount, totalQueryExecutionTime, queryPreparationTimes, indexLookupTime, documentLoadTime, vmExecutionTime, runtimeExecutionTimes, documentWriteTime, clientSideMetrics) {
            this.retrievedDocumentCount = retrievedDocumentCount;
            this.retrievedDocumentSize = retrievedDocumentSize;
            this.outputDocumentCount = outputDocumentCount;
            this.outputDocumentSize = outputDocumentSize;
            this.indexHitDocumentCount = indexHitDocumentCount;
            this.totalQueryExecutionTime = totalQueryExecutionTime;
            this.queryPreparationTimes = queryPreparationTimes;
            this.indexLookupTime = indexLookupTime;
            this.documentLoadTime = documentLoadTime;
            this.vmExecutionTime = vmExecutionTime;
            this.runtimeExecutionTimes = runtimeExecutionTimes;
            this.documentWriteTime = documentWriteTime;
            this.clientSideMetrics = clientSideMetrics;
        }
        /**
         * Gets the IndexHitRatio
         * @memberof QueryMetrics
         * @instance
         * @ignore
         */
        get indexHitRatio() {
            return this.retrievedDocumentCount === 0
                ? 1
                : this.indexHitDocumentCount / this.retrievedDocumentCount;
        }
        /**
         * returns a new QueryMetrics instance that is the addition of this and the arguments.
         */
        add(queryMetricsArray) {
            let retrievedDocumentCount = 0;
            let retrievedDocumentSize = 0;
            let outputDocumentCount = 0;
            let outputDocumentSize = 0;
            let indexHitDocumentCount = 0;
            let totalQueryExecutionTime = TimeSpan.zero;
            const queryPreparationTimesArray = [];
            let indexLookupTime = TimeSpan.zero;
            let documentLoadTime = TimeSpan.zero;
            let vmExecutionTime = TimeSpan.zero;
            const runtimeExecutionTimesArray = [];
            let documentWriteTime = TimeSpan.zero;
            const clientSideQueryMetricsArray = [];
            queryMetricsArray.push(this);
            for (const queryMetrics of queryMetricsArray) {
                if (queryMetrics) {
                    retrievedDocumentCount += queryMetrics.retrievedDocumentCount;
                    retrievedDocumentSize += queryMetrics.retrievedDocumentSize;
                    outputDocumentCount += queryMetrics.outputDocumentCount;
                    outputDocumentSize += queryMetrics.outputDocumentSize;
                    indexHitDocumentCount += queryMetrics.indexHitDocumentCount;
                    totalQueryExecutionTime = totalQueryExecutionTime.add(queryMetrics.totalQueryExecutionTime);
                    queryPreparationTimesArray.push(queryMetrics.queryPreparationTimes);
                    indexLookupTime = indexLookupTime.add(queryMetrics.indexLookupTime);
                    documentLoadTime = documentLoadTime.add(queryMetrics.documentLoadTime);
                    vmExecutionTime = vmExecutionTime.add(queryMetrics.vmExecutionTime);
                    runtimeExecutionTimesArray.push(queryMetrics.runtimeExecutionTimes);
                    documentWriteTime = documentWriteTime.add(queryMetrics.documentWriteTime);
                    clientSideQueryMetricsArray.push(queryMetrics.clientSideMetrics);
                }
            }
            return new QueryMetrics(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitDocumentCount, totalQueryExecutionTime, QueryPreparationTimes.createFromArray(queryPreparationTimesArray), indexLookupTime, documentLoadTime, vmExecutionTime, RuntimeExecutionTimes.createFromArray(runtimeExecutionTimesArray), documentWriteTime, ClientSideMetrics.createFromArray(...clientSideQueryMetricsArray));
        }
        /**
         * Output the QueryMetrics as a delimited string.
         * @memberof QueryMetrics
         * @instance
         * @ignore
         */
        toDelimitedString() {
            return (QueryMetricsConstants.RetrievedDocumentCount +
                "=" +
                this.retrievedDocumentCount +
                ";" +
                QueryMetricsConstants.RetrievedDocumentSize +
                "=" +
                this.retrievedDocumentSize +
                ";" +
                QueryMetricsConstants.OutputDocumentCount +
                "=" +
                this.outputDocumentCount +
                ";" +
                QueryMetricsConstants.OutputDocumentSize +
                "=" +
                this.outputDocumentSize +
                ";" +
                QueryMetricsConstants.IndexHitRatio +
                "=" +
                this.indexHitRatio +
                ";" +
                QueryMetricsConstants.TotalQueryExecutionTimeInMs +
                "=" +
                this.totalQueryExecutionTime.totalMilliseconds() +
                ";" +
                this.queryPreparationTimes.toDelimitedString() +
                ";" +
                QueryMetricsConstants.IndexLookupTimeInMs +
                "=" +
                this.indexLookupTime.totalMilliseconds() +
                ";" +
                QueryMetricsConstants.DocumentLoadTimeInMs +
                "=" +
                this.documentLoadTime.totalMilliseconds() +
                ";" +
                QueryMetricsConstants.VMExecutionTimeInMs +
                "=" +
                this.vmExecutionTime.totalMilliseconds() +
                ";" +
                this.runtimeExecutionTimes.toDelimitedString() +
                ";" +
                QueryMetricsConstants.DocumentWriteTimeInMs +
                "=" +
                this.documentWriteTime.totalMilliseconds());
        }
        /**
         * Returns a new instance of the QueryMetrics class that is the aggregation of an array of query metrics.
         * @memberof QueryMetrics
         * @instance
         */
        static createFromArray(queryMetricsArray) {
            if (!queryMetricsArray) {
                throw new Error("queryMetricsArray is null or undefined item(s)");
            }
            return QueryMetrics.zero.add(queryMetricsArray);
        }
        /**
         * Returns a new instance of the QueryMetrics class this is deserialized from a delimited string.
         * @memberof QueryMetrics
         * @instance
         */
        static createFromDelimitedString(delimitedString, clientSideMetrics) {
            const metrics = parseDelimitedString(delimitedString);
            const indexHitRatio = metrics[QueryMetricsConstants.IndexHitRatio] || 0;
            const retrievedDocumentCount = metrics[QueryMetricsConstants.RetrievedDocumentCount] || 0;
            const indexHitCount = indexHitRatio * retrievedDocumentCount;
            const outputDocumentCount = metrics[QueryMetricsConstants.OutputDocumentCount] || 0;
            const outputDocumentSize = metrics[QueryMetricsConstants.OutputDocumentSize] || 0;
            const retrievedDocumentSize = metrics[QueryMetricsConstants.RetrievedDocumentSize] || 0;
            const totalQueryExecutionTime = timeSpanFromMetrics(metrics, QueryMetricsConstants.TotalQueryExecutionTimeInMs);
            return new QueryMetrics(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitCount, totalQueryExecutionTime, QueryPreparationTimes.createFromDelimitedString(delimitedString), timeSpanFromMetrics(metrics, QueryMetricsConstants.IndexLookupTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.DocumentLoadTimeInMs), timeSpanFromMetrics(metrics, QueryMetricsConstants.VMExecutionTimeInMs), RuntimeExecutionTimes.createFromDelimitedString(delimitedString), timeSpanFromMetrics(metrics, QueryMetricsConstants.DocumentWriteTimeInMs), clientSideMetrics || ClientSideMetrics.zero);
        }
    }
    QueryMetrics.zero = new QueryMetrics(0, 0, 0, 0, 0, TimeSpan.zero, QueryPreparationTimes.zero, TimeSpan.zero, TimeSpan.zero, TimeSpan.zero, RuntimeExecutionTimes.zero, TimeSpan.zero, ClientSideMetrics.zero);

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    // TODO: docs
    function getRequestChargeIfAny(headers) {
        if (typeof headers === "number") {
            return headers;
        }
        else if (typeof headers === "string") {
            return parseFloat(headers);
        }
        if (headers) {
            const rc = headers[Constants.HttpHeaders.RequestCharge];
            if (rc) {
                return parseFloat(rc);
            }
            else {
                return 0;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * @ignore
     */
    function getInitialHeader() {
        const headers = {};
        headers[Constants.HttpHeaders.RequestCharge] = 0;
        headers[Constants.HttpHeaders.QueryMetrics] = {};
        return headers;
    }
    /**
     * @ignore
     * @param headers
     * @param toBeMergedHeaders
     */
    // TODO: The name of this method isn't very accurate to what it does
    function mergeHeaders(headers, toBeMergedHeaders) {
        if (headers[Constants.HttpHeaders.RequestCharge] === undefined) {
            headers[Constants.HttpHeaders.RequestCharge] = 0;
        }
        if (headers[Constants.HttpHeaders.QueryMetrics] === undefined) {
            headers[Constants.HttpHeaders.QueryMetrics] = QueryMetrics.zero;
        }
        if (!toBeMergedHeaders) {
            return;
        }
        headers[Constants.HttpHeaders.RequestCharge] += getRequestChargeIfAny(toBeMergedHeaders);
        if (toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed]) {
            headers[Constants.HttpHeaders.IsRUPerMinuteUsed] =
                toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed];
        }
        if (Constants.HttpHeaders.QueryMetrics in toBeMergedHeaders) {
            const headerQueryMetrics = headers[Constants.HttpHeaders.QueryMetrics];
            const toBeMergedHeaderQueryMetrics = toBeMergedHeaders[Constants.HttpHeaders.QueryMetrics];
            for (const partitionId in toBeMergedHeaderQueryMetrics) {
                if (partitionId in headerQueryMetrics) {
                    const combinedQueryMetrics = headerQueryMetrics[partitionId].add([
                        toBeMergedHeaderQueryMetrics[partitionId]
                    ]);
                    headerQueryMetrics[partitionId] = combinedQueryMetrics;
                }
                else {
                    headerQueryMetrics[partitionId] = toBeMergedHeaderQueryMetrics[partitionId];
                }
            }
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    let cosmosLevelFilter = "warn|error";
    if (typeof process !== "undefined" && process.env && process.env.COSMOS_LOG_LEVEL) {
        cosmosLevelFilter = process.env.COSMOS_LOG_LEVEL;
    }
    /** @hidden */
    const cosmosDebug = debugLib("cosmos");
    /** @hidden */
    const levelLogger = (namespaceLogger, level) => {
        return (message) => {
            if (cosmosLevelFilter.includes(level)) {
                namespaceLogger("[" + new Date().toISOString() + "][" + level + "]: %o", message);
            }
        };
    };
    /** @hidden */
    const logger = (namespace) => {
        const namespaceLogger = cosmosDebug.extend(namespace);
        return {
            silly: levelLogger(namespaceLogger, "silly"),
            debug: levelLogger(namespaceLogger, "debug"),
            info: levelLogger(namespaceLogger, "info"),
            warn: levelLogger(namespaceLogger, "warn"),
            error: levelLogger(namespaceLogger, "error")
        };
    };

    /** @hidden */
    const log = logger("defaultQueryExecutionContext");
    /** @hidden */
    var STATES;
    (function (STATES) {
        STATES["start"] = "start";
        STATES["inProgress"] = "inProgress";
        STATES["ended"] = "ended";
    })(STATES || (STATES = {}));
    /** @hidden */
    class DefaultQueryExecutionContext {
        /**
         * Provides the basic Query Execution Context.
         * This wraps the internal logic query execution using provided fetch functions
         * @constructor DefaultQueryExecutionContext
         * @param {ClientContext} clientContext          - Is used to read the partitionKeyRanges for split proofing
         * @param {SqlQuerySpec | string} query          - A SQL query.
         * @param {FeedOptions} [options]                - Represents the feed options.
         * @param {callback | callback[]} fetchFunctions - A function to retrieve each page of data.
         *                          An array of functions may be used to query more than one partition.
         * @ignore
         */
        constructor(options, fetchFunctions) {
            // TODO: any options
            this.resources = [];
            this.currentIndex = 0;
            this.currentPartitionIndex = 0;
            this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];
            this.options = options || {};
            this.continuationToken = this.options.continuationToken || this.options.continuation || null;
            this.state = DefaultQueryExecutionContext.STATES.start;
        }
        get continuation() {
            return this.continuationToken;
        }
        /**
         * Execute a provided callback on the next element in the execution context.
         * @memberof DefaultQueryExecutionContext
         * @instance
         */
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                ++this.currentIndex;
                const response = yield this.current();
                return response;
            });
        }
        /**
         * Retrieve the current element on the execution context.
         * @memberof DefaultQueryExecutionContext
         * @instance
         */
        current() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.currentIndex < this.resources.length) {
                    return {
                        result: this.resources[this.currentIndex],
                        headers: getInitialHeader()
                    };
                }
                if (this._canFetchMore()) {
                    const { result: resources, headers } = yield this.fetchMore();
                    this.resources = resources;
                    if (this.resources.length === 0) {
                        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {
                            this.state = DefaultQueryExecutionContext.STATES.ended;
                            return { result: undefined, headers };
                        }
                        else {
                            return this.current();
                        }
                    }
                    return { result: this.resources[this.currentIndex], headers };
                }
                else {
                    this.state = DefaultQueryExecutionContext.STATES.ended;
                    return { result: undefined, headers: getInitialHeader() };
                }
            });
        }
        /**
         * Determine if there are still remaining resources to processs based on
         * the value of the continuation token or the elements remaining on the current batch in the execution context.
         * @memberof DefaultQueryExecutionContext
         * @instance
         * @returns {Boolean} true if there is other elements to process in the DefaultQueryExecutionContext.
         */
        hasMoreResults() {
            return (this.state === DefaultQueryExecutionContext.STATES.start ||
                this.continuationToken !== undefined ||
                this.currentIndex < this.resources.length - 1 ||
                this.currentPartitionIndex < this.fetchFunctions.length);
        }
        /**
         * Fetches the next batch of the feed and pass them as an array to a callback
         * @memberof DefaultQueryExecutionContext
         * @instance
         */
        /**
         * Fetches the next batch of the feed and pass them as an array to a callback
         * @memberof DefaultQueryExecutionContext
         * @instance
         */
        fetchMore() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.currentPartitionIndex >= this.fetchFunctions.length) {
                    return { headers: getInitialHeader(), result: undefined };
                }
                // Keep to the original continuation and to restore the value after fetchFunction call
                const originalContinuation = this.options.continuationToken || this.options.continuation;
                this.options.continuationToken = this.continuationToken;
                // Return undefined if there is no more results
                if (this.currentPartitionIndex >= this.fetchFunctions.length) {
                    return { headers: getInitialHeader(), result: undefined };
                }
                let resources;
                let responseHeaders;
                try {
                    let p;
                    if (this.nextFetchFunction !== undefined) {
                        log.debug("using prefetch");
                        p = this.nextFetchFunction;
                        this.nextFetchFunction = undefined;
                    }
                    else {
                        log.debug("using fresh fetch");
                        p = this.fetchFunctions[this.currentPartitionIndex](this.options);
                    }
                    const response = yield p;
                    resources = response.result;
                    responseHeaders = response.headers;
                    this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];
                    if (!this.continuationToken) {
                        ++this.currentPartitionIndex;
                    }
                    if (this.options && this.options.bufferItems === true) {
                        const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];
                        this.nextFetchFunction = fetchFunction
                            ? fetchFunction(Object.assign(Object.assign({}, this.options), { continuationToken: this.continuationToken }))
                            : undefined;
                    }
                }
                catch (err) {
                    this.state = DefaultQueryExecutionContext.STATES.ended;
                    // return callback(err, undefined, responseHeaders);
                    // TODO: Error and data being returned is an antipattern, this might broken
                    throw err;
                }
                this.state = DefaultQueryExecutionContext.STATES.inProgress;
                this.currentIndex = 0;
                this.options.continuationToken = originalContinuation;
                this.options.continuation = originalContinuation;
                // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base
                if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {
                    const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];
                    let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);
                    // Add the request charge to the query metrics so that we can have per partition request charge.
                    if (Constants.HttpHeaders.RequestCharge in responseHeaders) {
                        const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;
                        queryMetrics = new QueryMetrics(queryMetrics.retrievedDocumentCount, queryMetrics.retrievedDocumentSize, queryMetrics.outputDocumentCount, queryMetrics.outputDocumentSize, queryMetrics.indexHitDocumentCount, queryMetrics.totalQueryExecutionTime, queryMetrics.queryPreparationTimes, queryMetrics.indexLookupTime, queryMetrics.documentLoadTime, queryMetrics.vmExecutionTime, queryMetrics.runtimeExecutionTimes, queryMetrics.documentWriteTime, new ClientSideMetrics(requestCharge));
                    }
                    // Wraping query metrics in a object where the key is '0' just so single partition
                    // and partition queries have the same response schema
                    responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};
                    responseHeaders[Constants.HttpHeaders.QueryMetrics]["0"] = queryMetrics;
                }
                return { result: resources, headers: responseHeaders };
            });
        }
        _canFetchMore() {
            const res = this.state === DefaultQueryExecutionContext.STATES.start ||
                (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||
                (this.currentPartitionIndex < this.fetchFunctions.length &&
                    this.state === DefaultQueryExecutionContext.STATES.inProgress);
            return res;
        }
    }
    DefaultQueryExecutionContext.STATES = STATES;

    /** @hidden */
    class AverageAggregator {
        /**
         * Add the provided item to aggregation result.
         * @memberof AverageAggregator
         * @instance
         * @param other
         */
        aggregate(other) {
            if (other == null || other.sum == null) {
                return;
            }
            if (this.sum == null) {
                this.sum = 0.0;
                this.count = 0;
            }
            this.sum += other.sum;
            this.count += other.count;
        }
        /**
         * Get the aggregation result.
         * @memberof AverageAggregator
         * @instance
         */
        getResult() {
            if (this.sum == null || this.count <= 0) {
                return undefined;
            }
            return this.sum / this.count;
        }
    }

    /** @hidden */
    class CountAggregator {
        /**
         * Represents an aggregator for COUNT operator.
         * @constructor CountAggregator
         * @ignore
         */
        constructor() {
            this.value = 0;
        }
        /**
         * Add the provided item to aggregation result.
         * @memberof CountAggregator
         * @instance
         * @param other
         */
        aggregate(other) {
            this.value += other;
        }
        /**
         * Get the aggregation result.
         * @memberof CountAggregator
         * @instance
         */
        getResult() {
            return this.value;
        }
    }

    // TODO: this smells funny
    /** @hidden */
    const TYPEORDCOMPARATOR = Object.freeze({
        NoValue: {
            ord: 0
        },
        undefined: {
            ord: 1
        },
        boolean: {
            ord: 2,
            compFunc: (a, b) => {
                return a === b ? 0 : a > b ? 1 : -1;
            }
        },
        number: {
            ord: 4,
            compFunc: (a, b) => {
                return a === b ? 0 : a > b ? 1 : -1;
            }
        },
        string: {
            ord: 5,
            compFunc: (a, b) => {
                return a === b ? 0 : a > b ? 1 : -1;
            }
        }
    });
    /** @hidden */
    class OrderByDocumentProducerComparator {
        constructor(sortOrder) {
            this.sortOrder = sortOrder;
        } // TODO: This should be an enum
        targetPartitionKeyRangeDocProdComparator(docProd1, docProd2) {
            const a = docProd1.getTargetParitionKeyRange()["minInclusive"];
            const b = docProd2.getTargetParitionKeyRange()["minInclusive"];
            return a === b ? 0 : a > b ? 1 : -1;
        }
        compare(docProd1, docProd2) {
            // Need to check for split, since we don't want to dereference "item" of undefined / exception
            if (docProd1.gotSplit()) {
                return -1;
            }
            if (docProd2.gotSplit()) {
                return 1;
            }
            const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);
            const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);
            // validate order by items and types
            // TODO: once V1 order by on different types is fixed this need to change
            this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);
            // no async call in the for loop
            for (let i = 0; i < orderByItemsRes1.length; i++) {
                // compares the orderby items one by one
                const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);
                if (compRes !== 0) {
                    if (this.sortOrder[i] === "Ascending") {
                        return compRes;
                    }
                    else if (this.sortOrder[i] === "Descending") {
                        return -compRes;
                    }
                }
            }
            return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);
        }
        // TODO: This smells funny
        compareValue(item1, type1, item2, type2) {
            if (type1 === "object" || type2 === "object") {
                throw new Error("Tried to compare an object type");
            }
            const type1Ord = TYPEORDCOMPARATOR[type1].ord;
            const type2Ord = TYPEORDCOMPARATOR[type2].ord;
            const typeCmp = type1Ord - type2Ord;
            if (typeCmp !== 0) {
                // if the types are different, use type ordinal
                return typeCmp;
            }
            // both are of the same type
            if (type1Ord === TYPEORDCOMPARATOR["undefined"].ord ||
                type1Ord === TYPEORDCOMPARATOR["NoValue"].ord) {
                // if both types are undefined or Null they are equal
                return 0;
            }
            const compFunc = TYPEORDCOMPARATOR[type1].compFunc;
            if (typeof compFunc === "undefined") {
                throw new Error("Cannot find the comparison function");
            }
            // same type and type is defined compare the items
            return compFunc(item1, item2);
        }
        compareOrderByItem(orderByItem1, orderByItem2) {
            const type1 = this.getType(orderByItem1);
            const type2 = this.getType(orderByItem2);
            return this.compareValue(orderByItem1["item"], type1, orderByItem2["item"], type2);
        }
        validateOrderByItems(res1, res2) {
            if (res1.length !== res2.length) {
                throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);
            }
            if (res1.length !== this.sortOrder.length) {
                throw new Error("orderByItems cannot have a different size than sort orders.");
            }
            for (let i = 0; i < this.sortOrder.length; i++) {
                const type1 = this.getType(res1[i]);
                const type2 = this.getType(res2[i]);
                if (type1 !== type2) {
                    throw new Error(`Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`);
                }
            }
        }
        getType(orderByItem) {
            // TODO: any item?
            if (orderByItem === undefined || orderByItem.item === undefined) {
                return "NoValue";
            }
            const type = typeof orderByItem.item;
            if (TYPEORDCOMPARATOR[type] === undefined) {
                throw new Error(`unrecognizable type ${type}`);
            }
            return type;
        }
        getOrderByItems(res) {
            // TODO: any res?
            return res["orderByItems"];
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    class MaxAggregator {
        /**
         * Represents an aggregator for MAX operator.
         * @constructor MaxAggregator
         * @ignore
         */
        constructor() {
            this.value = undefined;
            this.comparer = new OrderByDocumentProducerComparator(["Ascending"]);
        }
        /**
         * Add the provided item to aggregation result.
         * @memberof MaxAggregator
         * @instance
         * @param other
         */
        aggregate(other) {
            if (this.value === undefined) {
                this.value = other.max;
            }
            else if (this.comparer.compareValue(other.max, typeof other.max, this.value, typeof this.value) > 0) {
                this.value = other.max;
            }
        }
        /**
         * Get the aggregation result.
         * @memberof MaxAggregator
         * @instance
         */
        getResult() {
            return this.value;
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    class MinAggregator {
        /**
         * Represents an aggregator for MIN operator.
         * @constructor MinAggregator
         * @ignore
         */
        constructor() {
            this.value = undefined;
            this.comparer = new OrderByDocumentProducerComparator(["Ascending"]);
        }
        /**
         * Add the provided item to aggregation result.
         * @memberof MinAggregator
         * @instance
         * @param other
         */
        aggregate(other) {
            if (this.value === undefined) {
                // || typeof this.value === "object"
                this.value = other.min;
            }
            else {
                const otherType = other.min === null ? "NoValue" : typeof other.min; // || typeof other === "object"
                const thisType = this.value === null ? "NoValue" : typeof this.value;
                if (this.comparer.compareValue(other.min, otherType, this.value, thisType) < 0) {
                    this.value = other.min;
                }
            }
        }
        /**
         * Get the aggregation result.
         * @memberof MinAggregator
         * @instance
         */
        getResult() {
            return this.value;
        }
    }

    /** @hidden */
    class SumAggregator {
        /**
         * Add the provided item to aggregation result.
         * @memberof SumAggregator
         * @instance
         * @param other
         */
        aggregate(other) {
            if (other === undefined) {
                return;
            }
            if (this.sum === undefined) {
                this.sum = other;
            }
            else {
                this.sum += other;
            }
        }
        /**
         * Get the aggregation result.
         * @memberof SumAggregator
         * @instance
         */
        getResult() {
            return this.sum;
        }
    }

    /** @hidden */
    class StaticValueAggregator {
        aggregate(other) {
            if (this.value === undefined) {
                this.value = other;
            }
        }
        getResult() {
            return this.value;
        }
    }

    // Copyright (c) Microsoft Corporation.
    function createAggregator(aggregateType) {
        switch (aggregateType) {
            case "Average":
                return new AverageAggregator();
            case "Count":
                return new CountAggregator();
            case "Max":
                return new MaxAggregator();
            case "Min":
                return new MinAggregator();
            case "Sum":
                return new SumAggregator();
            default:
                return new StaticValueAggregator();
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /** @hidden */
    var FetchResultType;
    (function (FetchResultType) {
        FetchResultType[FetchResultType["Done"] = 0] = "Done";
        FetchResultType[FetchResultType["Exception"] = 1] = "Exception";
        FetchResultType[FetchResultType["Result"] = 2] = "Result";
    })(FetchResultType || (FetchResultType = {}));
    /** @hidden */
    class FetchResult {
        /**
         * Wraps fetch results for the document producer.
         * This allows the document producer to buffer exceptions so that actual results don't get flushed during splits.
         * @constructor DocumentProducer
         * @param {object} feedReponse                  - The response the document producer got back on a successful fetch
         * @param {object} error                        - The exception meant to be buffered on an unsuccessful fetch
         * @ignore
         */
        constructor(feedResponse, error) {
            // TODO: feedResponse/error
            if (feedResponse) {
                this.feedResponse = feedResponse;
                this.fetchResultType = FetchResultType.Result;
            }
            else {
                this.error = error;
                this.fetchResultType = FetchResultType.Exception;
            }
        }
    }

    /** @hidden */
    class DocumentProducer {
        /**
         * Provides the Target Partition Range Query Execution Context.
         * @constructor DocumentProducer
         * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
         * @param {String} collectionLink                - Represents collection link
         * @param {SqlQuerySpec | string} query          - A SQL query.
         * @param {object} targetPartitionKeyRange       - Query Target Partition key Range
         * @ignore
         */
        constructor(clientContext, collectionLink, query, targetPartitionKeyRange, // TODO: any partition key range
        options) {
            this.clientContext = clientContext;
            this.generation = 0;
            this.fetchFunction = (options) => tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.collectionLink, ResourceType.item);
                const id = getIdFromLink(this.collectionLink);
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    resultFn: (result) => result.Documents,
                    query: this.query,
                    options,
                    partitionKeyRangeId: this.targetPartitionKeyRange["id"]
                });
            });
            // TODO: any options
            this.collectionLink = collectionLink;
            this.query = query;
            this.targetPartitionKeyRange = targetPartitionKeyRange;
            this.fetchResults = [];
            this.allFetched = false;
            this.err = undefined;
            this.previousContinuationToken = undefined;
            this.continuationToken = undefined;
            this.respHeaders = getInitialHeader();
            // tslint:disable-next-line:no-shadowed-variable
            this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction);
        }
        /**
         * Synchronously gives the contiguous buffered results (stops at the first non result) if any
         * @returns {Object}       - buffered current items if any
         * @ignore
         */
        peekBufferedItems() {
            const bufferedResults = [];
            for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {
                const fetchResult = this.fetchResults[i];
                switch (fetchResult.fetchResultType) {
                    case FetchResultType.Done:
                        done = true;
                        break;
                    case FetchResultType.Exception:
                        done = true;
                        break;
                    case FetchResultType.Result:
                        bufferedResults.push(fetchResult.feedResponse);
                        break;
                }
            }
            return bufferedResults;
        }
        hasMoreResults() {
            return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;
        }
        gotSplit() {
            const fetchResult = this.fetchResults[0];
            if (fetchResult.fetchResultType === FetchResultType.Exception) {
                if (DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {
                    return true;
                }
            }
            return false;
        }
        _getAndResetActiveResponseHeaders() {
            const ret = this.respHeaders;
            this.respHeaders = getInitialHeader();
            return ret;
        }
        _updateStates(err, allFetched) {
            // TODO: any Error
            if (err) {
                this.err = err;
                return;
            }
            if (allFetched) {
                this.allFetched = true;
            }
            if (this.internalExecutionContext.continuationToken === this.continuationToken) {
                // nothing changed
                return;
            }
            this.previousContinuationToken = this.continuationToken;
            this.continuationToken = this.internalExecutionContext.continuationToken;
        }
        static _needPartitionKeyRangeCacheRefresh(error) {
            // TODO: error
            return (error.code === StatusCodes.Gone &&
                "substatus" in error &&
                error["substatus"] === SubStatusCodes.PartitionKeyRangeGone);
        }
        /**
         * Fetches and bufferes the next page of results and executes the given callback
         * @memberof DocumentProducer
         * @instance
         */
        bufferMore() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.err) {
                    throw this.err;
                }
                try {
                    const { result: resources, headers: headerResponse } = yield this.internalExecutionContext.fetchMore();
                    ++this.generation;
                    this._updateStates(undefined, resources === undefined);
                    if (resources !== undefined) {
                        // some more results
                        resources.forEach((element) => {
                            // TODO: resources any
                            this.fetchResults.push(new FetchResult(element, undefined));
                        });
                    }
                    // need to modify the header response so that the query metrics are per partition
                    if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {
                        // "0" is the default partition before one is actually assigned.
                        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics]["0"];
                        // Wraping query metrics in a object where the keys are the partition key range.
                        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};
                        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;
                    }
                    return { result: resources, headers: headerResponse };
                }
                catch (err) {
                    // TODO: any error
                    if (DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {
                        // Split just happend
                        // Buffer the error so the execution context can still get the feedResponses in the itemBuffer
                        const bufferedError = new FetchResult(undefined, err);
                        this.fetchResults.push(bufferedError);
                        // Putting a dummy result so that the rest of code flows
                        return { result: [bufferedError], headers: err.headers };
                    }
                    else {
                        this._updateStates(err, err.resources === undefined);
                        throw err;
                    }
                }
            });
        }
        /**
         * Synchronously gives the bufferend current item if any
         * @returns {Object}       - buffered current item if any
         * @ignore
         */
        getTargetParitionKeyRange() {
            return this.targetPartitionKeyRange;
        }
        /**
         * Execute a provided function on the next element in the DocumentProducer.
         * @memberof DocumentProducer
         * @instance
         * @param {callback} callback - Function to execute for each element. the function \
         * takes two parameters error, element.
         */
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.err) {
                    this._updateStates(this.err, undefined);
                    throw this.err;
                }
                try {
                    const { result, headers } = yield this.current();
                    const fetchResult = this.fetchResults.shift();
                    this._updateStates(undefined, result === undefined);
                    if (fetchResult.feedResponse !== result) {
                        throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);
                    }
                    switch (fetchResult.fetchResultType) {
                        case FetchResultType.Done:
                            return { result: undefined, headers };
                        case FetchResultType.Exception:
                            fetchResult.error.headers = headers;
                            throw fetchResult.error;
                        case FetchResultType.Result:
                            return { result: fetchResult.feedResponse, headers };
                    }
                }
                catch (err) {
                    this._updateStates(err, err.item === undefined);
                    throw err;
                }
            });
        }
        /**
         * Retrieve the current element on the DocumentProducer.
         * @memberof DocumentProducer
         * @instance
         * @param {callback} callback - Function to execute for the current element. \
         * the function takes two parameters error, element.
         */
        current() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // If something is buffered just give that
                if (this.fetchResults.length > 0) {
                    const fetchResult = this.fetchResults[0];
                    // Need to unwrap fetch results
                    switch (fetchResult.fetchResultType) {
                        case FetchResultType.Done:
                            return {
                                result: undefined,
                                headers: this._getAndResetActiveResponseHeaders()
                            };
                        case FetchResultType.Exception:
                            fetchResult.error.headers = this._getAndResetActiveResponseHeaders();
                            throw fetchResult.error;
                        case FetchResultType.Result:
                            return {
                                result: fetchResult.feedResponse,
                                headers: this._getAndResetActiveResponseHeaders()
                            };
                    }
                }
                // If there isn't anymore items left to fetch then let the user know.
                if (this.allFetched) {
                    return {
                        result: undefined,
                        headers: this._getAndResetActiveResponseHeaders()
                    };
                }
                // If there are no more bufferd items and there are still items to be fetched then buffer more
                const { result, headers } = yield this.bufferMore();
                mergeHeaders(this.respHeaders, headers);
                if (result === undefined) {
                    return { result: undefined, headers: this.respHeaders };
                }
                return this.current();
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    class QueryRange {
        /**
         * Represents a QueryRange.
         * @constructor QueryRange
         * @param {string} rangeMin                - min
         * @param {string} rangeMin                - max
         * @param {boolean} isMinInclusive         - isMinInclusive
         * @param {boolean} isMaxInclusive         - isMaxInclusive
         * @ignore
         */
        constructor(rangeMin, rangeMax, isMinInclusive, isMaxInclusive) {
            this.min = rangeMin;
            this.max = rangeMax;
            this.isMinInclusive = isMinInclusive;
            this.isMaxInclusive = isMaxInclusive;
        }
        overlaps(other) {
            // tslint:disable-next-line:no-this-assignment
            const range1 = this;
            const range2 = other;
            if (range1 === undefined || range2 === undefined) {
                return false;
            }
            if (range1.isEmpty() || range2.isEmpty()) {
                return false;
            }
            if (range1.min <= range2.max || range2.min <= range1.max) {
                if ((range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive)) ||
                    (range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive))) {
                    return false;
                }
                return true;
            }
            return false;
        }
        isFullRange() {
            return (this.min === Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&
                this.max === Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&
                this.isMinInclusive === true &&
                this.isMaxInclusive === false);
        }
        isEmpty() {
            return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;
        }
        /**
         * Parse a QueryRange from a partitionKeyRange
         * @returns QueryRange
         * @ignore
         */
        static parsePartitionKeyRange(partitionKeyRange) {
            // TODO: paritionkeyrange
            return new QueryRange(partitionKeyRange[Constants.PartitionKeyRange.MinInclusive], partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive], true, false);
        }
        /**
         * Parse a QueryRange from a dictionary
         * @returns QueryRange
         * @ignore
         */
        static parseFromDict(queryRangeDict) {
            // TODO: queryRangeDictionary
            return new QueryRange(queryRangeDict.min, queryRangeDict.max, queryRangeDict.isMinInclusive, queryRangeDict.isMaxInclusive);
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    class InMemoryCollectionRoutingMap {
        /**
         * Represents a InMemoryCollectionRoutingMap Object,
         * Stores partition key ranges in an efficient way with some additional information and provides
         * convenience methods for working with set of ranges.
         */
        constructor(orderedPartitionKeyRanges, orderedPartitionInfo) {
            this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;
            this.orderedRanges = orderedPartitionKeyRanges.map((pkr) => {
                return new QueryRange(pkr[Constants.PartitionKeyRange.MinInclusive], pkr[Constants.PartitionKeyRange.MaxExclusive], true, false);
            });
            this.orderedPartitionInfo = orderedPartitionInfo;
        }
        getOrderedParitionKeyRanges() {
            return this.orderedPartitionKeyRanges;
        }
        getOverlappingRanges(providedQueryRanges) {
            // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges
            // stfaul attempted to bring it down to one for-loop and failed
            const pqr = Array.isArray(providedQueryRanges)
                ? providedQueryRanges
                : [providedQueryRanges];
            const minToPartitionRange = {}; // TODO: any
            // this for loop doesn't invoke any async callback
            for (const queryRange of pqr) {
                if (queryRange.isEmpty()) {
                    continue;
                }
                if (queryRange.isFullRange()) {
                    return this.orderedPartitionKeyRanges;
                }
                const minIndex = this.orderedRanges.findIndex((range) => {
                    if (queryRange.min > range.min && queryRange.min < range.max) {
                        return true;
                    }
                    if (queryRange.min === range.min) {
                        return true;
                    }
                    if (queryRange.min === range.max) {
                        return true;
                    }
                });
                if (minIndex < 0) {
                    throw new Error("error in collection routing map, queried value is less than the start range.");
                }
                // Start at the end and work backwards
                let maxIndex;
                for (let i = this.orderedRanges.length - 1; i >= 0; i--) {
                    const range = this.orderedRanges[i];
                    if (queryRange.max > range.min && queryRange.max < range.max) {
                        maxIndex = i;
                        break;
                    }
                    if (queryRange.max === range.min) {
                        maxIndex = i;
                        break;
                    }
                    if (queryRange.max === range.max) {
                        maxIndex = i;
                        break;
                    }
                }
                if (maxIndex > this.orderedRanges.length) {
                    throw new Error("error in collection routing map, queried value is greater than the end range.");
                }
                for (let j = minIndex; j < maxIndex + 1; j++) {
                    if (queryRange.overlaps(this.orderedRanges[j])) {
                        minToPartitionRange[this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]] = this.orderedPartitionKeyRanges[j];
                    }
                }
            }
            const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map((k) => minToPartitionRange[k]);
            return overlappingPartitionKeyRanges.sort((a, b) => {
                return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(b[Constants.PartitionKeyRange.MinInclusive]);
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * @ignore
     */
    function compareRanges(a, b) {
        const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];
        const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];
        if (aVal > bVal) {
            return 1;
        }
        if (aVal < bVal) {
            return -1;
        }
        return 0;
    }
    /** @hidden */
    function createCompleteRoutingMap(partitionKeyRangeInfoTuppleList) {
        const rangeById = {}; // TODO: any
        const rangeByInfo = {}; // TODO: any
        let sortedRanges = [];
        // the for loop doesn't invoke any async callback
        for (const r of partitionKeyRangeInfoTuppleList) {
            rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;
            rangeByInfo[r[1]] = r[0];
            sortedRanges.push(r);
        }
        sortedRanges = sortedRanges.sort(compareRanges);
        const partitionKeyOrderedRange = sortedRanges.map((r) => r[0]);
        const orderedPartitionInfo = sortedRanges.map((r) => r[1]);
        if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {
            return undefined;
        }
        return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);
    }
    /**
     * @ignore
     */
    function isCompleteSetOfRange(partitionKeyOrderedRange) {
        // TODO: any
        let isComplete = false;
        if (partitionKeyOrderedRange.length > 0) {
            const firstRange = partitionKeyOrderedRange[0];
            const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];
            isComplete =
                firstRange[Constants.PartitionKeyRange.MinInclusive] ===
                    Constants.EffectiveParitionKeyConstants.MinimumInclusiveEffectivePartitionKey;
            isComplete =
                isComplete &&
                    lastRange[Constants.PartitionKeyRange.MaxExclusive] ===
                        Constants.EffectiveParitionKeyConstants.MaximumExclusiveEffectivePartitionKey;
            for (let i = 1; i < partitionKeyOrderedRange.length; i++) {
                const previousRange = partitionKeyOrderedRange[i - 1];
                const currentRange = partitionKeyOrderedRange[i];
                isComplete =
                    isComplete &&
                        previousRange[Constants.PartitionKeyRange.MaxExclusive] ===
                            currentRange[Constants.PartitionKeyRange.MinInclusive];
                if (!isComplete) {
                    if (previousRange[Constants.PartitionKeyRange.MaxExclusive] >
                        currentRange[Constants.PartitionKeyRange.MinInclusive]) {
                        throw Error("Ranges overlap");
                    }
                    break;
                }
            }
        }
        return isComplete;
    }

    /** @hidden */
    class PartitionKeyRangeCache {
        constructor(clientContext) {
            this.clientContext = clientContext;
            this.collectionRoutingMapByCollectionId = {};
        }
        /**
         * Finds or Instantiates the requested Collection Routing Map
         * @param {string} collectionLink            - Requested collectionLink
         * @ignore
         */
        onCollectionRoutingMap(collectionLink) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const collectionId = getIdFromLink(collectionLink);
                if (this.collectionRoutingMapByCollectionId[collectionId] === undefined) {
                    this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(collectionLink);
                }
                return this.collectionRoutingMapByCollectionId[collectionId];
            });
        }
        /**
         * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges
         * @param collectionLink
         * @param queryRange
         * @ignore
         */
        getOverlappingRanges(collectionLink, queryRange) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const crm = yield this.onCollectionRoutingMap(collectionLink);
                return crm.getOverlappingRanges(queryRange);
            });
        }
        requestCollectionRoutingMap(collectionLink) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { resources } = yield this.clientContext
                    .queryPartitionKeyRanges(collectionLink)
                    .fetchAll();
                return createCompleteRoutingMap(resources.map((r) => [r, true]));
            });
        }
    }

    /** @hidden */
    const PARITIONKEYRANGE = Constants.PartitionKeyRange;
    /** @hidden */
    class SmartRoutingMapProvider {
        constructor(clientContext) {
            this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);
        }
        static _secondRangeIsAfterFirstRange(range1, range2) {
            if (typeof range1.max === "undefined") {
                throw new Error("range1 must have max");
            }
            if (typeof range2.min === "undefined") {
                throw new Error("range2 must have min");
            }
            if (range1.max > range2.min) {
                // r.min < #previous_r.max
                return false;
            }
            else {
                if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {
                    // the inclusive ending endpoint of previous_r is the same as the inclusive beginning endpoint of r
                    // they share a point
                    return false;
                }
                return true;
            }
        }
        static _isSortedAndNonOverlapping(ranges) {
            for (let idx = 1; idx < ranges.length; idx++) {
                const previousR = ranges[idx - 1];
                const r = ranges[idx];
                if (!this._secondRangeIsAfterFirstRange(previousR, r)) {
                    return false;
                }
            }
            return true;
        }
        static _stringMax(a, b) {
            return a >= b ? a : b;
        }
        static _stringCompare(a, b) {
            return a === b ? 0 : a > b ? 1 : -1;
        }
        static _subtractRange(r, partitionKeyRange) {
            const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);
            const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;
            return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);
        }
        /**
         * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges
         * @param {callback} callback - Function execute on the overlapping partition key ranges result,
         *                              takes two parameters error, partition key ranges
         * @param collectionLink
         * @param sortedRanges
         * @ignore
         */
        getOverlappingRanges(collectionLink, sortedRanges) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // validate if the list is non- overlapping and sorted                             TODO: any PartitionKeyRanges
                if (!SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {
                    throw new Error("the list of ranges is not a non-overlapping sorted ranges");
                }
                let partitionKeyRanges = []; // TODO: any ParitionKeyRanges
                if (sortedRanges.length === 0) {
                    return partitionKeyRanges;
                }
                const collectionRoutingMap = yield this.partitionKeyRangeCache.onCollectionRoutingMap(collectionLink);
                let index = 0;
                let currentProvidedRange = sortedRanges[index];
                while (true) {
                    if (currentProvidedRange.isEmpty()) {
                        // skip and go to the next item
                        if (++index >= sortedRanges.length) {
                            return partitionKeyRanges;
                        }
                        currentProvidedRange = sortedRanges[index];
                        continue;
                    }
                    let queryRange;
                    if (partitionKeyRanges.length > 0) {
                        queryRange = SmartRoutingMapProvider._subtractRange(currentProvidedRange, partitionKeyRanges[partitionKeyRanges.length - 1]);
                    }
                    else {
                        queryRange = currentProvidedRange;
                    }
                    const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);
                    if (overlappingRanges.length <= 0) {
                        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);
                    }
                    partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);
                    const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(partitionKeyRanges[partitionKeyRanges.length - 1]);
                    if (!lastKnownTargetRange) {
                        throw new Error("expected lastKnowTargetRange to be truthy");
                    }
                    // the overlapping ranges must contain the requested range
                    if (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) >
                        0) {
                        throw new Error(`error: returned overlapping ranges ${overlappingRanges} \
        does not contain the requested range ${queryRange}`);
                    }
                    // the current range is contained in partitionKeyRanges just move forward
                    if (++index >= sortedRanges.length) {
                        return partitionKeyRanges;
                    }
                    currentProvidedRange = sortedRanges[index];
                    while (SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0) {
                        // the current range is covered too.just move forward
                        if (++index >= sortedRanges.length) {
                            return partitionKeyRanges;
                        }
                        currentProvidedRange = sortedRanges[index];
                    }
                }
            });
        }
    }

    /** @hidden */
    const log$1 = logger("parallelQueryExecutionContextBase");
    /** @hidden */
    var ParallelQueryExecutionContextBaseStates;
    (function (ParallelQueryExecutionContextBaseStates) {
        ParallelQueryExecutionContextBaseStates["started"] = "started";
        ParallelQueryExecutionContextBaseStates["inProgress"] = "inProgress";
        ParallelQueryExecutionContextBaseStates["ended"] = "ended";
    })(ParallelQueryExecutionContextBaseStates || (ParallelQueryExecutionContextBaseStates = {}));
    /** @hidden */
    class ParallelQueryExecutionContextBase {
        /**
         * Provides the ParallelQueryExecutionContextBase.
         * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.
         *
         * When handling a parallelized query, it instantiates one instance of
         * DocumentProcuder per target partition key range and aggregates the result of each.
         *
         * @constructor ParallelQueryExecutionContext
         * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
         * @param {string} collectionLink                - The Collection Link
         * @param {FeedOptions} [options]                - Represents the feed options.
         * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
         * @ignore
         */
        constructor(clientContext, collectionLink, query, // TODO: any - It's not SQLQuerySpec
        options, partitionedQueryExecutionInfo) {
            this.clientContext = clientContext;
            this.collectionLink = collectionLink;
            this.query = query;
            this.options = options;
            this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
            this.clientContext = clientContext;
            this.collectionLink = collectionLink;
            this.query = query;
            this.options = options;
            this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
            this.err = undefined;
            this.state = ParallelQueryExecutionContextBase.STATES.started;
            this.routingProvider = new SmartRoutingMapProvider(this.clientContext);
            this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;
            this.requestContinuation = options ? options.continuationToken || options.continuation : null;
            // response headers of undergoing operation
            this.respHeaders = getInitialHeader();
            // Make priority queue for documentProducers
            // The comparator is supplied by the derived class
            this.orderByPQ = new PriorityQueue((a, b) => this.documentProducerComparator(b, a));
            // Creating the documentProducers
            this.sem = semaphore(1);
            // Creating callback for semaphore
            // TODO: Code smell
            const createDocumentProducersAndFillUpPriorityQueueFunc = () => tslib.__awaiter(this, void 0, void 0, function* () {
                // ensure the lock is released after finishing up
                try {
                    const targetPartitionRanges = yield this._onTargetPartitionRanges();
                    this.waitingForInternalExecutionContexts = targetPartitionRanges.length;
                    const maxDegreeOfParallelism = options.maxDegreeOfParallelism === undefined || options.maxDegreeOfParallelism < 1
                        ? targetPartitionRanges.length
                        : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);
                    log$1.info("Query starting against " +
                        targetPartitionRanges.length +
                        " ranges with parallelism of " +
                        maxDegreeOfParallelism);
                    const parallelismSem = semaphore(maxDegreeOfParallelism);
                    let filteredPartitionKeyRanges = [];
                    // The document producers generated from filteredPartitionKeyRanges
                    const targetPartitionQueryExecutionContextList = [];
                    if (this.requestContinuation) {
                        throw new Error("Continuation tokens are not yet supported for cross partition queries");
                    }
                    else {
                        filteredPartitionKeyRanges = targetPartitionRanges;
                    }
                    // Create one documentProducer for each partitionTargetRange
                    filteredPartitionKeyRanges.forEach((partitionTargetRange) => {
                        // TODO: any partitionTargetRange
                        // no async callback
                        targetPartitionQueryExecutionContextList.push(this._createTargetPartitionQueryExecutionContext(partitionTargetRange));
                    });
                    // Fill up our priority queue with documentProducers
                    targetPartitionQueryExecutionContextList.forEach((documentProducer) => {
                        // has async callback
                        const throttledFunc = () => tslib.__awaiter(this, void 0, void 0, function* () {
                            try {
                                const { result: document, headers } = yield documentProducer.current();
                                this._mergeWithActiveResponseHeaders(headers);
                                if (document === undefined) {
                                    // no results on this one
                                    return;
                                }
                                // if there are matching results in the target ex range add it to the priority queue
                                try {
                                    this.orderByPQ.enq(documentProducer);
                                }
                                catch (e) {
                                    this.err = e;
                                }
                            }
                            catch (err) {
                                this._mergeWithActiveResponseHeaders(err.headers);
                                this.err = err;
                            }
                            finally {
                                parallelismSem.leave();
                                this._decrementInitiationLock();
                            }
                        });
                        parallelismSem.take(throttledFunc);
                    });
                }
                catch (err) {
                    this.err = err;
                    // release the lock
                    this.sem.leave();
                    return;
                }
            });
            this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);
        }
        _decrementInitiationLock() {
            // decrements waitingForInternalExecutionContexts
            // if waitingForInternalExecutionContexts reaches 0 releases the semaphore and changes the state
            this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;
            if (this.waitingForInternalExecutionContexts === 0) {
                this.sem.leave();
                if (this.orderByPQ.size() === 0) {
                    this.state = ParallelQueryExecutionContextBase.STATES.inProgress;
                }
            }
        }
        _mergeWithActiveResponseHeaders(headers) {
            mergeHeaders(this.respHeaders, headers);
        }
        _getAndResetActiveResponseHeaders() {
            const ret = this.respHeaders;
            this.respHeaders = getInitialHeader();
            return ret;
        }
        _onTargetPartitionRanges() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // invokes the callback when the target partition ranges are ready
                const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;
                const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));
                return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges);
            });
        }
        /**
         * Gets the replacement ranges for a partitionkeyrange that has been split
         * @memberof ParallelQueryExecutionContextBase
         * @instance
         */
        _getReplacementPartitionKeyRanges(documentProducer) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const partitionKeyRange = documentProducer.targetPartitionKeyRange;
                // Download the new routing map
                this.routingProvider = new SmartRoutingMapProvider(this.clientContext);
                // Get the queryRange that relates to this partitionKeyRange
                const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);
                return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange]);
            });
        }
        // TODO: P0 Code smell - can barely tell what this is doing
        /**
         * Removes the current document producer from the priqueue,
         * replaces that document producer with child document producers,
         * then reexecutes the originFunction with the corrrected executionContext
         * @memberof ParallelQueryExecutionContextBase
         * @instance
         */
        _repairExecutionContext(originFunction) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // TODO: any
                // Get the replacement ranges
                // Removing the invalid documentProducer from the orderByPQ
                const parentDocumentProducer = this.orderByPQ.deq();
                try {
                    const replacementPartitionKeyRanges = yield this._getReplacementPartitionKeyRanges(parentDocumentProducer);
                    const replacementDocumentProducers = [];
                    // Create the replacement documentProducers
                    replacementPartitionKeyRanges.forEach((partitionKeyRange) => {
                        // Create replacment document producers with the parent's continuationToken
                        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(partitionKeyRange, parentDocumentProducer.continuationToken);
                        replacementDocumentProducers.push(replacementDocumentProducer);
                    });
                    // We need to check if the documentProducers even has anything left to fetch from before enqueing them
                    const checkAndEnqueueDocumentProducer = (documentProducerToCheck, checkNextDocumentProducerCallback) => tslib.__awaiter(this, void 0, void 0, function* () {
                        try {
                            const { result: afterItem } = yield documentProducerToCheck.current();
                            if (afterItem === undefined) {
                                // no more results left in this document producer, so we don't enqueue it
                            }
                            else {
                                // Safe to put document producer back in the queue
                                this.orderByPQ.enq(documentProducerToCheck);
                            }
                            yield checkNextDocumentProducerCallback();
                        }
                        catch (err) {
                            this.err = err;
                            return;
                        }
                    });
                    const checkAndEnqueueDocumentProducers = (rdp) => tslib.__awaiter(this, void 0, void 0, function* () {
                        if (rdp.length > 0) {
                            // We still have a replacementDocumentProducer to check
                            const replacementDocumentProducer = rdp.shift();
                            yield checkAndEnqueueDocumentProducer(replacementDocumentProducer, () => tslib.__awaiter(this, void 0, void 0, function* () {
                                yield checkAndEnqueueDocumentProducers(rdp);
                            }));
                        }
                        else {
                            // reexecutes the originFunction with the corrrected executionContext
                            return originFunction();
                        }
                    });
                    // Invoke the recursive function to get the ball rolling
                    yield checkAndEnqueueDocumentProducers(replacementDocumentProducers);
                }
                catch (err) {
                    this.err = err;
                    throw err;
                }
            });
        }
        static _needPartitionKeyRangeCacheRefresh(error) {
            // TODO: any error
            return (error.code === StatusCodes.Gone &&
                "substatus" in error &&
                error["substatus"] === SubStatusCodes.PartitionKeyRangeGone);
        }
        /**
         * Checks to see if the executionContext needs to be repaired.
         * if so it repairs the execution context and executes the ifCallback,
         * else it continues with the current execution context and executes the elseCallback
         * @memberof ParallelQueryExecutionContextBase
         * @instance
         */
        _repairExecutionContextIfNeeded(ifCallback, elseCallback) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const documentProducer = this.orderByPQ.peek();
                // Check if split happened
                try {
                    yield documentProducer.current();
                    elseCallback();
                }
                catch (err) {
                    if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {
                        // Split has happened so we need to repair execution context before continueing
                        return this._repairExecutionContext(ifCallback);
                    }
                    else {
                        // Something actually bad happened ...
                        this.err = err;
                        throw err;
                    }
                }
            });
        }
        /**
         * Execute a provided function on the next element in the ParallelQueryExecutionContextBase.
         * @memberof ParallelQueryExecutionContextBase
         * @instance
         * @param {callback} callback - Function to execute for each element. the function takes two \
         * parameters error, element.
         */
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.err) {
                    // if there is a prior error return error
                    throw this.err;
                }
                return new Promise((resolve, reject) => {
                    this.sem.take(() => {
                        // NOTE: lock must be released before invoking quitting
                        if (this.err) {
                            // release the lock before invoking callback
                            this.sem.leave();
                            // if there is a prior error return error
                            this.err.headers = this._getAndResetActiveResponseHeaders();
                            reject(this.err);
                            return;
                        }
                        if (this.orderByPQ.size() === 0) {
                            // there is no more results
                            this.state = ParallelQueryExecutionContextBase.STATES.ended;
                            // release the lock before invoking callback
                            this.sem.leave();
                            return resolve({
                                result: undefined,
                                headers: this._getAndResetActiveResponseHeaders()
                            });
                        }
                        const ifCallback = () => {
                            // Release the semaphore to avoid deadlock
                            this.sem.leave();
                            // Reexcute the function
                            return resolve(this.nextItem());
                        };
                        const elseCallback = () => tslib.__awaiter(this, void 0, void 0, function* () {
                            let documentProducer;
                            try {
                                documentProducer = this.orderByPQ.deq();
                            }
                            catch (e) {
                                // if comparing elements of the priority queue throws exception
                                // set that error and return error
                                this.err = e;
                                // release the lock before invoking callback
                                this.sem.leave();
                                this.err.headers = this._getAndResetActiveResponseHeaders();
                                reject(this.err);
                                return;
                            }
                            let item;
                            let headers;
                            try {
                                const response = yield documentProducer.nextItem();
                                item = response.result;
                                headers = response.headers;
                                this._mergeWithActiveResponseHeaders(headers);
                                if (item === undefined) {
                                    // this should never happen
                                    // because the documentProducer already has buffered an item
                                    // assert item !== undefined
                                    this.err = new Error(`Extracted DocumentProducer from the priority queue \
                                            doesn't have any buffered item!`);
                                    // release the lock before invoking callback
                                    this.sem.leave();
                                    return resolve({
                                        result: undefined,
                                        headers: this._getAndResetActiveResponseHeaders()
                                    });
                                }
                            }
                            catch (err) {
                                this.err = new Error(`Extracted DocumentProducer from the priority queue fails to get the \
                                    buffered item. Due to ${JSON.stringify(err)}`);
                                this.err.headers = this._getAndResetActiveResponseHeaders();
                                // release the lock before invoking callback
                                this.sem.leave();
                                reject(this.err);
                                return;
                            }
                            // we need to put back the document producer to the queue if it has more elements.
                            // the lock will be released after we know document producer must be put back in the queue or not
                            try {
                                const { result: afterItem, headers: otherHeaders } = yield documentProducer.current();
                                this._mergeWithActiveResponseHeaders(otherHeaders);
                                if (afterItem === undefined) {
                                    // no more results is left in this document producer
                                }
                                else {
                                    try {
                                        const headItem = documentProducer.fetchResults[0];
                                        if (typeof headItem === "undefined") {
                                            throw new Error("Extracted DocumentProducer from PQ is invalid state with no result!");
                                        }
                                        this.orderByPQ.enq(documentProducer);
                                    }
                                    catch (e) {
                                        // if comparing elements in priority queue throws exception
                                        // set error
                                        this.err = e;
                                    }
                                }
                            }
                            catch (err) {
                                if (ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {
                                    // We want the document producer enqueued
                                    // So that later parts of the code can repair the execution context
                                    this.orderByPQ.enq(documentProducer);
                                }
                                else {
                                    // Something actually bad happened
                                    this.err = err;
                                    reject(this.err);
                                }
                            }
                            finally {
                                // release the lock before returning
                                this.sem.leave();
                            }
                            // invoke the callback on the item
                            return resolve({
                                result: item,
                                headers: this._getAndResetActiveResponseHeaders()
                            });
                        });
                        this._repairExecutionContextIfNeeded(ifCallback, elseCallback).catch(reject);
                    });
                });
            });
        }
        /**
         * Determine if there are still remaining resources to processs based on the value of the continuation \
         * token or the elements remaining on the current batch in the QueryIterator.
         * @memberof ParallelQueryExecutionContextBase
         * @instance
         * @returns {Boolean} true if there is other elements to process in the ParallelQueryExecutionContextBase.
         */
        hasMoreResults() {
            return !(this.state === ParallelQueryExecutionContextBase.STATES.ended || this.err !== undefined);
        }
        /**
         * Creates document producers
         */
        _createTargetPartitionQueryExecutionContext(partitionKeyTargetRange, continuationToken) {
            // TODO: any
            // creates target partition range Query Execution Context
            let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;
            let query = this.query;
            if (typeof query === "string") {
                query = { query };
            }
            const formatPlaceHolder = "{documentdb-formattableorderbyquery-filter}";
            if (rewrittenQuery) {
                query = JSON.parse(JSON.stringify(query));
                // We hardcode the formattable filter to true for now
                rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, "true");
                query["query"] = rewrittenQuery;
            }
            const options = JSON.parse(JSON.stringify(this.options));
            options.continuationToken = continuationToken;
            return new DocumentProducer(this.clientContext, this.collectionLink, query, partitionKeyTargetRange, options);
        }
    }
    ParallelQueryExecutionContextBase.STATES = ParallelQueryExecutionContextBaseStates;

    /** @hidden */
    class ParallelQueryExecutionContext extends ParallelQueryExecutionContextBase {
        /**
         * Provides the ParallelQueryExecutionContext.
         * This class is capable of handling parallelized queries and dervives from ParallelQueryExecutionContextBase.
         *
         * @constructor ParallelQueryExecutionContext
         * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
         * @param {string} collectionLink                - The Collection Link
         * @param {FeedOptions} [options]                - Represents the feed options.
         * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
         * @ignore
         */
        constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo) {
            // Calling on base class constructor
            super(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo);
        }
        // Instance members are inherited
        // Overriding documentProducerComparator for ParallelQueryExecutionContexts
        /**
         * Provides a Comparator for document producers using the min value of the corresponding target partition.
         * @returns {object}        - Comparator Function
         * @ignore
         */
        documentProducerComparator(docProd1, docProd2) {
            return docProd1.generation - docProd2.generation;
        }
    }

    /** @hidden */
    class OrderByQueryExecutionContext extends ParallelQueryExecutionContextBase {
        /**
         * Provides the OrderByQueryExecutionContext.
         * This class is capable of handling orderby queries and dervives from ParallelQueryExecutionContextBase.
         *
         * When handling a parallelized query, it instantiates one instance of
         * DocumentProcuder per target partition key range and aggregates the result of each.
         *
         * @constructor ParallelQueryExecutionContext
         * @param {ClientContext} clientContext        - The service endpoint to use to create the client.
         * @param {string} collectionLink                - The Collection Link
         * @param {FeedOptions} [options]                - Represents the feed options.
         * @param {object} partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
         * @ignore
         */
        constructor(clientContext, collectionLink, query, // TODO: any query
        options, // TODO: any options
        partitionedQueryExecutionInfo) {
            // Calling on base class constructor
            super(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo);
            this.orderByComparator = new OrderByDocumentProducerComparator(this.sortOrders);
        }
        // Instance members are inherited
        // Overriding documentProducerComparator for OrderByQueryExecutionContexts
        /**
         * Provides a Comparator for document producers which respects orderby sort order.
         * @returns {object}        - Comparator Function
         * @ignore
         */
        documentProducerComparator(docProd1, docProd2) {
            return this.orderByComparator.compare(docProd1, docProd2);
        }
    }

    /** @hidden */
    class OffsetLimitEndpointComponent {
        constructor(executionContext, offset, limit) {
            this.executionContext = executionContext;
            this.offset = offset;
            this.limit = limit;
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const aggregateHeaders = getInitialHeader();
                while (this.offset > 0) {
                    // Grab next item but ignore the result. We only need the headers
                    const { headers } = yield this.executionContext.nextItem();
                    this.offset--;
                    mergeHeaders(aggregateHeaders, headers);
                }
                if (this.limit > 0) {
                    const { result, headers } = yield this.executionContext.nextItem();
                    this.limit--;
                    mergeHeaders(aggregateHeaders, headers);
                    return { result, headers: aggregateHeaders };
                }
                // If both limit and offset are 0, return nothing
                return { result: undefined, headers: getInitialHeader() };
            });
        }
        hasMoreResults() {
            return (this.offset > 0 || this.limit > 0) && this.executionContext.hasMoreResults();
        }
    }

    /** @hidden */
    class OrderByEndpointComponent {
        /**
         * Represents an endpoint in handling an order by query. For each processed orderby \
         * result it returns 'payload' item of the result
         * @constructor OrderByEndpointComponent
         * @param {object} executionContext              - Underlying Execution Context
         * @ignore
         */
        constructor(executionContext) {
            this.executionContext = executionContext;
        }
        /**
         * Execute a provided function on the next element in the OrderByEndpointComponent.
         * @memberof OrderByEndpointComponent
         * @instance
         */
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { result: item, headers } = yield this.executionContext.nextItem();
                return {
                    result: item !== undefined ? item.payload : undefined,
                    headers
                };
            });
        }
        /**
         * Determine if there are still remaining resources to processs.
         * @memberof OrderByEndpointComponent
         * @instance
         * @returns {Boolean} true if there is other elements to process in the OrderByEndpointComponent.
         */
        hasMoreResults() {
            return this.executionContext.hasMoreResults();
        }
    }

    function digest(str) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const hash = crypto.createHash("sha256");
            hash.update(str, "utf8");
            return hash.digest("hex");
        });
    }

    function hashObject(object) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const stringifiedObject = stableStringify(object);
            return digest(stringifiedObject);
        });
    }

    /** @hidden */
    class OrderedDistinctEndpointComponent {
        constructor(executionContext) {
            this.executionContext = executionContext;
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { headers, result } = yield this.executionContext.nextItem();
                if (result) {
                    const hashedResult = yield hashObject(result);
                    if (hashedResult === this.hashedLastResult) {
                        return { result: undefined, headers };
                    }
                    this.hashedLastResult = hashedResult;
                }
                return { result, headers };
            });
        }
        hasMoreResults() {
            return this.executionContext.hasMoreResults();
        }
    }

    /** @hidden */
    class UnorderedDistinctEndpointComponent {
        constructor(executionContext) {
            this.executionContext = executionContext;
            this.hashedResults = new Set();
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { headers, result } = yield this.executionContext.nextItem();
                if (result) {
                    const hashedResult = yield hashObject(result);
                    if (this.hashedResults.has(hashedResult)) {
                        return { result: undefined, headers };
                    }
                    this.hashedResults.add(hashedResult);
                }
                return { result, headers };
            });
        }
        hasMoreResults() {
            return this.executionContext.hasMoreResults();
        }
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    // All aggregates are effectively a group by operation
    // The empty group is used for aggregates without a GROUP BY clause
    const emptyGroup = "__empty__";
    // Newer API versions rewrite the query to return `item2`. It fixes some legacy issues with the original `item` result
    // Aggregator code should use item2 when available
    const extractAggregateResult = (payload) => payload.item2 ? payload.item2 : payload.item;

    /** @hidden */
    class GroupByEndpointComponent {
        constructor(executionContext, queryInfo) {
            this.executionContext = executionContext;
            this.queryInfo = queryInfo;
            this.groupings = new Map();
            this.aggregateResultArray = [];
            this.completed = false;
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // If we have a full result set, begin returning results
                if (this.aggregateResultArray.length > 0) {
                    return { result: this.aggregateResultArray.pop(), headers: getInitialHeader() };
                }
                if (this.completed) {
                    return { result: undefined, headers: getInitialHeader() };
                }
                const aggregateHeaders = getInitialHeader();
                while (this.executionContext.hasMoreResults()) {
                    // Grab the next result
                    const { result, headers } = (yield this.executionContext.nextItem());
                    mergeHeaders(aggregateHeaders, headers);
                    // If it exists, process it via aggregators
                    if (result) {
                        const group = result.groupByItems ? yield hashObject(result.groupByItems) : emptyGroup;
                        const aggregators = this.groupings.get(group);
                        const payload = result.payload;
                        if (aggregators) {
                            // Iterator over all results in the payload
                            Object.keys(payload).map((key) => {
                                const aggregateResult = extractAggregateResult(payload[key]);
                                aggregators.get(key).aggregate(aggregateResult);
                            });
                        }
                        else {
                            // This is the first time we have seen a grouping. Setup the initial result without aggregate values
                            const grouping = new Map();
                            this.groupings.set(group, grouping);
                            // Iterator over all results in the payload
                            Object.keys(payload).map((key) => {
                                const aggregateType = this.queryInfo.groupByAliasToAggregateType[key];
                                // Create a new aggregator for this specific aggregate field
                                const aggregator = createAggregator(aggregateType);
                                grouping.set(key, aggregator);
                                if (aggregateType) {
                                    const aggregateResult = extractAggregateResult(payload[key]);
                                    aggregator.aggregate(aggregateResult);
                                }
                                else {
                                    aggregator.aggregate(payload[key]);
                                }
                            });
                        }
                    }
                }
                for (const grouping of this.groupings.values()) {
                    const groupResult = {};
                    for (const [aggregateKey, aggregator] of grouping.entries()) {
                        groupResult[aggregateKey] = aggregator.getResult();
                    }
                    this.aggregateResultArray.push(groupResult);
                }
                this.completed = true;
                return { result: this.aggregateResultArray.pop(), headers: aggregateHeaders };
            });
        }
        hasMoreResults() {
            return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;
        }
    }

    /** @hidden */
    class GroupByValueEndpointComponent {
        constructor(executionContext, queryInfo) {
            this.executionContext = executionContext;
            this.queryInfo = queryInfo;
            this.aggregators = new Map();
            this.aggregateResultArray = [];
            this.completed = false;
            // VALUE queries will only every have a single grouping
            this.aggregateType = this.queryInfo.aggregates[0];
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // Start returning results if we have processed a full results set
                if (this.aggregateResultArray.length > 0) {
                    return { result: this.aggregateResultArray.pop(), headers: getInitialHeader() };
                }
                if (this.completed) {
                    return { result: undefined, headers: getInitialHeader() };
                }
                const aggregateHeaders = getInitialHeader();
                while (this.executionContext.hasMoreResults()) {
                    // Grab the next result
                    const { result, headers } = (yield this.executionContext.nextItem());
                    mergeHeaders(aggregateHeaders, headers);
                    // If it exists, process it via aggregators
                    if (result) {
                        let grouping = emptyGroup;
                        let payload = result;
                        if (result.groupByItems) {
                            // If the query contains a GROUP BY clause, it will have a payload property and groupByItems
                            payload = result.payload;
                            grouping = yield hashObject(result.groupByItems);
                        }
                        const aggregator = this.aggregators.get(grouping);
                        if (!aggregator) {
                            // This is the first time we have seen a grouping so create a new aggregator
                            this.aggregators.set(grouping, createAggregator(this.aggregateType));
                        }
                        if (this.aggregateType) {
                            const aggregateResult = extractAggregateResult(payload[0]);
                            this.aggregators.get(grouping).aggregate(aggregateResult);
                        }
                        else {
                            // Queries with no aggregates pass the payload directly to the aggregator
                            // Example: SELECT VALUE c.team FROM c GROUP BY c.team
                            this.aggregators.get(grouping).aggregate(payload);
                        }
                    }
                }
                // It no results are left in the underling execution context, convert our aggregate results to an array
                for (const aggregator of this.aggregators.values()) {
                    this.aggregateResultArray.push(aggregator.getResult());
                }
                this.completed = true;
                return { result: this.aggregateResultArray.pop(), headers: aggregateHeaders };
            });
        }
        hasMoreResults() {
            return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;
        }
    }

    /** @hidden */
    class PipelinedQueryExecutionContext {
        constructor(clientContext, collectionLink, query, // TODO: any query
        options, partitionedQueryExecutionInfo) {
            this.clientContext = clientContext;
            this.collectionLink = collectionLink;
            this.query = query;
            this.options = options;
            this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
            this.endpoint = null;
            this.pageSize = options["maxItemCount"];
            if (this.pageSize === undefined) {
                this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;
            }
            // Pick between parallel vs order by execution context
            const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;
            if (Array.isArray(sortOrders) && sortOrders.length > 0) {
                // Need to wrap orderby execution context in endpoint component, since the data is nested as a \
                //      "payload" property.
                this.endpoint = new OrderByEndpointComponent(new OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo));
            }
            else {
                this.endpoint = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo);
            }
            if (Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 ||
                partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||
                partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0) {
                if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {
                    this.endpoint = new GroupByValueEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);
                }
                else {
                    this.endpoint = new GroupByEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);
                }
            }
            // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N
            const top = partitionedQueryExecutionInfo.queryInfo.top;
            if (typeof top === "number") {
                this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);
            }
            // If offset+limit then add that to the pipeline
            const limit = partitionedQueryExecutionInfo.queryInfo.limit;
            const offset = partitionedQueryExecutionInfo.queryInfo.offset;
            if (typeof limit === "number" && typeof offset === "number") {
                this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);
            }
            // If distinct then add that to the pipeline
            const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;
            if (distinctType === "Ordered") {
                this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);
            }
            if (distinctType === "Unordered") {
                this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);
            }
        }
        nextItem() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.endpoint.nextItem();
            });
        }
        // Removed callback here beacuse it wouldn't have ever worked...
        hasMoreResults() {
            return this.endpoint.hasMoreResults();
        }
        fetchMore() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // if the wrapped endpoint has different implementation for fetchMore use that
                // otherwise use the default implementation
                if (typeof this.endpoint.fetchMore === "function") {
                    return this.endpoint.fetchMore();
                }
                else {
                    this.fetchBuffer = [];
                    this.fetchMoreRespHeaders = getInitialHeader();
                    return this._fetchMoreImplementation();
                }
            });
        }
        _fetchMoreImplementation() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const { result: item, headers } = yield this.endpoint.nextItem();
                    mergeHeaders(this.fetchMoreRespHeaders, headers);
                    if (item === undefined) {
                        // no more results
                        if (this.fetchBuffer.length === 0) {
                            return {
                                result: undefined,
                                headers: this.fetchMoreRespHeaders
                            };
                        }
                        else {
                            // Just give what we have
                            const temp = this.fetchBuffer;
                            this.fetchBuffer = [];
                            return { result: temp, headers: this.fetchMoreRespHeaders };
                        }
                    }
                    else {
                        // append the result
                        this.fetchBuffer.push(item);
                        if (this.fetchBuffer.length >= this.pageSize) {
                            // fetched enough results
                            const temp = this.fetchBuffer.slice(0, this.pageSize);
                            this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);
                            return { result: temp, headers: this.fetchMoreRespHeaders };
                        }
                        else {
                            // recursively fetch more
                            // TODO: is recursion a good idea?
                            return this._fetchMoreImplementation();
                        }
                    }
                }
                catch (err) {
                    mergeHeaders(this.fetchMoreRespHeaders, err.headers);
                    err.headers = this.fetchMoreRespHeaders;
                    if (err) {
                        throw err;
                    }
                }
            });
        }
    }
    PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;

    /**
     * Represents a QueryIterator Object, an implementation of feed or query response that enables
     * traversal and iterating over the response
     * in the Azure Cosmos DB database service.
     */
    class QueryIterator {
        /**
         * @hidden
         */
        constructor(clientContext, query, options, fetchFunctions, resourceLink, resourceType) {
            this.clientContext = clientContext;
            this.query = query;
            this.options = options;
            this.fetchFunctions = fetchFunctions;
            this.resourceLink = resourceLink;
            this.resourceType = resourceType;
            this.query = query;
            this.fetchFunctions = fetchFunctions;
            this.options = options || {};
            this.resourceLink = resourceLink;
            this.fetchAllLastResHeaders = getInitialHeader();
            this.reset();
            this.isInitialized = false;
        }
        /**
         * Gets an async iterator that will yield results until completion.
         *
         * NOTE: AsyncIterators are a very new feature and you might need to
         * use polyfils/etc. in order to use them in your code.
         *
         * If you're using TypeScript, you can use the following polyfill as long
         * as you target ES6 or higher and are running on Node 6 or higher.
         *
         * ```typescript
         * if (!Symbol || !Symbol.asyncIterator) {
         *   (Symbol as any).asyncIterator = Symbol.for("Symbol.asyncIterator");
         * }
         * ```
         *
         * @example Iterate over all databases
         * ```typescript
         * for await(const {result: db} in client.databases.readAll().getAsyncIterator()) {
         *   console.log(`Got ${db.id} from AsyncIterator`);
         * }
         * ```
         */
        getAsyncIterator() {
            return tslib.__asyncGenerator(this, arguments, function* getAsyncIterator_1() {
                this.reset();
                this.queryPlanPromise = this.fetchQueryPlan();
                while (this.queryExecutionContext.hasMoreResults()) {
                    let response;
                    try {
                        response = yield tslib.__await(this.queryExecutionContext.fetchMore());
                    }
                    catch (error) {
                        if (this.needsQueryPlan(error)) {
                            yield tslib.__await(this.createPipelinedExecutionContext());
                            try {
                                response = yield tslib.__await(this.queryExecutionContext.fetchMore());
                            }
                            catch (error) {
                                this.handleSplitError(error);
                            }
                        }
                        else {
                            throw error;
                        }
                    }
                    const feedResponse = new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults());
                    if (response.result !== undefined) {
                        yield yield tslib.__await(feedResponse);
                    }
                }
            });
        }
        /**
         * Determine if there are still remaining resources to processs based on the value of the continuation token or the\
         * elements remaining on the current batch in the QueryIterator.
         * @returns {Boolean} true if there is other elements to process in the QueryIterator.
         */
        hasMoreResults() {
            return this.queryExecutionContext.hasMoreResults();
        }
        /**
         * Fetch all pages for the query and return a single FeedResponse.
         */
        fetchAll() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                this.reset();
                this.fetchAllTempResources = [];
                let response;
                try {
                    response = yield this.toArrayImplementation();
                }
                catch (error) {
                    this.handleSplitError(error);
                }
                return response;
            });
        }
        /**
         * Retrieve the next batch from the feed.
         *
         * This may or may not fetch more pages from the backend depending on your settings
         * and the type of query. Aggregate queries will generally fetch all backend pages
         * before returning the first batch of responses.
         */
        fetchNext() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                this.queryPlanPromise = this.fetchQueryPlan();
                if (!this.isInitialized) {
                    yield this.init();
                }
                let response;
                try {
                    response = yield this.queryExecutionContext.fetchMore();
                }
                catch (error) {
                    if (this.needsQueryPlan(error)) {
                        yield this.createPipelinedExecutionContext();
                        try {
                            response = yield this.queryExecutionContext.fetchMore();
                        }
                        catch (error) {
                            this.handleSplitError(error);
                        }
                    }
                    else {
                        throw error;
                    }
                }
                return new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults());
            });
        }
        /**
         * Reset the QueryIterator to the beginning and clear all the resources inside it
         */
        reset() {
            this.queryPlanPromise = undefined;
            this.queryExecutionContext = new DefaultQueryExecutionContext(this.options, this.fetchFunctions);
        }
        toArrayImplementation() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                this.queryPlanPromise = this.fetchQueryPlan();
                if (!this.isInitialized) {
                    yield this.init();
                }
                while (this.queryExecutionContext.hasMoreResults()) {
                    let response;
                    try {
                        response = yield this.queryExecutionContext.nextItem();
                    }
                    catch (error) {
                        if (this.needsQueryPlan(error)) {
                            yield this.createPipelinedExecutionContext();
                            response = yield this.queryExecutionContext.nextItem();
                        }
                        else {
                            throw error;
                        }
                    }
                    const { result, headers } = response;
                    // concatenate the results and fetch more
                    mergeHeaders(this.fetchAllLastResHeaders, headers);
                    if (result !== undefined) {
                        this.fetchAllTempResources.push(result);
                    }
                }
                return new FeedResponse(this.fetchAllTempResources, this.fetchAllLastResHeaders, this.queryExecutionContext.hasMoreResults());
            });
        }
        createPipelinedExecutionContext() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const queryPlanResponse = yield this.queryPlanPromise;
                // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value
                if (queryPlanResponse instanceof Error) {
                    throw queryPlanResponse;
                }
                const queryPlan = queryPlanResponse.result;
                const queryInfo = queryPlan.queryInfo;
                if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {
                    throw new Error("Aggregate queries must use the VALUE keyword");
                }
                this.queryExecutionContext = new PipelinedQueryExecutionContext(this.clientContext, this.resourceLink, this.query, this.options, queryPlan);
            });
        }
        fetchQueryPlan() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {
                    return this.clientContext
                        .getQueryPlan(getPathFromLink(this.resourceLink) + "/docs", ResourceType.item, this.resourceLink, this.query, this.options)
                        .catch((error) => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.
                }
                return this.queryPlanPromise;
            });
        }
        needsQueryPlan(error) {
            return error.code === StatusCodes.BadRequest;
        }
        init() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.isInitialized === true) {
                    return;
                }
                if (this.initPromise === undefined) {
                    this.initPromise = this._init();
                }
                return this.initPromise;
            });
        }
        _init() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {
                    yield this.createPipelinedExecutionContext();
                }
                this.isInitialized = true;
            });
        }
        handleSplitError(err) {
            if (err.code === 410) {
                const error = new Error("Encountered partition split and could not recover. This request is retryable");
                error.code = 503;
                error.originalError = err;
                throw error;
            }
            else {
                throw err;
            }
        }
    }

    class ConflictResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, conflict) {
            super(resource, headers, statusCode);
            this.conflict = conflict;
        }
    }

    /**
     * Use to read or delete a given {@link Conflict} by id.
     *
     * @see {@link Conflicts} to query or read all conflicts.
     */
    class Conflict {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         * @param id The id of the given {@link Conflict}.
         */
        constructor(container, id, clientContext) {
            this.container = container;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return `/${this.container.url}/${Constants.Path.ConflictsPathSegment}/${this.id}`;
        }
        /**
         * Read the {@link ConflictDefinition} for the given {@link Conflict}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url, ResourceType.conflicts);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                return new ConflictResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link ConflictDefinition}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.conflicts,
                    resourceId: id,
                    options
                });
                return new ConflictResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Use to query or read all conflicts.
     *
     * @see {@link Conflict} to read or delete a given {@link Conflict} by id.
     */
    class Conflicts {
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.container.url, ResourceType.conflicts);
            const id = getIdFromLink(this.container.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.conflicts,
                    resourceId: id,
                    resultFn: (result) => result.Conflicts,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Reads all conflicts
         * @param options Use to set options like response page size, continuation tokens, etc.
         */
        readAll(options) {
            return this.query(undefined, options);
        }
    }

    // Copyright (c) Microsoft Corporation.
    (function (ConflictResolutionMode) {
        ConflictResolutionMode["Custom"] = "Custom";
        ConflictResolutionMode["LastWriterWins"] = "LastWriterWins";
    })(exports.ConflictResolutionMode || (exports.ConflictResolutionMode = {}));

    class ItemResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, subsstatusCode, item) {
            super(resource, headers, statusCode, subsstatusCode);
            this.item = item;
        }
    }

    /**
     * Used to perform operations on a specific item.
     *
     * @see {@link Items} for operations on all items; see `container.items`.
     */
    class Item {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         * @param id The id of the given {@link Item}.
         * @param partitionKey The primary key of the given {@link Item} (only for partitioned containers).
         */
        constructor(container, id, partitionKey, clientContext) {
            this.container = container;
            this.id = id;
            this.clientContext = clientContext;
            this.partitionKey = partitionKey;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createDocumentUri(this.container.database.id, this.container.id, this.id);
        }
        /**
         * Read the item's definition.
         *
         * Any provided type, T, is not necessarily enforced by the SDK.
         * You may get more or less properties and it's up to your logic to enforce it.
         * If the type, T, is a class, it won't pass `typeof` comparisons, because it won't have a match prototype.
         * It's recommended to only use interfaces.
         *
         * There is no set schema for JSON items. They may contain any number of custom properties.
         *
         * @param options Additional options for the request, such as the partition key.
         * Note, if you provide a partition key on the options object, it will override the primary key on `this.partitionKey`.
         *
         * @example Using custom type for response
         * ```typescript
         * interface TodoItem {
         *   title: string;
         *   done: bool;
         *   id: string;
         * }
         *
         * let item: TodoItem;
         * ({body: item} = await item.read<TodoItem>());
         * ```
         */
        read(options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.partitionKey === undefined) {
                    const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                    this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                let response;
                try {
                    response = yield this.clientContext.read({
                        path,
                        resourceType: ResourceType.item,
                        resourceId: id,
                        options,
                        partitionKey: this.partitionKey
                    });
                }
                catch (error) {
                    if (error.code !== StatusCodes.NotFound) {
                        throw error;
                    }
                    response = error;
                }
                return new ItemResponse(response.result, response.headers, response.code, response.substatus, this);
            });
        }
        replace(body, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.partitionKey === undefined) {
                    const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                    this.partitionKey = extractPartitionKey(body, partitionKeyDefinition);
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    options,
                    partitionKey: this.partitionKey
                });
                return new ItemResponse(response.result, response.headers, response.code, response.substatus, this);
            });
        }
        /**
         * Delete the item.
         *
         * Any provided type, T, is not necessarily enforced by the SDK.
         * You may get more or less properties and it's up to your logic to enforce it.
         *
         * @param options Additional options for the request, such as the partition key.
         */
        delete(options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (this.partitionKey === undefined) {
                    const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                    this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    options,
                    partitionKey: this.partitionKey
                });
                return new ItemResponse(response.result, response.headers, response.code, response.substatus, this);
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    /**
     * A single response page from the Azure Cosmos DB Change Feed
     */
    class ChangeFeedResponse {
        /**
         * @internal
         * @hidden
         *
         * @param result
         * @param count
         * @param statusCode
         * @param headers
         */
        constructor(
        /**
         * Gets the items returned in the response from Azure Cosmos DB
         */
        result, 
        /**
         * Gets the number of items returned in the response from Azure Cosmos DB
         */
        count, 
        /**
         * Gets the status code of the response from Azure Cosmos DB
         */
        statusCode, headers) {
            this.result = result;
            this.count = count;
            this.statusCode = statusCode;
            this.headers = Object.freeze(headers);
        }
        /**
         * Gets the request charge for this request from the Azure Cosmos DB service.
         */
        get requestCharge() {
            const rus = this.headers[Constants.HttpHeaders.RequestCharge];
            return rus ? parseInt(rus, 10) : null;
        }
        /**
         * Gets the activity ID for the request from the Azure Cosmos DB service.
         */
        get activityId() {
            return this.headers[Constants.HttpHeaders.ActivityId];
        }
        /**
         * Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
         *
         * This is equivalent to the `etag` property.
         */
        get continuation() {
            return this.etag;
        }
        /**
         * Gets the session token for use in session consistency reads from the Azure Cosmos DB service.
         */
        get sessionToken() {
            return this.headers[Constants.HttpHeaders.SessionToken];
        }
        /**
         * Gets the entity tag associated with last transaction in the Azure Cosmos DB service,
         * which can be used as If-Non-Match Access condition for ReadFeed REST request or
         * `continuation` property of `ChangeFeedOptions` parameter for
         * `Items.changeFeed()`
         * to get feed changes since the transaction specified by this entity tag.
         *
         * This is equivalent to the `continuation` property.
         */
        get etag() {
            return this.headers[Constants.HttpHeaders.ETag];
        }
    }

    /**
     * Provides iterator for change feed.
     *
     * Use `Items.changeFeed()` to get an instance of the iterator.
     */
    class ChangeFeedIterator {
        /**
         * @internal
         * @hidden
         *
         * @param clientContext
         * @param resourceId
         * @param resourceLink
         * @param isPartitionedContainer
         * @param changeFeedOptions
         */
        constructor(clientContext, resourceId, resourceLink, partitionKey, changeFeedOptions) {
            this.clientContext = clientContext;
            this.resourceId = resourceId;
            this.resourceLink = resourceLink;
            this.partitionKey = partitionKey;
            this.changeFeedOptions = changeFeedOptions;
            // partition key XOR partition key range id
            const partitionKeyValid = partitionKey !== undefined;
            this.isPartitionSpecified = partitionKeyValid;
            let canUseStartFromBeginning = true;
            if (changeFeedOptions.continuation) {
                this.nextIfNoneMatch = changeFeedOptions.continuation;
                canUseStartFromBeginning = false;
            }
            if (changeFeedOptions.startTime) {
                // .toUTCString() is platform specific, but most platforms use RFC 1123.
                // In ECMAScript 2018, this was standardized to RFC 1123.
                // See for more info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString
                this.ifModifiedSince = changeFeedOptions.startTime.toUTCString();
                canUseStartFromBeginning = false;
            }
            if (canUseStartFromBeginning && !changeFeedOptions.startFromBeginning) {
                this.nextIfNoneMatch = ChangeFeedIterator.IfNoneMatchAllHeaderValue;
            }
        }
        /**
         * Gets a value indicating whether there are potentially additional results that can be retrieved.
         *
         * Initially returns true. This value is set based on whether the last execution returned a continuation token.
         *
         * @returns Boolean value representing if whether there are potentially additional results that can be retrieved.
         */
        get hasMoreResults() {
            return this.lastStatusCode !== StatusCodes.NotModified;
        }
        /**
         * Gets an async iterator which will yield pages of results from Azure Cosmos DB.
         */
        getAsyncIterator() {
            return tslib.__asyncGenerator(this, arguments, function* getAsyncIterator_1() {
                do {
                    const result = yield tslib.__await(this.fetchNext());
                    if (result.count > 0) {
                        yield yield tslib.__await(result);
                    }
                } while (this.hasMoreResults);
            });
        }
        /**
         * Read feed and retrieves the next page of results in Azure Cosmos DB.
         */
        fetchNext() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.getFeedResponse();
                this.lastStatusCode = response.statusCode;
                this.nextIfNoneMatch = response.headers[Constants.HttpHeaders.ETag];
                return response;
            });
        }
        getFeedResponse() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!this.isPartitionSpecified) {
                    throw new Error("Container is partitioned, but no partition key or partition key range id was specified.");
                }
                const feedOptions = { initialHeaders: {}, useIncrementalFeed: true };
                if (typeof this.changeFeedOptions.maxItemCount === "number") {
                    feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;
                }
                if (this.changeFeedOptions.sessionToken) {
                    feedOptions.sessionToken = this.changeFeedOptions.sessionToken;
                }
                if (this.nextIfNoneMatch) {
                    feedOptions.accessCondition = {
                        type: Constants.HttpHeaders.IfNoneMatch,
                        condition: this.nextIfNoneMatch
                    };
                }
                if (this.ifModifiedSince) {
                    feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.ifModifiedSince;
                }
                const response = yield this.clientContext.queryFeed({
                    path: this.resourceLink,
                    resourceType: ResourceType.item,
                    resourceId: this.resourceId,
                    resultFn: (result) => (result ? result.Documents : []),
                    query: undefined,
                    options: feedOptions,
                    partitionKey: this.partitionKey
                }); // TODO: some funky issues with query feed. Probably need to change it up.
                return new ChangeFeedResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers);
            });
        }
    }
    ChangeFeedIterator.IfNoneMatchAllHeaderValue = "*";

    /**
     * @ignore
     * @param options
     */
    function isChangeFeedOptions(options) {
        const optionsType = typeof options;
        return (options && !(optionsType === "string" || optionsType === "boolean" || optionsType === "number"));
    }
    /**
     * Operations for creating new items, and reading/querying all items
     *
     * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.
     */
    class Items {
        /**
         * Create an instance of {@link Items} linked to the parent {@link Container}.
         * @param container The parent container.
         * @hidden
         */
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        query(query, options = {}) {
            const path = getPathFromLink(this.container.url, ResourceType.item);
            const id = getIdFromLink(this.container.url);
            const fetchFunction = (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    resultFn: (result) => (result ? result.Documents : []),
                    query,
                    options: innerOptions,
                    partitionKey: options.partitionKey
                });
            };
            return new QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url, ResourceType.item);
        }
        readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
            if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
                return this.changeFeed(partitionKeyOrChangeFeedOptions);
            }
            else {
                return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);
            }
        }
        changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
            let partitionKey;
            if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
                partitionKey = undefined;
                changeFeedOptions = partitionKeyOrChangeFeedOptions;
            }
            else if (partitionKeyOrChangeFeedOptions !== undefined &&
                !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
                partitionKey = partitionKeyOrChangeFeedOptions;
            }
            if (!changeFeedOptions) {
                changeFeedOptions = {};
            }
            const path = getPathFromLink(this.container.url, ResourceType.item);
            const id = getIdFromLink(this.container.url);
            return new ChangeFeedIterator(this.clientContext, id, path, partitionKey, changeFeedOptions);
        }
        readAll(options) {
            return this.query("SELECT * from c", options);
        }
        /**
         * Create an item.
         *
         * Any provided type, T, is not necessarily enforced by the SDK.
         * You may get more or less properties and it's up to your logic to enforce it.
         *
         * There is no set schema for JSON items. They may contain any number of custom properties.
         *
         * @param body Represents the body of the item. Can contain any number of user defined properties.
         * @param options Used for modifying the request (for instance, specifying the partition key).
         */
        create(body, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                const partitionKey = extractPartitionKey(body, partitionKeyDefinition);
                // Generate random document id if the id is missing in the payload and
                // options.disableAutomaticIdGeneration != true
                if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                    body.id = uuid();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.container.url, ResourceType.item);
                const id = getIdFromLink(this.container.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    options,
                    partitionKey
                });
                const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);
                return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);
            });
        }
        upsert(body, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                const partitionKey = extractPartitionKey(body, partitionKeyDefinition);
                // Generate random document id if the id is missing in the payload and
                // options.disableAutomaticIdGeneration != true
                if ((body.id === undefined || body.id === "") && !options.disableAutomaticIdGeneration) {
                    body.id = uuid();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.container.url, ResourceType.item);
                const id = getIdFromLink(this.container.url);
                const response = yield this.clientContext.upsert({
                    body,
                    path,
                    resourceType: ResourceType.item,
                    resourceId: id,
                    options,
                    partitionKey
                });
                const ref = new Item(this.container, response.result.id, partitionKey, this.clientContext);
                return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref);
            });
        }
    }

    class StoredProcedureResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, storedProcedure) {
            super(resource, headers, statusCode);
            this.storedProcedure = storedProcedure;
        }
        /**
         * Alias for storedProcedure.
         *
         * A reference to the {@link StoredProcedure} which the {@link StoredProcedureDefinition} corresponds to.
         */
        get sproc() {
            return this.storedProcedure;
        }
    }

    /**
     * Operations for reading, replacing, deleting, or executing a specific, existing stored procedure by id.
     *
     * For operations to create, upsert, read all, or query Stored Procedures,
     */
    class StoredProcedure {
        /**
         * Creates a new instance of {@link StoredProcedure} linked to the parent {@link Container}.
         * @param container The parent {@link Container}.
         * @param id The id of the given {@link StoredProcedure}.
         * @hidden
         */
        constructor(container, id, clientContext) {
            this.container = container;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createStoredProcedureUri(this.container.database.id, this.container.id, this.id);
        }
        /**
         * Read the {@link StoredProcedureDefinition} for the given {@link StoredProcedure}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.sproc,
                    resourceId: id,
                    options
                });
                return new StoredProcedureResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link StoredProcedure} with the specified {@link StoredProcedureDefinition}.
         * @param body The specified {@link StoredProcedureDefinition} to replace the existing definition.
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.sproc,
                    resourceId: id,
                    options
                });
                return new StoredProcedureResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link StoredProcedure}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.sproc,
                    resourceId: id,
                    options
                });
                return new StoredProcedureResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Execute the given {@link StoredProcedure}.
         *
         * The specified type, T, is not enforced by the client.
         * Be sure to validate the response from the stored procedure matches the type, T, you provide.
         *
         * @param partitionKey The partition key to use when executing the stored procedure
         * @param params Array of parameters to pass as arguments to the given {@link StoredProcedure}.
         * @param options Additional options, such as the partition key to invoke the {@link StoredProcedure} on.
         */
        execute(partitionKey, params, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (partitionKey === undefined) {
                    const { resource: partitionKeyDefinition } = yield this.container.readPartitionKeyDefinition();
                    partitionKey = undefinedPartitionKey(partitionKeyDefinition);
                }
                const response = yield this.clientContext.execute({
                    sprocLink: this.url,
                    params,
                    options,
                    partitionKey
                });
                return new ResourceResponse(response.result, response.headers, response.code);
            });
        }
    }

    /**
     * Operations for creating, upserting, or reading/querying all Stored Procedures.
     *
     * For operations to read, replace, delete, or execute a specific, existing stored procedure by id, see `container.storedProcedure()`.
     */
    class StoredProcedures {
        /**
         * @param container The parent {@link Container}.
         * @hidden
         */
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.container.url, ResourceType.sproc);
            const id = getIdFromLink(this.container.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.sproc,
                    resourceId: id,
                    resultFn: (result) => result.StoredProcedures,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all stored procedures.
         * @param options
         * @example Read all stored procedures to array.
         * ```typescript
         * const {body: sprocList} = await containers.storedProcedures.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
        /**
         * Create a StoredProcedure.
         *
         * Azure Cosmos DB allows stored procedures to be executed in the storage tier,
         * directly against an item container. The script
         * gets executed under ACID transactions on the primary storage partition of the
         * specified container. For additional details,
         * refer to the server-side JavaScript API documentation.
         */
        create(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.container.url, ResourceType.sproc);
                const id = getIdFromLink(this.container.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.sproc,
                    resourceId: id,
                    options
                });
                const ref = new StoredProcedure(this.container, response.result.id, this.clientContext);
                return new StoredProcedureResponse(response.result, response.headers, response.code, ref);
            });
        }
    }

    class TriggerResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, trigger) {
            super(resource, headers, statusCode);
            this.trigger = trigger;
        }
    }

    /**
     * Operations to read, replace, or delete a {@link Trigger}.
     *
     * Use `container.triggers` to create, upsert, query, or read all.
     */
    class Trigger {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         * @param id The id of the given {@link Trigger}.
         */
        constructor(container, id, clientContext) {
            this.container = container;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createTriggerUri(this.container.database.id, this.container.id, this.id);
        }
        /**
         * Read the {@link TriggerDefinition} for the given {@link Trigger}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.trigger,
                    resourceId: id,
                    options
                });
                return new TriggerResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link Trigger} with the specified {@link TriggerDefinition}.
         * @param body The specified {@link TriggerDefinition} to replace the existing definition with.
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.trigger,
                    resourceId: id,
                    options
                });
                return new TriggerResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link Trigger}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.trigger,
                    resourceId: id,
                    options
                });
                return new TriggerResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Operations to create, upsert, query, and read all triggers.
     *
     * Use `container.triggers` to read, replace, or delete a {@link Trigger}.
     */
    class Triggers {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         */
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.container.url, ResourceType.trigger);
            const id = getIdFromLink(this.container.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.trigger,
                    resourceId: id,
                    resultFn: (result) => result.Triggers,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all Triggers.
         * @param options
         * @example Read all trigger to array.
         * ```typescript
         * const {body: triggerList} = await container.triggers.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
        /**
         * Create a trigger.
         *
         * Azure Cosmos DB supports pre and post triggers defined in JavaScript to be executed
         * on creates, updates and deletes.
         *
         * For additional details, refer to the server-side JavaScript API documentation.
         * @param body
         * @param options
         */
        create(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.container.url, ResourceType.trigger);
                const id = getIdFromLink(this.container.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.trigger,
                    resourceId: id,
                    options
                });
                const ref = new Trigger(this.container, response.result.id, this.clientContext);
                return new TriggerResponse(response.result, response.headers, response.code, ref);
            });
        }
    }

    class UserDefinedFunctionResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, udf) {
            super(resource, headers, statusCode);
            this.userDefinedFunction = udf;
        }
        /**
         * Alias for `userDefinedFunction(id).
         *
         * A reference to the {@link UserDefinedFunction} corresponding to the returned {@link UserDefinedFunctionDefinition}.
         */
        get udf() {
            return this.userDefinedFunction;
        }
    }

    /**
     * Used to read, replace, or delete a specified User Definied Function by id.
     *
     * @see {@link UserDefinedFunction} to create, upsert, query, read all User Defined Functions.
     */
    class UserDefinedFunction {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         * @param id The id of the given {@link UserDefinedFunction}.
         */
        constructor(container, id, clientContext) {
            this.container = container;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createUserDefinedFunctionUri(this.container.database.id, this.container.id, this.id);
        }
        /**
         * Read the {@link UserDefinedFunctionDefinition} for the given {@link UserDefinedFunction}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.udf,
                    resourceId: id,
                    options
                });
                return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link UserDefinedFunction} with the specified {@link UserDefinedFunctionDefinition}.
         * @param body The specified {@link UserDefinedFunctionDefinition}.
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.udf,
                    resourceId: id,
                    options
                });
                return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link UserDefined}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.udf,
                    resourceId: id,
                    options
                });
                return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Used to create, upsert, query, or read all User Defined Functions.
     *
     * @see {@link UserDefinedFunction} to read, replace, or delete a given User Defined Function by id.
     */
    class UserDefinedFunctions {
        /**
         * @hidden
         * @param container The parent {@link Container}.
         */
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.container.url, ResourceType.udf);
            const id = getIdFromLink(this.container.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.udf,
                    resourceId: id,
                    resultFn: (result) => result.UserDefinedFunctions,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all User Defined Functions.
         * @param options
         * @example Read all User Defined Functions to array.
         * ```typescript
         * const {body: udfList} = await container.userDefinedFunctions.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
        /**
         * Create a UserDefinedFunction.
         *
         * Azure Cosmos DB supports JavaScript UDFs which can be used inside queries, stored procedures and triggers.
         *
         * For additional details, refer to the server-side JavaScript API documentation.
         *
         */
        create(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (body.body) {
                    body.body = body.body.toString();
                }
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.container.url, ResourceType.udf);
                const id = getIdFromLink(this.container.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.udf,
                    resourceId: id,
                    options
                });
                const ref = new UserDefinedFunction(this.container, response.result.id, this.clientContext);
                return new UserDefinedFunctionResponse(response.result, response.headers, response.code, ref);
            });
        }
    }

    // Copyright (c) Microsoft Corporation.
    class Scripts {
        /**
         * @param container The parent {@link Container}.
         * @hidden
         */
        constructor(container, clientContext) {
            this.container = container;
            this.clientContext = clientContext;
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link StoredProcedure} by id.
         *
         * Use `.storedProcedures` for creating new stored procedures, or querying/reading all stored procedures.
         * @param id The id of the {@link StoredProcedure}.
         */
        storedProcedure(id) {
            return new StoredProcedure(this.container, id, this.clientContext);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link Trigger} by id.
         *
         * Use `.triggers` for creating new triggers, or querying/reading all triggers.
         * @param id The id of the {@link Trigger}.
         */
        trigger(id) {
            return new Trigger(this.container, id, this.clientContext);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link UserDefinedFunction} by id.
         *
         * Use `.userDefinedFunctions` for creating new user defined functions, or querying/reading all user defined functions.
         * @param id The id of the {@link UserDefinedFunction}.
         */
        userDefinedFunction(id) {
            return new UserDefinedFunction(this.container, id, this.clientContext);
        }
        /**
         * Operations for creating new stored procedures, and reading/querying all stored procedures.
         *
         * For reading, replacing, or deleting an existing stored procedure, use `.storedProcedure(id)`.
         */
        get storedProcedures() {
            if (!this.$sprocs) {
                this.$sprocs = new StoredProcedures(this.container, this.clientContext);
            }
            return this.$sprocs;
        }
        /**
         * Operations for creating new triggers, and reading/querying all triggers.
         *
         * For reading, replacing, or deleting an existing trigger, use `.trigger(id)`.
         */
        get triggers() {
            if (!this.$triggers) {
                this.$triggers = new Triggers(this.container, this.clientContext);
            }
            return this.$triggers;
        }
        /**
         * Operations for creating new user defined functions, and reading/querying all user defined functions.
         *
         * For reading, replacing, or deleting an existing user defined function, use `.userDefinedFunction(id)`.
         */
        get userDefinedFunctions() {
            if (!this.$udfs) {
                this.$udfs = new UserDefinedFunctions(this.container, this.clientContext);
            }
            return this.$udfs;
        }
    }

    /** Response object for Container operations */
    class ContainerResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, container) {
            super(resource, headers, statusCode);
            this.container = container;
        }
    }

    /**
     * Operations for reading, replacing, or deleting a specific, existing container by id.
     *
     * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.
     *
     * Note: all these operations make calls against a fixed budget.
     * You should design your system such that these calls scale sublinearly with your application.
     * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;
     * do this once on application start up.
     */
    class Container {
        /**
         * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.
         * @param database The parent {@link Database}.
         * @param id The id of the given container.
         * @hidden
         */
        constructor(database, id, clientContext) {
            this.database = database;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Operations for creating new items, and reading/querying all items
         *
         * For reading, replacing, or deleting an existing item, use `.item(id)`.
         *
         * @example Create a new item
         * ```typescript
         * const {body: createdItem} = await container.items.create({id: "<item id>", properties: {}});
         * ```
         */
        get items() {
            if (!this.$items) {
                this.$items = new Items(this, this.clientContext);
            }
            return this.$items;
        }
        /**
         * All operations for Stored Procedures, Triggers, and User Defined Functions
         */
        get scripts() {
            if (!this.$scripts) {
                this.$scripts = new Scripts(this, this.clientContext);
            }
            return this.$scripts;
        }
        /**
         * Opertaions for reading and querying conflicts for the given container.
         *
         * For reading or deleting a specific conflict, use `.conflict(id)`.
         */
        get conflicts() {
            if (!this.$conflicts) {
                this.$conflicts = new Conflicts(this, this.clientContext);
            }
            return this.$conflicts;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createDocumentCollectionUri(this.database.id, this.id);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link Item} by id.
         *
         * Use `.items` for creating new items, or querying/reading all items.
         *
         * @param id The id of the {@link Item}.
         * @param partitionKeyValue The value of the {@link Item} partition key
         * @example Replace an item
         * const {body: replacedItem} = await container.item("<item id>", "<partition key value>").replace({id: "<item id>", title: "Updated post", authorID: 5});
         */
        item(id, partitionKeyValue) {
            return new Item(this, id, partitionKeyValue, this.clientContext);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link Conflict} by id.
         *
         * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.
         * @param id The id of the {@link Conflict}.
         */
        conflict(id) {
            return new Conflict(this, id, this.clientContext);
        }
        /** Read the container's definition */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.container,
                    resourceId: id,
                    options
                });
                this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;
                return new ContainerResponse(response.result, response.headers, response.code, this);
            });
        }
        /** Replace the container's definition */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.container,
                    resourceId: id,
                    options
                });
                return new ContainerResponse(response.result, response.headers, response.code, this);
            });
        }
        /** Delete the container */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.container,
                    resourceId: id,
                    options
                });
                return new ContainerResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
         * @deprecated This method has been renamed to readPartitionKeyDefinition.
         * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.
         * @param {function} callback       - \
         * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers
         */
        getPartitionKeyDefinition() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.readPartitionKeyDefinition();
            });
        }
        /**
         * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
         * @ignore
         * @param {string} collectionLink   - Link to the collection whose partition key needs to be extracted.
         * @param {function} callback       - \
         * The arguments to the callback are(in order): error, partitionKeyDefinition, response object and response headers
         */
        readPartitionKeyDefinition() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key
                // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary
                if (this.url in this.clientContext.partitionKeyDefinitionCache) {
                    return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], {}, 0);
                }
                const { headers, statusCode } = yield this.read();
                return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], headers, statusCode);
            });
        }
        getQueryPlan(query) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                return this.clientContext.getQueryPlan(path + "/docs", ResourceType.item, getIdFromLink(this.url), query);
            });
        }
        readPartitionKeyRanges(feedOptions) {
            feedOptions = feedOptions || {};
            return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);
        }
    }

    /**
     * Operations for creating new containers, and reading/querying all containers
     *
     * @see {@link Container} for reading, replacing, or deleting an existing container; use `.container(id)`.
     *
     * Note: all these operations make calls against a fixed budget.
     * You should design your system such that these calls scale sublinearly with your application.
     * For instance, do not call `containers.readAll()` before every single `item.read()` call, to ensure the container exists;
     * do this once on application start up.
     */
    class Containers {
        constructor(database, clientContext) {
            this.database = database;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.database.url, ResourceType.container);
            const id = getIdFromLink(this.database.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.container,
                    resourceId: id,
                    resultFn: (result) => result.DocumentCollections,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Creates a container.
         *
         * A container is a named logical container for items.
         *
         * A database may contain zero or more named containers and each container consists of
         * zero or more JSON items.
         *
         * Being schema-free, the items in a container do not need to share the same structure or fields.
         *
         *
         * Since containers are application resources, they can be authorized using either the
         * master key or resource keys.
         *
         * @param body Represents the body of the container.
         * @param options Use to set options like response page size, continuation tokens, etc.
         */
        create(body, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.database.url, ResourceType.container);
                const id = getIdFromLink(this.database.url);
                if (body.throughput) {
                    options.initialHeaders = Object.assign({}, options.initialHeaders, {
                        [Constants.HttpHeaders.OfferThroughput]: body.throughput
                    });
                    delete body.throughput;
                }
                // If they don't specify a partition key, use the default path
                if (!body.partitionKey || !body.partitionKey.paths) {
                    body.partitionKey = {
                        paths: [DEFAULT_PARTITION_KEY_PATH]
                    };
                }
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.container,
                    resourceId: id,
                    options
                });
                const ref = new Container(this.database, response.result.id, this.clientContext);
                return new ContainerResponse(response.result, response.headers, response.code, ref);
            });
        }
        /**
         * Checks if a Container exists, and, if it doesn't, creates it.
         * This will make a read operation based on the id in the `body`, then if it is not found, a create operation.
         * You should confirm that the output matches the body you passed in for non-default properties (i.e. indexing policy/etc.)
         *
         * A container is a named logical container for items.
         *
         * A database may contain zero or more named containers and each container consists of
         * zero or more JSON items.
         *
         * Being schema-free, the items in a container do not need to share the same structure or fields.
         *
         *
         * Since containers are application resources, they can be authorized using either the
         * master key or resource keys.
         *
         * @param body Represents the body of the container.
         * @param options Use to set options like response page size, continuation tokens, etc.
         */
        createIfNotExists(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!body || body.id === null || body.id === undefined) {
                    throw new Error("body parameter must be an object with an id property");
                }
                /*
                  1. Attempt to read the Database (based on an assumption that most databases will already exist, so its faster)
                  2. If it fails with NotFound error, attempt to create the db. Else, return the read results.
                */
                try {
                    const readResponse = yield this.database.container(body.id).read(options);
                    return readResponse;
                }
                catch (err) {
                    if (err.code === StatusCodes.NotFound) {
                        const createResponse = yield this.create(body, options);
                        // Must merge the headers to capture RU costskaty
                        mergeHeaders(createResponse.headers, err.headers);
                        return createResponse;
                    }
                    else {
                        throw err;
                    }
                }
            });
        }
        /**
         * Read all containers.
         * @param options Use to set options like response page size, continuation tokens, etc.
         * @returns {@link QueryIterator} Allows you to return all containers in an array or iterate over them one at a time.
         * @example Read all containers to array.
         * ```typescript
         * const {body: containerList} = await client.database("<db id>").containers.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
    }

    class PermissionResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, permission) {
            super(resource, headers, statusCode);
            this.permission = permission;
        }
    }

    /**
     * Use to read, replace, or delete a given {@link Permission} by id.
     *
     * @see {@link Permissions} to create, upsert, query, or read all Permissions.
     */
    class Permission {
        /**
         * @hidden
         * @param user The parent {@link User}.
         * @param id The id of the given {@link Permission}.
         */
        constructor(user, id, clientContext) {
            this.user = user;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createPermissionUri(this.user.database.id, this.user.id, this.id);
        }
        /**
         * Read the {@link PermissionDefinition} of the given {@link Permission}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    options
                });
                return new PermissionResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link Permission} with the specified {@link PermissionDefinition}.
         * @param body The specified {@link PermissionDefinition}.
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    options
                });
                return new PermissionResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link Permission}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    options
                });
                return new PermissionResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Use to create, replace, query, and read all Permissions.
     *
     * @see {@link Permission} to read, replace, or delete a specific permission by id.
     */
    class Permissions {
        /**
         * @hidden
         * @param user The parent {@link User}.
         */
        constructor(user, clientContext) {
            this.user = user;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.user.url, ResourceType.permission);
            const id = getIdFromLink(this.user.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    resultFn: (result) => result.Permissions,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all permissions.
         * @param options
         * @example Read all permissions to array.
         * ```typescript
         * const {body: permissionList} = await user.permissions.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
        /**
         * Create a permission.
         *
         * A permission represents a per-User Permission to access a specific resource
         * e.g. Item or Container.
         * @param body Represents the body of the permission.
         */
        create(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.user.url, ResourceType.permission);
                const id = getIdFromLink(this.user.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    options
                });
                const ref = new Permission(this.user, response.result.id, this.clientContext);
                return new PermissionResponse(response.result, response.headers, response.code, ref);
            });
        }
        /**
         * Upsert a permission.
         *
         * A permission represents a per-User Permission to access a
         * specific resource e.g. Item or Container.
         */
        upsert(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.user.url, ResourceType.permission);
                const id = getIdFromLink(this.user.url);
                const response = yield this.clientContext.upsert({
                    body,
                    path,
                    resourceType: ResourceType.permission,
                    resourceId: id,
                    options
                });
                const ref = new Permission(this.user, response.result.id, this.clientContext);
                return new PermissionResponse(response.result, response.headers, response.code, ref);
            });
        }
    }

    class UserResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, user) {
            super(resource, headers, statusCode);
            this.user = user;
        }
    }

    /**
     * Used to read, replace, and delete Users.
     *
     * Additionally, you can access the permissions for a given user via `user.permission` and `user.permissions`.
     *
     * @see {@link Users} to create, upsert, query, or read all.
     */
    class User {
        /**
         * @hidden
         * @param database The parent {@link Database}.
         * @param id
         */
        constructor(database, id, clientContext) {
            this.database = database;
            this.id = id;
            this.clientContext = clientContext;
            this.permissions = new Permissions(this, this.clientContext);
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createUserUri(this.database.id, this.id);
        }
        /**
         * Operations to read, replace, or delete a specific Permission by id.
         *
         * See `client.permissions` for creating, upserting, querying, or reading all operations.
         * @param id
         */
        permission(id) {
            return new Permission(this, id, this.clientContext);
        }
        /**
         * Read the {@link UserDefinition} for the given {@link User}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                return new UserResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link User}'s definition with the specified {@link UserDefinition}.
         * @param body The specified {@link UserDefinition} to replace the definition.
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.replace({
                    body,
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                return new UserResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Delete the given {@link User}.
         * @param options
         */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                return new UserResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Used to create, upsert, query, and read all users.
     *
     * @see {@link User} to read, replace, or delete a specific User by id.
     */
    class Users {
        /**
         * @hidden
         * @param database The parent {@link Database}.
         */
        constructor(database, clientContext) {
            this.database = database;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const path = getPathFromLink(this.database.url, ResourceType.user);
            const id = getIdFromLink(this.database.url);
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    resultFn: (result) => result.Users,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all users.
         * @param options
         * @example Read all users to array.
         * ```typescript
         * const {body: usersList} = await database.users.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
        /**
         * Create a database user with the specified {@link UserDefinition}.
         * @param body The specified {@link UserDefinition}.
         * @param options
         */
        create(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.database.url, ResourceType.user);
                const id = getIdFromLink(this.database.url);
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                const ref = new User(this.database, response.result.id, this.clientContext);
                return new UserResponse(response.result, response.headers, response.code, ref);
            });
        }
        /**
         * Upsert a database user with a specified {@link UserDefinition}.
         * @param body The specified {@link UserDefinition}.
         * @param options
         */
        upsert(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const path = getPathFromLink(this.database.url, ResourceType.user);
                const id = getIdFromLink(this.database.url);
                const response = yield this.clientContext.upsert({
                    body,
                    path,
                    resourceType: ResourceType.user,
                    resourceId: id,
                    options
                });
                const ref = new User(this.database, response.result.id, this.clientContext);
                return new UserResponse(response.result, response.headers, response.code, ref);
            });
        }
    }

    /** Response object for Database operations */
    class DatabaseResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, database) {
            super(resource, headers, statusCode);
            this.database = database;
        }
    }

    /**
     * Operations for reading or deleting an existing database.
     *
     * @see {@link Databases} for creating new databases, and reading/querying all databases; use `client.databases`.
     *
     * Note: all these operations make calls against a fixed budget.
     * You should design your system such that these calls scale sublinearly with your application.
     * For instance, do not call `database.read()` before every single `item.read()` call, to ensure the database exists;
     * do this once on application start up.
     */
    class Database {
        /** Returns a new {@link Database} instance.
         *
         * Note: the intention is to get this object from {@link CosmosClient} via `client.database(id)`, not to instantiate it yourself.
         */
        constructor(client, id, clientContext) {
            this.client = client;
            this.id = id;
            this.clientContext = clientContext;
            this.containers = new Containers(this, this.clientContext);
            this.users = new Users(this, this.clientContext);
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return createDatabaseUri(this.id);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link Database} by id.
         *
         * Use `.containers` creating new containers, or querying/reading all containers.
         *
         * @example Delete a container
         * ```typescript
         * await client.database("<db id>").container("<container id>").delete();
         * ```
         */
        container(id) {
            return new Container(this, id, this.clientContext);
        }
        /**
         * Used to read, replace, or delete a specific, existing {@link User} by id.
         *
         * Use `.users` for creating new users, or querying/reading all users.
         */
        user(id) {
            return new User(this, id, this.clientContext);
        }
        /** Read the definition of the given Database. */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.read({
                    path,
                    resourceType: ResourceType.database,
                    resourceId: id,
                    options
                });
                return new DatabaseResponse(response.result, response.headers, response.code, this);
            });
        }
        /** Delete the given Database. */
        delete(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const path = getPathFromLink(this.url);
                const id = getIdFromLink(this.url);
                const response = yield this.clientContext.delete({
                    path,
                    resourceType: ResourceType.database,
                    resourceId: id,
                    options
                });
                return new DatabaseResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Operations for creating new databases, and reading/querying all databases
     *
     * @see {@link Database} for reading or deleting an existing database; use `client.database(id)`.
     *
     * Note: all these operations make calls against a fixed budget.
     * You should design your system such that these calls scale sublinearly with your application.
     * For instance, do not call `databases.readAll()` before every single `item.read()` call, to ensure the database exists;
     * do this once on application start up.
     */
    class Databases {
        /**
         * @hidden
         * @param client The parent {@link CosmosClient} for the Database.
         */
        constructor(client, clientContext) {
            this.client = client;
            this.clientContext = clientContext;
        }
        query(query, options) {
            const cb = (innerOptions) => {
                return this.clientContext.queryFeed({
                    path: "/dbs",
                    resourceType: ResourceType.database,
                    resourceId: "",
                    resultFn: (result) => result.Databases,
                    query,
                    options: innerOptions
                });
            };
            return new QueryIterator(this.clientContext, query, options, cb);
        }
        /**
         * Send a request for creating a database.
         *
         * A database manages users, permissions and a set of containers.
         * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
         * with the database being the logical container for data.
         *
         * Each Database consists of one or more containers, each of which in turn contain one or more
         * documents. Since databases are an administrative resource, the Service Master Key will be
         * required in order to access and successfully complete any action using the User APIs.
         *
         * @param body The {@link DatabaseDefinition} that represents the {@link Database} to be created.
         * @param options Use to set options like response page size, continuation tokens, etc.
         */
        create(body, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                if (body.throughput) {
                    options.initialHeaders = Object.assign({}, options.initialHeaders, {
                        [Constants.HttpHeaders.OfferThroughput]: body.throughput
                    });
                    delete body.throughput;
                }
                const path = "/dbs"; // TODO: constant
                const response = yield this.clientContext.create({
                    body,
                    path,
                    resourceType: ResourceType.database,
                    resourceId: undefined,
                    options
                });
                const ref = new Database(this.client, body.id, this.clientContext);
                return new DatabaseResponse(response.result, response.headers, response.code, ref);
            });
        }
        /**
         * Check if a database exists, and if it doesn't, create it.
         * This will make a read operation based on the id in the `body`, then if it is not found, a create operation.
         *
         * A database manages users, permissions and a set of containers.
         * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
         * with the database being the logical container for data.
         *
         * Each Database consists of one or more containers, each of which in turn contain one or more
         * documents. Since databases are an an administrative resource, the Service Master Key will be
         * required in order to access and successfully complete any action using the User APIs.
         *
         * @param body The {@link DatabaseDefinition} that represents the {@link Database} to be created.
         * @param options
         */
        createIfNotExists(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!body || body.id === null || body.id === undefined) {
                    throw new Error("body parameter must be an object with an id property");
                }
                /*
                  1. Attempt to read the Database (based on an assumption that most databases will already exist, so its faster)
                  2. If it fails with NotFound error, attempt to create the db. Else, return the read results.
                */
                try {
                    const readResponse = yield this.client.database(body.id).read(options);
                    return readResponse;
                }
                catch (err) {
                    if (err.code === StatusCodes.NotFound) {
                        const createResponse = yield this.create(body, options);
                        // Must merge the headers to capture RU costskaty
                        mergeHeaders(createResponse.headers, err.headers);
                        return createResponse;
                    }
                    else {
                        throw err;
                    }
                }
            });
        }
        // TODO: DatabaseResponse for QueryIterator?
        /**
         * Reads all databases.
         * @param options Use to set options like response page size, continuation tokens, etc.
         * @returns {@link QueryIterator} Allows you to return all databases in an array or iterate over them one at a time.
         * @example Read all databases to array.
         * ```typescript
         * const {body: databaseList} = await client.databases.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
    }

    class OfferResponse extends ResourceResponse {
        constructor(resource, headers, statusCode, offer) {
            super(resource, headers, statusCode);
            this.offer = offer;
        }
    }

    /**
     * Use to read or replace an existing {@link Offer} by id.
     *
     * @see {@link Offers} to query or read all offers.
     */
    class Offer {
        /**
         * @hidden
         * @param client The parent {@link CosmosClient} for the Database Account.
         * @param id The id of the given {@link Offer}.
         */
        constructor(client, id, clientContext) {
            this.client = client;
            this.id = id;
            this.clientContext = clientContext;
        }
        /**
         * Returns a reference URL to the resource. Used for linking in Permissions.
         */
        get url() {
            return `/${Constants.Path.OffersPathSegment}/${this.id}`;
        }
        /**
         * Read the {@link OfferDefinition} for the given {@link Offer}.
         * @param options
         */
        read(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.clientContext.read({
                    path: this.url,
                    resourceType: ResourceType.offer,
                    resourceId: this.id,
                    options
                });
                return new OfferResponse(response.result, response.headers, response.code, this);
            });
        }
        /**
         * Replace the given {@link Offer} with the specified {@link OfferDefinition}.
         * @param body The specified {@link OfferDefinition}
         * @param options
         */
        replace(body, options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const err = {};
                if (!isResourceValid(body, err)) {
                    throw err;
                }
                const response = yield this.clientContext.replace({
                    body,
                    path: this.url,
                    resourceType: ResourceType.offer,
                    resourceId: this.id,
                    options
                });
                return new OfferResponse(response.result, response.headers, response.code, this);
            });
        }
    }

    /**
     * Use to query or read all Offers.
     *
     * @see {@link Offer} to read or replace an existing {@link Offer} by id.
     */
    class Offers {
        /**
         * @hidden
         * @param client The parent {@link CosmosClient} for the offers.
         */
        constructor(client, clientContext) {
            this.client = client;
            this.clientContext = clientContext;
        }
        query(query, options) {
            return new QueryIterator(this.clientContext, query, options, (innerOptions) => {
                return this.clientContext.queryFeed({
                    path: "/offers",
                    resourceType: ResourceType.offer,
                    resourceId: "",
                    resultFn: (result) => result.Offers,
                    query,
                    options: innerOptions
                });
            });
        }
        /**
         * Read all offers.
         * @param options
         * @example Read all offers to array.
         * ```typescript
         * const {body: offerList} = await client.offers.readAll().fetchAll();
         * ```
         */
        readAll(options) {
            return this.query(undefined, options);
        }
    }

    (function (PluginOn) {
        /**
         * Will be executed per network request
         */
        PluginOn["request"] = "request";
        /**
         * Will be executed per API operation
         */
        PluginOn["operation"] = "operation";
    })(exports.PluginOn || (exports.PluginOn = {}));
    /**
     * @internal
     * @hidden
     * @ignore
     * @param requestContext
     * @param next
     * @param on
     */
    function executePlugins(requestContext, next, on) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!requestContext.plugins) {
                return next(requestContext, undefined);
            }
            let level = 0;
            const _ = (inner) => {
                if (++level >= inner.plugins.length) {
                    return next(requestContext, undefined);
                }
                else if (inner.plugins[level].on !== on) {
                    return _(requestContext);
                }
                else {
                    return inner.plugins[level].plugin(inner, _);
                }
            };
            if (requestContext.plugins[level].on !== on) {
                return _(requestContext);
            }
            else {
                return requestContext.plugins[level].plugin(requestContext, _);
            }
        });
    }

    // ----------------------------------------------------------------------------
    // Utility methods
    //
    /** @hidden */
    function javaScriptFriendlyJSONStringify(s) {
        // two line terminators (Line separator and Paragraph separator) are not needed to be escaped in JSON
        // but are needed to be escaped in JavaScript.
        return JSON.stringify(s)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029");
    }
    /** @hidden */
    function bodyFromData(data) {
        if (typeof data === "object") {
            return javaScriptFriendlyJSONStringify(data);
        }
        return data;
    }
    const JsonContentType = "application/json";
    /**
     * @ignore
     * @param param0
     */
    function getHeaders({ clientOptions, defaultHeaders, verb, path, resourceId, resourceType, options = {}, partitionKeyRangeId, useMultipleWriteLocations, partitionKey }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const headers = Object.assign({ [Constants.HttpHeaders.ResponseContinuationTokenLimitInKB]: 1, [Constants.HttpHeaders.EnableCrossPartitionQuery]: true }, defaultHeaders);
            if (useMultipleWriteLocations) {
                headers[Constants.HttpHeaders.ALLOW_MULTIPLE_WRITES] = true;
            }
            if (options.continuationTokenLimitInKB) {
                headers[Constants.HttpHeaders.ResponseContinuationTokenLimitInKB] =
                    options.continuationTokenLimitInKB;
            }
            if (options.continuationToken) {
                headers[Constants.HttpHeaders.Continuation] = options.continuationToken;
            }
            else if (options.continuation) {
                headers[Constants.HttpHeaders.Continuation] = options.continuation;
            }
            if (options.preTriggerInclude) {
                headers[Constants.HttpHeaders.PreTriggerInclude] =
                    options.preTriggerInclude.constructor === Array
                        ? options.preTriggerInclude.join(",")
                        : options.preTriggerInclude;
            }
            if (options.postTriggerInclude) {
                headers[Constants.HttpHeaders.PostTriggerInclude] =
                    options.postTriggerInclude.constructor === Array
                        ? options.postTriggerInclude.join(",")
                        : options.postTriggerInclude;
            }
            if (options.offerType) {
                headers[Constants.HttpHeaders.OfferType] = options.offerType;
            }
            if (options.offerThroughput) {
                headers[Constants.HttpHeaders.OfferThroughput] = options.offerThroughput;
            }
            if (options.maxItemCount) {
                headers[Constants.HttpHeaders.PageSize] = options.maxItemCount;
            }
            if (options.accessCondition) {
                if (options.accessCondition.type === "IfMatch") {
                    headers[Constants.HttpHeaders.IfMatch] = options.accessCondition.condition;
                }
                else {
                    headers[Constants.HttpHeaders.IfNoneMatch] = options.accessCondition.condition;
                }
            }
            if (options.useIncrementalFeed) {
                headers[Constants.HttpHeaders.A_IM] = "Incremental Feed";
            }
            if (options.indexingDirective) {
                headers[Constants.HttpHeaders.IndexingDirective] = options.indexingDirective;
            }
            if (options.consistencyLevel) {
                headers[Constants.HttpHeaders.ConsistencyLevel] = options.consistencyLevel;
            }
            if (options.resourceTokenExpirySeconds) {
                headers[Constants.HttpHeaders.ResourceTokenExpiry] = options.resourceTokenExpirySeconds;
            }
            if (options.sessionToken) {
                headers[Constants.HttpHeaders.SessionToken] = options.sessionToken;
            }
            if (options.enableScanInQuery) {
                headers[Constants.HttpHeaders.EnableScanInQuery] = options.enableScanInQuery;
            }
            if (options.populateQuotaInfo) {
                headers[Constants.HttpHeaders.PopulateQuotaInfo] = options.populateQuotaInfo;
            }
            if (options.populateQueryMetrics) {
                headers[Constants.HttpHeaders.PopulateQueryMetrics] = options.populateQueryMetrics;
            }
            if (options.maxDegreeOfParallelism !== undefined) {
                headers[Constants.HttpHeaders.ParallelizeCrossPartitionQuery] = true;
            }
            if (options.populateQuotaInfo) {
                headers[Constants.HttpHeaders.PopulateQuotaInfo] = true;
            }
            if (partitionKey !== undefined && !headers[Constants.HttpHeaders.PartitionKey]) {
                if (partitionKey === null || !Array.isArray(partitionKey)) {
                    partitionKey = [partitionKey];
                }
                headers[Constants.HttpHeaders.PartitionKey] = jsonStringifyAndEscapeNonASCII(partitionKey);
            }
            if (clientOptions.key || clientOptions.tokenProvider) {
                headers[Constants.HttpHeaders.XDate] = new Date().toUTCString();
            }
            if (verb === HTTPMethod.post || verb === HTTPMethod.put) {
                if (!headers[Constants.HttpHeaders.ContentType]) {
                    headers[Constants.HttpHeaders.ContentType] = JsonContentType;
                }
            }
            if (!headers[Constants.HttpHeaders.Accept]) {
                headers[Constants.HttpHeaders.Accept] = JsonContentType;
            }
            if (partitionKeyRangeId !== undefined) {
                headers[Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;
            }
            if (options.enableScriptLogging) {
                headers[Constants.HttpHeaders.EnableScriptLogging] = options.enableScriptLogging;
            }
            if (options.disableRUPerMinuteUsage) {
                headers[Constants.HttpHeaders.DisableRUPerMinuteUsage] = true;
            }
            if (clientOptions.key ||
                clientOptions.resourceTokens ||
                clientOptions.tokenProvider ||
                clientOptions.permissionFeed) {
                yield setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers);
            }
            return headers;
        });
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * @ignore
     */
    const TimeoutErrorCode = "TimeoutError";
    class TimeoutError extends Error {
        constructor(message) {
            super(message);
            this.code = TimeoutErrorCode;
            this.name = TimeoutErrorCode;
        }
    }

    /**
     * @ignore
     */
    // Windows Socket Error Codes
    const WindowsInterruptedFunctionCall = 10004;
    /**
     * @ignore
     */
    const WindowsFileHandleNotValid = 10009;
    /**
     * @ignore
     */
    const WindowsPermissionDenied = 10013;
    /**
     * @ignore
     */
    const WindowsBadAddress = 10014;
    /**
     * @ignore
     */
    const WindowsInvalidArgumnet = 10022;
    /**
     * @ignore
     */
    const WindowsResourceTemporarilyUnavailable = 10035;
    /**
     * @ignore
     */
    const WindowsOperationNowInProgress = 10036;
    /**
     * @ignore
     */
    const WindowsAddressAlreadyInUse = 10048;
    /**
     * @ignore
     */
    const WindowsConnectionResetByPeer = 10054;
    /**
     * @ignore
     */
    const WindowsCannotSendAfterSocketShutdown = 10058;
    /**
     * @ignore
     */
    const WindowsConnectionTimedOut = 10060;
    /**
     * @ignore
     */
    const WindowsConnectionRefused = 10061;
    /**
     * @ignore
     */
    const WindowsNameTooLong = 10063;
    /**
     * @ignore
     */
    const WindowsHostIsDown = 10064;
    /**
     * @ignore
     */
    const WindowsNoRouteTohost = 10065;
    /**
     * @ignore
     */
    // Linux Error Codes
    /**
     * @ignore
     */
    const LinuxConnectionReset = "ECONNRESET";
    // Node Error Codes
    /**
     * @ignore
     */
    const BrokenPipe = "EPIPE";
    /**
     * @ignore
     */
    const CONNECTION_ERROR_CODES = [
        WindowsInterruptedFunctionCall,
        WindowsFileHandleNotValid,
        WindowsPermissionDenied,
        WindowsBadAddress,
        WindowsInvalidArgumnet,
        WindowsResourceTemporarilyUnavailable,
        WindowsOperationNowInProgress,
        WindowsAddressAlreadyInUse,
        WindowsConnectionResetByPeer,
        WindowsCannotSendAfterSocketShutdown,
        WindowsConnectionTimedOut,
        WindowsConnectionRefused,
        WindowsNameTooLong,
        WindowsHostIsDown,
        WindowsNoRouteTohost,
        LinuxConnectionReset,
        TimeoutErrorCode,
        BrokenPipe
    ];
    /**
     * @ignore
     */
    function needsRetry(operationType, code) {
        if ((operationType === exports.OperationType.Read || operationType === exports.OperationType.Query) &&
            CONNECTION_ERROR_CODES.indexOf(code) !== -1) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * This class implements the default connection retry policy for requests.
     * @property {int} currentRetryAttemptCount           - Current retry attempt count.
     * @hidden
     * @ignore
     */
    class DefaultRetryPolicy {
        constructor(operationType) {
            this.operationType = operationType;
            this.maxTries = 10;
            this.currentRetryAttemptCount = 0;
            this.retryAfterInMs = 1000;
        }
        /**
         * Determines whether the request should be retried or not.
         * @param {object} err - Error returned by the request.
         */
        shouldRetry(err) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (err) {
                    if (this.currentRetryAttemptCount < this.maxTries &&
                        needsRetry(this.operationType, err.code)) {
                        this.currentRetryAttemptCount++;
                        return true;
                    }
                }
                return false;
            });
        }
    }

    /**
     * This class implements the retry policy for endpoint discovery.
     * @hidden
     */
    class EndpointDiscoveryRetryPolicy {
        /**
         * @constructor EndpointDiscoveryRetryPolicy
         * @param {object} globalEndpointManager The GlobalEndpointManager instance.
         */
        constructor(globalEndpointManager, operationType) {
            this.globalEndpointManager = globalEndpointManager;
            this.operationType = operationType;
            this.maxTries = EndpointDiscoveryRetryPolicy.maxTries;
            this.currentRetryAttemptCount = 0;
            this.retryAfterInMs = EndpointDiscoveryRetryPolicy.retryAfterInMs;
        }
        /**
         * Determines whether the request should be retried or not.
         * @param {object} err - Error returned by the request.
         */
        shouldRetry(err, retryContext, locationEndpoint) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!err) {
                    return false;
                }
                if (!retryContext || !locationEndpoint) {
                    return false;
                }
                if (!this.globalEndpointManager.enableEndpointDiscovery) {
                    return false;
                }
                if (this.currentRetryAttemptCount >= this.maxTries) {
                    return false;
                }
                this.currentRetryAttemptCount++;
                if (isReadRequest(this.operationType)) {
                    yield this.globalEndpointManager.markCurrentLocationUnavailableForRead(locationEndpoint);
                }
                else {
                    yield this.globalEndpointManager.markCurrentLocationUnavailableForWrite(locationEndpoint);
                }
                retryContext.retryCount = this.currentRetryAttemptCount;
                retryContext.clearSessionTokenNotAvailable = false;
                retryContext.retryRequestOnPreferredLocations = false;
                return true;
            });
        }
    }
    EndpointDiscoveryRetryPolicy.maxTries = 120; // TODO: Constant?
    EndpointDiscoveryRetryPolicy.retryAfterInMs = 1000;

    /**
     * This class implements the resource throttle retry policy for requests.
     * @hidden
     */
    class ResourceThrottleRetryPolicy {
        /**
         * @constructor ResourceThrottleRetryPolicy
         * @param {int} maxTries - Max number of retries to be performed for a request.
         * @param {int} fixedRetryIntervalInMs   - Fixed retry interval in milliseconds to wait between each \
         * retry ignoring the retryAfter returned as part of the response.
         * @param {int} timeoutInSeconds               - Max wait time in seconds to wait for a request while the \
         * retries are happening.
         */
        constructor(maxTries = 9, fixedRetryIntervalInMs = 0, timeoutInSeconds = 30) {
            this.maxTries = maxTries;
            this.fixedRetryIntervalInMs = fixedRetryIntervalInMs;
            /** Current retry attempt count. */
            this.currentRetryAttemptCount = 0;
            /** Cummulative wait time in milliseconds for a request while the retries are happening. */
            this.cummulativeWaitTimeinMs = 0;
            /** Max wait time in milliseconds to wait for a request while the retries are happening. */
            this.retryAfterInMs = 0;
            this.timeoutInMs = timeoutInSeconds * 1000;
            this.currentRetryAttemptCount = 0;
            this.cummulativeWaitTimeinMs = 0;
        }
        /**
         * Determines whether the request should be retried or not.
         * @param {object} err - Error returned by the request.
         */
        shouldRetry(err) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // TODO: any custom error object
                if (err) {
                    if (this.currentRetryAttemptCount < this.maxTries) {
                        this.currentRetryAttemptCount++;
                        this.retryAfterInMs = 0;
                        if (this.fixedRetryIntervalInMs) {
                            this.retryAfterInMs = this.fixedRetryIntervalInMs;
                        }
                        else if (err.retryAfterInMs) {
                            this.retryAfterInMs = err.retryAfterInMs;
                        }
                        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {
                            this.cummulativeWaitTimeinMs += this.retryAfterInMs;
                            return true;
                        }
                    }
                }
                return false;
            });
        }
    }

    /**
     * This class implements the retry policy for session consistent reads.
     * @hidden
     */
    class SessionRetryPolicy {
        /**
         * @constructor SessionReadRetryPolicy
         * @param {object} globalEndpointManager                           - The GlobalEndpointManager instance.
         * @property {object} request                                      - The Http request information
         */
        constructor(globalEndpointManager, resourceType, operationType, connectionPolicy) {
            this.globalEndpointManager = globalEndpointManager;
            this.resourceType = resourceType;
            this.operationType = operationType;
            this.connectionPolicy = connectionPolicy;
            /** Current retry attempt count. */
            this.currentRetryAttemptCount = 0;
            /** Retry interval in milliseconds. */
            this.retryAfterInMs = 0;
        }
        /**
         * Determines whether the request should be retried or not.
         * @param {object} err - Error returned by the request.
         * @param {function} callback - The callback function which takes bool argument which specifies whether the request\
         * will be retried or not.
         */
        shouldRetry(err, retryContext) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!err) {
                    return false;
                }
                if (!retryContext) {
                    return false;
                }
                if (!this.connectionPolicy.enableEndpointDiscovery) {
                    return false;
                }
                if (this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)) {
                    // If we can write to multiple locations, we should against every write endpoint until we succeed
                    const endpoints = isReadRequest(this.operationType)
                        ? yield this.globalEndpointManager.getReadEndpoints()
                        : yield this.globalEndpointManager.getWriteEndpoints();
                    if (this.currentRetryAttemptCount > endpoints.length) {
                        return false;
                    }
                    else {
                        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;
                        retryContext.clearSessionTokenNotAvailable =
                            this.currentRetryAttemptCount === endpoints.length;
                        return true;
                    }
                }
                else {
                    if (this.currentRetryAttemptCount > 1) {
                        return false;
                    }
                    else {
                        retryContext.retryCount = ++this.currentRetryAttemptCount - 1;
                        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint
                        retryContext.clearSessionTokenNotAvailable = true;
                        return true;
                    }
                }
            });
        }
    }

    /**
     *
     * @param param0
     * @ignore
     */
    function execute({ retryContext = {}, retryPolicies, requestContext, executeRequest }) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // TODO: any response
            if (!retryPolicies) {
                retryPolicies = {
                    endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(requestContext.globalEndpointManager, requestContext.operationType),
                    resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount, requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds, requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds),
                    sessionReadRetryPolicy: new SessionRetryPolicy(requestContext.globalEndpointManager, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy),
                    defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)
                };
            }
            if (retryContext && retryContext.clearSessionTokenNotAvailable) {
                requestContext.client.clearSessionToken(requestContext.path);
            }
            requestContext.endpoint = yield requestContext.globalEndpointManager.resolveServiceEndpoint(requestContext.resourceType, requestContext.operationType);
            try {
                const response = yield executeRequest(requestContext);
                response.headers[Constants.ThrottleRetryCount] =
                    retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
                response.headers[Constants.ThrottleRetryWaitTimeInMs] =
                    retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;
                return response;
            }
            catch (err) {
                // TODO: any error
                let retryPolicy = null;
                const headers = err.headers || {};
                if (err.code === StatusCodes.Forbidden &&
                    (err.substatus === SubStatusCodes.DatabaseAccountNotFound ||
                        err.substatus === SubStatusCodes.WriteForbidden)) {
                    retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;
                }
                else if (err.code === StatusCodes.TooManyRequests) {
                    retryPolicy = retryPolicies.resourceThrottleRetryPolicy;
                }
                else if (err.code === StatusCodes.NotFound &&
                    err.substatus === SubStatusCodes.ReadSessionNotAvailable) {
                    retryPolicy = retryPolicies.sessionReadRetryPolicy;
                }
                else {
                    retryPolicy = retryPolicies.defaultRetryPolicy;
                }
                const results = yield retryPolicy.shouldRetry(err, retryContext, requestContext.endpoint);
                if (!results) {
                    headers[Constants.ThrottleRetryCount] =
                        retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
                    headers[Constants.ThrottleRetryWaitTimeInMs] =
                        retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;
                    err.headers = Object.assign(Object.assign({}, err.headers), headers);
                    throw err;
                }
                else {
                    requestContext.retryCount++;
                    const newUrl = results[1]; // TODO: any hack
                    if (newUrl !== undefined) {
                        requestContext.endpoint = newUrl;
                    }
                    yield sleep(retryPolicy.retryAfterInMs);
                    return execute({
                        executeRequest,
                        requestContext,
                        retryContext,
                        retryPolicies
                    });
                }
            }
        });
    }

    /**
     * @ignore
     */
    let defaultHttpAgent;
    /**
     * @ignore
     */
    let defaultHttpsAgent;
    if (isNode) {
        // tslint:disable-next-line:no-var-requires
        const https = require("https");
        // tslint:disable-next-line:no-var-requires
        const tls = require("tls");
        // minVersion only available in Node 10+
        if (tls.DEFAULT_MIN_VERSION) {
            defaultHttpsAgent = new https.Agent({
                keepAlive: true,
                minVersion: "TLSv1.2"
            });
        }
        else {
            // Remove when Node 8 support has been dropped
            defaultHttpsAgent = new https.Agent({
                keepAlive: true,
                secureProtocol: "TLSv1_2_method"
            });
        }
        // tslint:disable-next-line:no-var-requires
        const http = require("http");
        defaultHttpAgent = new http.Agent({
            keepAlive: true
        });
    }

    /** @hidden */
    const log$2 = logger("RequestHandler");
    function executeRequest(requestContext) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return executePlugins(requestContext, httpRequest, exports.PluginOn.request);
        });
    }
    /**
     * @ignore
     * @param requestContext
     */
    function httpRequest(requestContext) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const controller = new AbortController();
            const signal = controller.signal;
            // Wrap users passed abort events and call our own internal abort()
            const userSignal = requestContext.options && requestContext.options.abortSignal;
            if (userSignal) {
                if (userSignal) {
                    controller.abort();
                }
                else {
                    userSignal.addEventListener("abort", () => {
                        controller.abort();
                    });
                }
            }
            const timeout = setTimeout(() => {
                controller.abort();
            }, requestContext.connectionPolicy.requestTimeout);
            let response;
            if (requestContext.body) {
                requestContext.body = bodyFromData(requestContext.body);
            }
            try {
                response = yield fetch(trimSlashes(requestContext.endpoint) + requestContext.path, {
                    method: requestContext.method,
                    headers: requestContext.headers,
                    agent: (parsedUrl) => {
                        if (requestContext.requestAgent) {
                            return requestContext.requestAgent;
                        }
                        return parsedUrl.protocol === "http" ? defaultHttpAgent : defaultHttpsAgent;
                    },
                    signal,
                    body: requestContext.body
                });
            }
            catch (error) {
                if (error.name === "AbortError") {
                    // If the user passed signal caused the abort, cancel the timeout and rethrow the error
                    if (userSignal && userSignal.aborted === true) {
                        clearTimeout(timeout);
                        throw error;
                    }
                    // If the user didn't cancel, it must be an abort we called due to timeout
                    throw new TimeoutError();
                }
                throw error;
            }
            clearTimeout(timeout);
            const result = response.status === 204 || response.status === 304 ? null : yield response.json();
            const headers = {};
            response.headers.forEach((value, key) => {
                headers[key] = value;
            });
            const substatus = headers[Constants.HttpHeaders.SubStatus]
                ? parseInt(headers[Constants.HttpHeaders.SubStatus], 10)
                : undefined;
            if (response.status >= 400) {
                const errorResponse = new Error(result.message);
                log$2.warn(response.status +
                    " " +
                    requestContext.endpoint +
                    " " +
                    requestContext.path +
                    " " +
                    result.message);
                errorResponse.code = response.status;
                errorResponse.body = result;
                errorResponse.headers = headers;
                if (Constants.HttpHeaders.ActivityId in headers) {
                    errorResponse.activityId = headers[Constants.HttpHeaders.ActivityId];
                }
                if (Constants.HttpHeaders.SubStatus in headers) {
                    errorResponse.substatus = substatus;
                }
                if (Constants.HttpHeaders.RetryAfterInMs in headers) {
                    errorResponse.retryAfterInMs = parseInt(headers[Constants.HttpHeaders.RetryAfterInMs], 10);
                    Object.defineProperty(errorResponse, "retryAfterInMilliseconds", {
                        get: () => {
                            return errorResponse.retryAfterInMs;
                        }
                    });
                }
                throw errorResponse;
            }
            return {
                headers,
                result,
                code: response.status,
                substatus
            };
        });
    }
    /**
     * @ignore
     * @param requestContext
     */
    function request(requestContext) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (requestContext.body) {
                requestContext.body = bodyFromData(requestContext.body);
                if (!requestContext.body) {
                    throw new Error("parameter data must be a javascript object, string, or Buffer");
                }
            }
            return execute({
                requestContext,
                executeRequest
            });
        });
    }

    function atob(str) {
        return Buffer.from(str, "base64").toString("binary");
    }

    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
     * Models vector clock bases session token. Session token has the following format:
     * {Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}
     * 'Version' captures the configuration number of the partition which returned this session token.
     * 'Version' is incremented everytime topology of the partition is updated (say due to Add/Remove/Failover).
     *
     * The choice of separators '#' and '=' is important. Separators ';' and ',' are used to delimit
     * per-partitionKeyRange session token
     * @hidden
     * @private
     *
     */
    class VectorSessionToken {
        constructor(version, globalLsn, localLsnByregion, sessionToken) {
            this.version = version;
            this.globalLsn = globalLsn;
            this.localLsnByregion = localLsnByregion;
            this.sessionToken = sessionToken;
            if (!this.sessionToken) {
                const regionAndLocalLsn = [];
                for (const [key, value] of this.localLsnByregion.entries()) {
                    regionAndLocalLsn.push(`${key}${VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);
                }
                const regionProgress = regionAndLocalLsn.join(VectorSessionToken.SEGMENT_SEPARATOR);
                if (regionProgress === "") {
                    this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;
                }
                else {
                    this.sessionToken = `${this.version}${VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;
                }
            }
        }
        static create(sessionToken) {
            if (!sessionToken) {
                return null;
            }
            const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(VectorSessionToken.SEGMENT_SEPARATOR);
            const version = parseInt(versionStr, 10);
            const globalLsn = parseFloat(globalLsnStr);
            if (typeof version !== "number" || typeof globalLsn !== "number") {
                return null;
            }
            const lsnByRegion = new Map();
            for (const regionSegment of regionSegments) {
                const [regionIdStr, localLsnStr] = regionSegment.split(VectorSessionToken.REGION_PROGRESS_SEPARATOR);
                if (!regionIdStr || !localLsnStr) {
                    return null;
                }
                const regionId = parseInt(regionIdStr, 10);
                let localLsn;
                try {
                    localLsn = localLsnStr;
                }
                catch (err) {
                    // TODO: log error
                    return null;
                }
                if (typeof regionId !== "number") {
                    return null;
                }
                lsnByRegion.set(regionId, localLsn);
            }
            return new VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);
        }
        equals(other) {
            return !other
                ? false
                : this.version === other.version &&
                    this.globalLsn === other.globalLsn &&
                    this.areRegionProgressEqual(other.localLsnByregion);
        }
        merge(other) {
            if (other == null) {
                throw new Error("other (Vector Session Token) must not be null");
            }
            if (this.version === other.version &&
                this.localLsnByregion.size !== other.localLsnByregion.size) {
                throw new Error(`Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`);
            }
            const [higherVersionSessionToken, lowerVersionSessionToken] = this.version < other.version ? [other, this] : [this, other];
            const highestLocalLsnByRegion = new Map();
            for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {
                const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);
                if (lowLocalLsn) {
                    highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));
                }
                else if (this.version === other.version) {
                    throw new Error(`Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`);
                }
                else {
                    highestLocalLsnByRegion.set(regionId, highLocalLsn);
                }
            }
            return new VectorSessionToken(Math.max(this.version, other.version), Math.max(this.globalLsn, other.globalLsn), highestLocalLsnByRegion);
        }
        toString() {
            return this.sessionToken;
        }
        areRegionProgressEqual(other) {
            if (this.localLsnByregion.size !== other.size) {
                return false;
            }
            for (const [regionId, localLsn] of this.localLsnByregion.entries()) {
                const otherLocalLsn = other.get(regionId);
                if (localLsn !== otherLocalLsn) {
                    return false;
                }
            }
            return true;
        }
    }
    VectorSessionToken.SEGMENT_SEPARATOR = "#";
    VectorSessionToken.REGION_PROGRESS_SEPARATOR = "=";
    /**
     * @ignore
     * @param int1
     * @param int2
     */
    function max(int1, int2) {
        // NOTE: This only works for positive numbers
        if (int1.length === int2.length) {
            return int1 > int2 ? int1 : int2;
        }
        else if (int1.length > int2.length) {
            return int1;
        }
        else {
            return int2;
        }
    }

    // Copyright (c) Microsoft Corporation.
    /** @hidden */
    class SessionContainer {
        constructor(collectionNameToCollectionResourceId = new Map(), collectionResourceIdToSessionTokens = new Map()) {
            this.collectionNameToCollectionResourceId = collectionNameToCollectionResourceId;
            this.collectionResourceIdToSessionTokens = collectionResourceIdToSessionTokens;
        }
        get(request) {
            if (!request) {
                throw new Error("request cannot be null");
            }
            const collectionName = getContainerLink(trimSlashes(request.resourceAddress));
            const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);
            return SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);
        }
        remove(request) {
            let collectionResourceId;
            const resourceAddress = trimSlashes(request.resourceAddress);
            const collectionName = getContainerLink(resourceAddress);
            if (collectionName) {
                collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);
                this.collectionNameToCollectionResourceId.delete(collectionName);
            }
            if (collectionResourceId !== undefined) {
                this.collectionResourceIdToSessionTokens.delete(collectionResourceId);
            }
        }
        set(request, resHeaders) {
            // TODO: we check the master logic a few different places. Might not need it.
            if (!resHeaders ||
                SessionContainer.isReadingFromMaster(request.resourceType, request.operationType)) {
                return;
            }
            const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];
            if (!sessionTokenString) {
                return;
            }
            const containerName = this.getContainerName(request, resHeaders);
            const ownerId = !request.isNameBased
                ? request.resourceId
                : resHeaders[Constants.HttpHeaders.OwnerId] || request.resourceId;
            if (!ownerId) {
                return;
            }
            if (containerName && this.validateOwnerID(ownerId)) {
                if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {
                    this.collectionResourceIdToSessionTokens.set(ownerId, new Map());
                }
                if (!this.collectionNameToCollectionResourceId.has(containerName)) {
                    this.collectionNameToCollectionResourceId.set(containerName, ownerId);
                }
                const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);
                SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);
            }
        }
        validateOwnerID(ownerId) {
            // If ownerId contains exactly 8 bytes it represents a unique database+collection identifier. Otherwise it represents another resource
            // The first 4 bytes are the database. The last 4 bytes are the collection.
            // Cosmos rids potentially contain "-" which is an invalid character in the browser atob implementation
            // See https://en.wikipedia.org/wiki/Base64#Filenames
            return atob(ownerId.replace(/-/g, "/")).length === 8;
        }
        getPartitionKeyRangeIdToTokenMap(collectionName) {
            let rangeIdToTokenMap = null;
            if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {
                rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(this.collectionNameToCollectionResourceId.get(collectionName));
            }
            return rangeIdToTokenMap;
        }
        static getCombinedSessionTokenString(tokens) {
            if (!tokens || tokens.size === 0) {
                return SessionContainer.EMPTY_SESSION_TOKEN;
            }
            let result = "";
            for (const [range, token] of tokens.entries()) {
                result +=
                    range +
                        SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER +
                        token.toString() +
                        SessionContainer.SESSION_TOKEN_SEPARATOR;
            }
            return result.slice(0, -1);
        }
        static compareAndSetToken(newTokenString, containerSessionTokens) {
            if (!newTokenString) {
                return;
            }
            const partitionsParts = newTokenString.split(SessionContainer.SESSION_TOKEN_SEPARATOR);
            for (const partitionPart of partitionsParts) {
                const newTokenParts = partitionPart.split(SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);
                if (newTokenParts.length !== 2) {
                    return;
                }
                const range = newTokenParts[0];
                const newToken = VectorSessionToken.create(newTokenParts[1]);
                const tokenForRange = !containerSessionTokens.get(range)
                    ? newToken
                    : containerSessionTokens.get(range).merge(newToken);
                containerSessionTokens.set(range, tokenForRange);
            }
        }
        // TODO: have a assert if the type doesn't mastch known types
        static isReadingFromMaster(resourceType, operationType) {
            if (resourceType === Constants.Path.OffersPathSegment ||
                resourceType === Constants.Path.DatabasesPathSegment ||
                resourceType === Constants.Path.UsersPathSegment ||
                resourceType === Constants.Path.PermissionsPathSegment ||
                resourceType === Constants.Path.TopologyPathSegment ||
                resourceType === Constants.Path.DatabaseAccountPathSegment ||
                resourceType === Constants.Path.PartitionKeyRangesPathSegment ||
                (resourceType === Constants.Path.CollectionsPathSegment &&
                    operationType === exports.OperationType.Query)) {
                return true;
            }
            return false;
        }
        getContainerName(request, headers) {
            let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];
            if (!ownerFullName) {
                ownerFullName = trimSlashes(request.resourceAddress);
            }
            return getContainerLink(ownerFullName);
        }
    }
    SessionContainer.EMPTY_SESSION_TOKEN = "";
    SessionContainer.SESSION_TOKEN_SEPARATOR = ",";
    SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER = ":";

    /** @hidden */
    const log$3 = logger("ClientContext");
    const QueryJsonContentType = "application/query+json";
    /**
     * @hidden
     * @ignore
     */
    class ClientContext {
        constructor(cosmosClientOptions, globalEndpointManager) {
            this.cosmosClientOptions = cosmosClientOptions;
            this.globalEndpointManager = globalEndpointManager;
            this.connectionPolicy = cosmosClientOptions.connectionPolicy;
            this.sessionContainer = new SessionContainer();
            this.partitionKeyDefinitionCache = {};
        }
        /** @ignore */
        read({ path, resourceType, resourceId, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const request$1 = {
                        globalEndpointManager: this.globalEndpointManager,
                        requestAgent: this.cosmosClientOptions.agent,
                        connectionPolicy: this.connectionPolicy,
                        method: HTTPMethod.get,
                        path,
                        operationType: exports.OperationType.Read,
                        client: this,
                        resourceId,
                        options,
                        resourceType,
                        plugins: this.cosmosClientOptions.plugins,
                        partitionKey
                    };
                    request$1.headers = yield this.buildHeaders(request$1);
                    this.applySessionToken(request$1);
                    // read will use ReadEndpoint since it uses GET operation
                    request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                    const response = yield executePlugins(request$1, request, exports.PluginOn.operation);
                    this.captureSessionToken(undefined, path, exports.OperationType.Read, response.headers);
                    return response;
                }
                catch (err) {
                    this.captureSessionToken(err, path, exports.OperationType.Upsert, err.headers);
                    throw err;
                }
            });
        }
        queryFeed({ path, resourceType, resourceId, resultFn, query, options, partitionKeyRangeId, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // Query operations will use ReadEndpoint even though it uses
                // GET(for queryFeed) and POST(for regular query operations)
                const request$1 = {
                    globalEndpointManager: this.globalEndpointManager,
                    requestAgent: this.cosmosClientOptions.agent,
                    connectionPolicy: this.connectionPolicy,
                    method: HTTPMethod.get,
                    path,
                    operationType: exports.OperationType.Query,
                    client: this,
                    partitionKeyRangeId,
                    resourceId,
                    resourceType,
                    options,
                    body: query,
                    plugins: this.cosmosClientOptions.plugins,
                    partitionKey
                };
                const requestId = uuid();
                if (query !== undefined) {
                    request$1.method = HTTPMethod.post;
                }
                request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                request$1.headers = yield this.buildHeaders(request$1);
                if (query !== undefined) {
                    request$1.headers[Constants.HttpHeaders.IsQuery] = "true";
                    request$1.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;
                    if (typeof query === "string") {
                        request$1.body = { query }; // Converts query text to query object.
                    }
                }
                this.applySessionToken(request$1);
                log$3.info("query " +
                    requestId +
                    " started" +
                    (request$1.partitionKeyRangeId ? " pkrid: " + request$1.partitionKeyRangeId : ""));
                log$3.silly(request$1);
                const start = Date.now();
                const response = yield request(request$1);
                log$3.info("query " + requestId + " finished - " + (Date.now() - start) + "ms");
                this.captureSessionToken(undefined, path, exports.OperationType.Query, response.headers);
                return this.processQueryFeedResponse(response, !!query, resultFn);
            });
        }
        getQueryPlan(path, resourceType, resourceId, query, options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const request$1 = {
                    globalEndpointManager: this.globalEndpointManager,
                    requestAgent: this.cosmosClientOptions.agent,
                    connectionPolicy: this.connectionPolicy,
                    method: HTTPMethod.post,
                    path,
                    operationType: exports.OperationType.Read,
                    client: this,
                    resourceId,
                    resourceType,
                    options,
                    body: query,
                    plugins: this.cosmosClientOptions.plugins
                };
                request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                request$1.headers = yield this.buildHeaders(request$1);
                request$1.headers[Constants.HttpHeaders.IsQueryPlan] = "True";
                request$1.headers[Constants.HttpHeaders.QueryVersion] = "1.4";
                request$1.headers[Constants.HttpHeaders.SupportedQueryFeatures] =
                    "NonValueAggregate, Aggregate, Distinct, MultipleOrderBy, OffsetAndLimit, OrderBy, Top, CompositeAggregate, GroupBy, MultipleAggregates";
                request$1.headers[Constants.HttpHeaders.ContentType] = QueryJsonContentType;
                if (typeof query === "string") {
                    request$1.body = { query }; // Converts query text to query object.
                }
                this.applySessionToken(request$1);
                const response = yield request(request$1);
                this.captureSessionToken(undefined, path, exports.OperationType.Query, response.headers);
                return response;
            });
        }
        queryPartitionKeyRanges(collectionLink, query, options) {
            const path = getPathFromLink(collectionLink, ResourceType.pkranges);
            const id = getIdFromLink(collectionLink);
            const cb = (innerOptions) => {
                return this.queryFeed({
                    path,
                    resourceType: ResourceType.pkranges,
                    resourceId: id,
                    resultFn: (result) => result.PartitionKeyRanges,
                    query,
                    options: innerOptions
                });
            };
            return new QueryIterator(this, query, options, cb);
        }
        delete({ path, resourceType, resourceId, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const request$1 = {
                        globalEndpointManager: this.globalEndpointManager,
                        requestAgent: this.cosmosClientOptions.agent,
                        connectionPolicy: this.connectionPolicy,
                        method: HTTPMethod.delete,
                        client: this,
                        operationType: exports.OperationType.Delete,
                        path,
                        resourceType,
                        options,
                        resourceId,
                        plugins: this.cosmosClientOptions.plugins,
                        partitionKey
                    };
                    request$1.headers = yield this.buildHeaders(request$1);
                    this.applySessionToken(request$1);
                    // deleteResource will use WriteEndpoint since it uses DELETE operation
                    request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                    const response = yield executePlugins(request$1, request, exports.PluginOn.operation);
                    if (parseLink(path).type !== "colls") {
                        this.captureSessionToken(undefined, path, exports.OperationType.Delete, response.headers);
                    }
                    else {
                        this.clearSessionToken(path);
                    }
                    return response;
                }
                catch (err) {
                    this.captureSessionToken(err, path, exports.OperationType.Upsert, err.headers);
                    throw err;
                }
            });
        }
        create({ body, path, resourceType, resourceId, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const request$1 = {
                        globalEndpointManager: this.globalEndpointManager,
                        requestAgent: this.cosmosClientOptions.agent,
                        connectionPolicy: this.connectionPolicy,
                        method: HTTPMethod.post,
                        client: this,
                        operationType: exports.OperationType.Create,
                        path,
                        resourceType,
                        resourceId,
                        body,
                        options,
                        plugins: this.cosmosClientOptions.plugins,
                        partitionKey
                    };
                    request$1.headers = yield this.buildHeaders(request$1);
                    // create will use WriteEndpoint since it uses POST operation
                    this.applySessionToken(request$1);
                    request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                    const response = yield executePlugins(request$1, request, exports.PluginOn.operation);
                    this.captureSessionToken(undefined, path, exports.OperationType.Create, response.headers);
                    return response;
                }
                catch (err) {
                    this.captureSessionToken(err, path, exports.OperationType.Upsert, err.headers);
                    throw err;
                }
            });
        }
        processQueryFeedResponse(res, isQuery, resultFn) {
            if (isQuery) {
                return { result: resultFn(res.result), headers: res.headers, code: res.code };
            }
            else {
                const newResult = resultFn(res.result).map((body) => body);
                return { result: newResult, headers: res.headers, code: res.code };
            }
        }
        applySessionToken(requestContext) {
            const request = this.getSessionParams(requestContext.path);
            if (requestContext.headers && requestContext.headers[Constants.HttpHeaders.SessionToken]) {
                return;
            }
            const sessionConsistency = requestContext.headers[Constants.HttpHeaders.ConsistencyLevel];
            if (!sessionConsistency) {
                return;
            }
            if (sessionConsistency !== exports.ConsistencyLevel.Session) {
                return;
            }
            if (request.resourceAddress) {
                const sessionToken = this.sessionContainer.get(request);
                if (sessionToken) {
                    requestContext.headers[Constants.HttpHeaders.SessionToken] = sessionToken;
                }
            }
        }
        replace({ body, path, resourceType, resourceId, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const request$1 = {
                        globalEndpointManager: this.globalEndpointManager,
                        requestAgent: this.cosmosClientOptions.agent,
                        connectionPolicy: this.connectionPolicy,
                        method: HTTPMethod.put,
                        client: this,
                        operationType: exports.OperationType.Replace,
                        path,
                        resourceType,
                        body,
                        resourceId,
                        options,
                        plugins: this.cosmosClientOptions.plugins,
                        partitionKey
                    };
                    request$1.headers = yield this.buildHeaders(request$1);
                    this.applySessionToken(request$1);
                    // replace will use WriteEndpoint since it uses PUT operation
                    request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                    const response = yield executePlugins(request$1, request, exports.PluginOn.operation);
                    this.captureSessionToken(undefined, path, exports.OperationType.Replace, response.headers);
                    return response;
                }
                catch (err) {
                    this.captureSessionToken(err, path, exports.OperationType.Upsert, err.headers);
                    throw err;
                }
            });
        }
        upsert({ body, path, resourceType, resourceId, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const request$1 = {
                        globalEndpointManager: this.globalEndpointManager,
                        requestAgent: this.cosmosClientOptions.agent,
                        connectionPolicy: this.connectionPolicy,
                        method: HTTPMethod.post,
                        client: this,
                        operationType: exports.OperationType.Upsert,
                        path,
                        resourceType,
                        body,
                        resourceId,
                        options,
                        plugins: this.cosmosClientOptions.plugins,
                        partitionKey
                    };
                    request$1.headers = yield this.buildHeaders(request$1);
                    request$1.headers[Constants.HttpHeaders.IsUpsert] = true;
                    this.applySessionToken(request$1);
                    // upsert will use WriteEndpoint since it uses POST operation
                    request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                    const response = yield executePlugins(request$1, request, exports.PluginOn.operation);
                    this.captureSessionToken(undefined, path, exports.OperationType.Upsert, response.headers);
                    return response;
                }
                catch (err) {
                    this.captureSessionToken(err, path, exports.OperationType.Upsert, err.headers);
                    throw err;
                }
            });
        }
        execute({ sprocLink, params, options = {}, partitionKey }) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // Accept a single parameter or an array of parameters.
                // Didn't add type annotation for this because we should legacy this behavior
                if (params !== null && params !== undefined && !Array.isArray(params)) {
                    params = [params];
                }
                const path = getPathFromLink(sprocLink);
                const id = getIdFromLink(sprocLink);
                const request$1 = {
                    globalEndpointManager: this.globalEndpointManager,
                    requestAgent: this.cosmosClientOptions.agent,
                    connectionPolicy: this.connectionPolicy,
                    method: HTTPMethod.post,
                    client: this,
                    operationType: exports.OperationType.Execute,
                    path,
                    resourceType: ResourceType.sproc,
                    options,
                    resourceId: id,
                    body: params,
                    plugins: this.cosmosClientOptions.plugins,
                    partitionKey
                };
                request$1.headers = yield this.buildHeaders(request$1);
                // executeStoredProcedure will use WriteEndpoint since it uses POST operation
                request$1.endpoint = yield this.globalEndpointManager.resolveServiceEndpoint(request$1.resourceType, request$1.operationType);
                return executePlugins(request$1, request, exports.PluginOn.operation);
            });
        }
        /**
         * Gets the Database account information.
         * @param {string} [options.urlConnection]   - The endpoint url whose database account needs to be retrieved. \
         * If not present, current client's url will be used.
         */
        getDatabaseAccount(options = {}) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;
                const request$1 = {
                    endpoint,
                    globalEndpointManager: this.globalEndpointManager,
                    requestAgent: this.cosmosClientOptions.agent,
                    connectionPolicy: this.connectionPolicy,
                    method: HTTPMethod.get,
                    client: this,
                    operationType: exports.OperationType.Read,
                    path: "",
                    resourceType: ResourceType.none,
                    options,
                    plugins: this.cosmosClientOptions.plugins
                };
                request$1.headers = yield this.buildHeaders(request$1);
                // await options.beforeOperation({ endpoint, request, headers: requestHeaders });
                const { result, headers } = yield executePlugins(request$1, request, exports.PluginOn.operation);
                const databaseAccount = new DatabaseAccount(result, headers);
                return { result: databaseAccount, headers };
            });
        }
        getWriteEndpoint() {
            return this.globalEndpointManager.getWriteEndpoint();
        }
        getReadEndpoint() {
            return this.globalEndpointManager.getReadEndpoint();
        }
        captureSessionToken(err, path, operationType, resHeaders) {
            const request = this.getSessionParams(path);
            request.operationType = operationType;
            if (!err ||
                (!this.isMasterResource(request.resourceType) &&
                    (err.code === StatusCodes.PreconditionFailed ||
                        err.code === StatusCodes.Conflict ||
                        (err.code === StatusCodes.NotFound &&
                            err.substatus !== SubStatusCodes.ReadSessionNotAvailable)))) {
                this.sessionContainer.set(request, resHeaders);
            }
        }
        clearSessionToken(path) {
            const request = this.getSessionParams(path);
            this.sessionContainer.remove(request);
        }
        getSessionParams(resourceLink) {
            const resourceId = null;
            let resourceAddress = null;
            const parserOutput = parseLink(resourceLink);
            resourceAddress = parserOutput.objectBody.self;
            const resourceType = parserOutput.type;
            return {
                resourceId,
                resourceAddress,
                resourceType,
                isNameBased: true
            };
        }
        isMasterResource(resourceType) {
            if (resourceType === Constants.Path.OffersPathSegment ||
                resourceType === Constants.Path.DatabasesPathSegment ||
                resourceType === Constants.Path.UsersPathSegment ||
                resourceType === Constants.Path.PermissionsPathSegment ||
                resourceType === Constants.Path.TopologyPathSegment ||
                resourceType === Constants.Path.DatabaseAccountPathSegment ||
                resourceType === Constants.Path.PartitionKeyRangesPathSegment ||
                resourceType === Constants.Path.CollectionsPathSegment) {
                return true;
            }
            return false;
        }
        buildHeaders(requestContext) {
            return getHeaders({
                clientOptions: this.cosmosClientOptions,
                defaultHeaders: Object.assign(Object.assign({}, this.cosmosClientOptions.defaultHeaders), requestContext.options.initialHeaders),
                verb: requestContext.method,
                path: requestContext.path,
                resourceId: requestContext.resourceId,
                resourceType: requestContext.resourceType,
                options: requestContext.options,
                partitionKeyRangeId: requestContext.partitionKeyRangeId,
                useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,
                partitionKey: requestContext.partitionKey
            });
        }
    }

    /**
     * @hidden
     * This internal class implements the logic for endpoint management for geo-replicated database accounts.
     * @property {object} client                       - The document client instance.
     * @property {string} defaultEndpoint              - The endpoint used to create the client instance.
     * @property {bool} enableEndpointDiscovery        - Flag to enable/disable automatic redirecting of requests
     *                                                   based on read/write operations.
     * @property {Array} preferredLocations            - List of azure regions to be used as preferred locations
     *                                                   for read requests.
     * @property {bool} isEndpointCacheInitialized     - Flag to determine whether the endpoint cache is initialized or not.
     */
    class GlobalEndpointManager {
        /**
         * @constructor GlobalEndpointManager
         * @param {object} options                          - The document client instance.
         */
        constructor(options, readDatabaseAccount) {
            this.readDatabaseAccount = readDatabaseAccount;
            this.options = options;
            this.defaultEndpoint = options.endpoint;
            this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;
            this.isRefreshing = false;
            this.preferredLocations = this.options.connectionPolicy.preferredLocations;
        }
        /**
         * Gets the current read endpoint from the endpoint cache.
         */
        getReadEndpoint() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.resolveServiceEndpoint(ResourceType.item, exports.OperationType.Read);
            });
        }
        /**
         * Gets the current write endpoint from the endpoint cache.
         */
        getWriteEndpoint() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.resolveServiceEndpoint(ResourceType.item, exports.OperationType.Replace);
            });
        }
        getReadEndpoints() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);
            });
        }
        getWriteEndpoints() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);
            });
        }
        markCurrentLocationUnavailableForRead(endpoint) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                yield this.refreshEndpointList();
                const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);
                if (location) {
                    location.unavailable = true;
                }
            });
        }
        markCurrentLocationUnavailableForWrite(endpoint) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                yield this.refreshEndpointList();
                const location = this.writeableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);
                if (location) {
                    location.unavailable = true;
                }
            });
        }
        canUseMultipleWriteLocations(resourceType, operationType) {
            let canUse = this.options.connectionPolicy.useMultipleWriteLocations;
            if (resourceType) {
                canUse =
                    canUse &&
                        (resourceType === ResourceType.item ||
                            (resourceType === ResourceType.sproc && operationType === exports.OperationType.Execute));
            }
            return canUse;
        }
        resolveServiceEndpoint(resourceType, operationType) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                // If endpoint discovery is disabled, always use the user provided endpoint
                if (!this.options.connectionPolicy.enableEndpointDiscovery) {
                    return this.defaultEndpoint;
                }
                // If getting the database account, always use the user provided endpoint
                if (resourceType === ResourceType.none) {
                    return this.defaultEndpoint;
                }
                if (!this.readableLocations || !this.writeableLocations) {
                    const { resource: databaseAccount } = yield this.readDatabaseAccount({
                        urlConnection: this.defaultEndpoint
                    });
                    this.writeableLocations = databaseAccount.writableLocations;
                    this.readableLocations = databaseAccount.readableLocations;
                }
                const locations = isReadRequest(operationType)
                    ? this.readableLocations
                    : this.writeableLocations;
                let location;
                // If we have preferred locations, try each one in order and use the first available one
                if (this.preferredLocations && this.preferredLocations.length > 0) {
                    for (const preferredLocation of this.preferredLocations) {
                        location = locations.find((loc) => loc.unavailable !== true &&
                            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation));
                        if (location) {
                            break;
                        }
                    }
                }
                // If no preferred locations or one did not match, just grab the first one that is available
                if (!location) {
                    location = locations.find((loc) => {
                        return loc.unavailable !== true;
                    });
                }
                return location ? location.databaseAccountEndpoint : this.defaultEndpoint;
            });
        }
        /**
         * Refreshes the endpoint list by retrieving the writable and readable locations
         *  from the geo-replicated database account and then updating the locations cache.
         *   We skip the refreshing if enableEndpointDiscovery is set to False
         */
        refreshEndpointList() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                if (!this.isRefreshing && this.enableEndpointDiscovery) {
                    this.isRefreshing = true;
                    const databaseAccount = yield this.getDatabaseAccountFromAnyEndpoint();
                    if (databaseAccount) {
                        this.refreshEndpoints(databaseAccount);
                    }
                    this.isRefreshing = false;
                }
            });
        }
        refreshEndpoints(databaseAccount) {
            for (const location of databaseAccount.writableLocations) {
                const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);
                if (!existingLocation) {
                    this.writeableLocations.push(location);
                }
            }
            for (const location of databaseAccount.writableLocations) {
                const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);
                if (!existingLocation) {
                    this.readableLocations.push(location);
                }
            }
        }
        /**
         * Gets the database account first by using the default endpoint, and if that doesn't returns
         * use the endpoints for the preferred locations in the order they are specified to get
         * the database account.
         * @memberof GlobalEndpointManager
         * @instance
         * @param {function} callback        - The callback function which takes databaseAccount(object) as an argument.
         */
        getDatabaseAccountFromAnyEndpoint() {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                try {
                    const options = { urlConnection: this.defaultEndpoint };
                    const { resource: databaseAccount } = yield this.readDatabaseAccount(options);
                    return databaseAccount;
                    // If for any reason(non - globaldb related), we are not able to get the database
                    // account from the above call to readDatabaseAccount,
                    // we would try to get this information from any of the preferred locations that the user
                    // might have specified (by creating a locational endpoint)
                    // and keeping eating the exception until we get the database account and return None at the end,
                    // if we are not able to get that info from any endpoints
                }
                catch (err) {
                    // TODO: Tracing
                }
                if (this.preferredLocations) {
                    for (const location of this.preferredLocations) {
                        try {
                            const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(this.defaultEndpoint, location);
                            const options = { urlConnection: locationalEndpoint };
                            const { resource: databaseAccount } = yield this.readDatabaseAccount(options);
                            if (databaseAccount) {
                                return databaseAccount;
                            }
                        }
                        catch (err) {
                            // TODO: Tracing
                        }
                    }
                }
            });
        }
        /**
         * Gets the locational endpoint using the location name passed to it using the default endpoint.
         * @memberof GlobalEndpointManager
         * @instance
         * @param {string} defaultEndpoint - The default endpoint to use for the endpoint.
         * @param {string} locationName    - The location name for the azure region like "East US".
         */
        static getLocationalEndpoint(defaultEndpoint, locationName) {
            // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format
            // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)
            // and we agreed to document that
            const endpointUrl = new URL(defaultEndpoint);
            // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'
            if (endpointUrl.hostname) {
                const hostnameParts = endpointUrl.hostname
                    .toString()
                    .toLowerCase()
                    .split(".");
                if (hostnameParts) {
                    // globalDatabaseAccountName will return 'contoso'
                    const globalDatabaseAccountName = hostnameParts[0];
                    // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'
                    const locationalDatabaseAccountName = globalDatabaseAccountName + "-" + locationName.replace(" ", "");
                    // Replace 'contoso' with 'contoso-EastUS' and
                    // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/
                    const locationalEndpoint = defaultEndpoint
                        .toLowerCase()
                        .replace(globalDatabaseAccountName, locationalDatabaseAccountName);
                    return locationalEndpoint;
                }
            }
            return null;
        }
    }
    function normalizeEndpoint(endpoint) {
        return endpoint
            .split(" ")
            .join("")
            .toLowerCase();
    }

    /**
     * Provides a client-side logical representation of the Azure Cosmos DB database account.
     * This client is used to configure and execute requests in the Azure Cosmos DB database service.
     * @example Instantiate a client and create a new database
     * ```typescript
     * const client = new CosmosClient({endpoint: "<URL HERE>", auth: {masterKey: "<KEY HERE>"}});
     * await client.databases.create({id: "<datbase name here>"});
     * ```
     * @example Instantiate a client with custom Connection Policy
     * ```typescript
     * const connectionPolicy = new ConnectionPolicy();
     * connectionPolicy.RequestTimeout = 10000;
     * const client = new CosmosClient({
     *    endpoint: "<URL HERE>",
     *    auth: {masterKey: "<KEY HERE>"},
     *    connectionPolicy
     * });
     * ```
     */
    class CosmosClient {
        constructor(optionsOrConnectionString) {
            if (typeof optionsOrConnectionString === "string") {
                optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);
            }
            optionsOrConnectionString.connectionPolicy = Object.assign({}, defaultConnectionPolicy, optionsOrConnectionString.connectionPolicy);
            optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};
            optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = "no-cache";
            optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] =
                Constants.CurrentVersion;
            if (optionsOrConnectionString.consistencyLevel !== undefined) {
                optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] =
                    optionsOrConnectionString.consistencyLevel;
            }
            optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = getUserAgent(optionsOrConnectionString.userAgentSuffix);
            const globalEndpointManager = new GlobalEndpointManager(optionsOrConnectionString, (opts) => tslib.__awaiter(this, void 0, void 0, function* () { return this.getDatabaseAccount(opts); }));
            this.clientContext = new ClientContext(optionsOrConnectionString, globalEndpointManager);
            this.databases = new Databases(this, this.clientContext);
            this.offers = new Offers(this, this.clientContext);
        }
        /**
         * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)
         */
        getDatabaseAccount(options) {
            return tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.clientContext.getDatabaseAccount(options);
                return new ResourceResponse(response.result, response.headers, response.code);
            });
        }
        /**
         * Gets the currently used write endpoint url. Useful for troubleshooting purposes.
         *
         * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
         */
        getWriteEndpoint() {
            return this.clientContext.getWriteEndpoint();
        }
        /**
         * Gets the currently used read endpoint. Useful for troubleshooting purposes.
         *
         * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
         */
        getReadEndpoint() {
            return this.clientContext.getReadEndpoint();
        }
        /**
         * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.
         *
         * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.
         *
         * @param id The id of the database.
         * @example Create a new container off of an existing database
         * ```typescript
         * const container = client.database("<database id>").containers.create("<container id>");
         * ```
         *
         * @example Delete an existing database
         * ```typescript
         * await client.database("<id here>").delete();
         * ```
         */
        database(id) {
            return new Database(this, id, this.clientContext);
        }
        /**
         * Used for reading, or updating a existing offer by id.
         * @param id The id of the offer.
         */
        offer(id) {
            return new Offer(this, id, this.clientContext);
        }
    }

    exports.ClientSideMetrics = ClientSideMetrics;
    exports.Conflict = Conflict;
    exports.ConflictResponse = ConflictResponse;
    exports.Conflicts = Conflicts;
    exports.Constants = Constants;
    exports.Container = Container;
    exports.ContainerResponse = ContainerResponse;
    exports.Containers = Containers;
    exports.CosmosClient = CosmosClient;
    exports.DEFAULT_PARTITION_KEY_PATH = DEFAULT_PARTITION_KEY_PATH;
    exports.Database = Database;
    exports.DatabaseAccount = DatabaseAccount;
    exports.DatabaseResponse = DatabaseResponse;
    exports.Databases = Databases;
    exports.FeedResponse = FeedResponse;
    exports.Item = Item;
    exports.ItemResponse = ItemResponse;
    exports.Items = Items;
    exports.Offer = Offer;
    exports.OfferResponse = OfferResponse;
    exports.Offers = Offers;
    exports.Permission = Permission;
    exports.PermissionResponse = PermissionResponse;
    exports.Permissions = Permissions;
    exports.QueryIterator = QueryIterator;
    exports.QueryMetrics = QueryMetrics;
    exports.QueryMetricsConstants = QueryMetricsConstants;
    exports.QueryPreparationTimes = QueryPreparationTimes;
    exports.ResourceResponse = ResourceResponse;
    exports.RuntimeExecutionTimes = RuntimeExecutionTimes;
    exports.StatusCodes = StatusCodes;
    exports.StoredProcedure = StoredProcedure;
    exports.StoredProcedureResponse = StoredProcedureResponse;
    exports.StoredProcedures = StoredProcedures;
    exports.TimeSpan = TimeSpan;
    exports.Trigger = Trigger;
    exports.TriggerResponse = TriggerResponse;
    exports.Triggers = Triggers;
    exports.User = User;
    exports.UserDefinedFunction = UserDefinedFunction;
    exports.UserDefinedFunctionResponse = UserDefinedFunctionResponse;
    exports.UserDefinedFunctions = UserDefinedFunctions;
    exports.UserResponse = UserResponse;
    exports.Users = Users;
    exports.extractPartitionKey = extractPartitionKey;
    exports.setAuthorizationTokenHeaderUsingMasterKey = setAuthorizationTokenHeaderUsingMasterKey;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
